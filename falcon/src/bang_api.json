[
  {
    "content": "\n 3.1.1. __bang_move \n^^^^^^^^^^^^^^^\n void  __bang_move (void * dst ,  const  void * src , unsigned int  size )   \n Copies  <size>  bytes data from source address  <src>  to destination address  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination area.\n*  [in] src : The address of source area.\n*  [in] size : The number of bytes to be copied. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst>  can be overlapped with  <src> . \n \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(int8_t *dst, int8_t *src) {\n  __nram__ int8_t src1_nram[512];\n  __nram__ int8_t src2_nram[512];\n  __memcpy(src1_nram, src, 512, GDRAM2NRAM);\n  __bang_move(src2_nram, src1_nram, 512);\n  __memcpy(dst, src2_nram, 512, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.1.2. __memcpy \n^^^^^^^^^^^^^^^\n void  __memcpy (void * dst ,  const  void * src , unsigned int  size , mluMemcpyDirection_t  dir )   \n void  __memcpy (void * dst ,  const  void * src , unsigned int  size , mluMemcpyDirection_t  dir , unsigned int  id_dst_cluster )   \n Copies  <size>  bytes data from source address  <src>  to destination address  <dst> . The copy direction is specified by  <dir> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination area.\n*  [in] src : The address of source area.\n*  [in] size : The number of bytes to be copied.\n*  [in] dir : Copy direction.\n*  [in] id\\_dst\\_cluster : Destination cluster ID. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n* <id\\_dst\\_cluster>  is necessarily used when  <dir>  is SRAM2SRAM and data is copied across different clusters. When there is no  <id\\_dst\\_cluster> , it means copy within cluster;\n* If the size of the vector with the address space of WRAM is not 8-byte aligned on each LT, the value of the unaligned part is uncertain on  tp\\_322  and  (m)tp\\_372 , and is 0 on other targets;\n Instruction Pipeline * If  <dir>  is NRAM2NRAM, execute in Compute instruction pipeline;\n* If either  <src>  or  <dst>  is  off-chip address , execute in IO instruction pipeline, otherwise, execute in Move instruction pipeline;\n* If  <dir>  is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM or LDRAM2SRAM, execute on MPU core, otherwise, execute on MLU core. \n^^^^^^^^^^^^^^^\n Example \n```\nif (clusterId == 0) {\n  // Step1. load data from GDRAM to cluster0's SRAM\n  // auto running on MPU, no need to specify coreId == 0x80\n  __memcpy(S, src, size * coreDim, GDRAM2SRAM);\n  __sync_cluster(); \n // Step2. test inside cluster0\n  __memcpy(A, S + offset, size, SRAM2NRAM);\n  __memcpy(C, A, size, NRAM2NRAM);\n  __memcpy(S + offset, C, size, NRAM2SRAM);\n  __sync_cluster(); \n // Step3. push S from Cluster0 to Cluster1\n  __memcpy(S, S, size * coreDim, SRAM2SRAM, clusterId + 1);\n} \n ``` \n"
  },
  {
    "content": "\n 3.2.1. __bang_write_value \n^^^^^^^^^^^^^^^\n void  __bang_write_value (void * dst , unsigned int  elem_count , char  value )   \n void  __bang_write_value (void * dst , unsigned int  elem_count , int  value )   \n void  __bang_write_value (void * dst , unsigned int  elem_count , short  value )   \n void  __bang_write_value (void * dst , unsigned int  elem_count , bfloat16_t  value )   \n void  __bang_write_value (void * dst , unsigned int  elem_count , float  value )   \n void  __bang_write_value (void * dst , unsigned int  elem_count , half  value )   \n Sets a vector in the  \\_\\_nram\\_\\_  address space pointed by  <dst>  to the specified  <value> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements to be set.\n*  [in] value : The value to be set to  <dst> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n "
  },
  {
    "content": "\n 3.2.2. __bang_write_zero \n^^^^^^^^^^^^^^^\n void  __bang_write_zero (void * dst , unsigned int  elem_count )   \n Sets a vector in  \\_\\_nram\\_\\_  address space pointed by  <dst>  to zero. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements in destination vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <dst>  must point to \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;"
  },
  {
    "content": "\n 3.2.3. __gdramset \n^^^^^^^^^^^^^^^\n void  __gdramset (void * dst , unsigned int  elem_count , char  value )   \n void  __gdramset (void * dst , unsigned int  elem_count , short  value )   \n void  __gdramset (void * dst , unsigned int  elem_count , bfloat16_t  value )   \n void  __gdramset (void * dst , unsigned int  elem_count , half  value )   \n void  __gdramset (void * dst , unsigned int  elem_count , float  value )   \n void  __gdramset (void * dst , unsigned int  elem_count , int  value )   \n Sets a vector in  \\_\\_mlu\\_device\\_\\_  address space pointed by  <dst>  to the specified  <value> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements to be set.\n*  [in] value : Value to be set. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.2.4. __ldramset \n^^^^^^^^^^^^^^^\n void  __ldramset (void * dst , unsigned int  elem_count , char  value )   \n void  __ldramset (void * dst , unsigned int  elem_count , short  value )   \n void  __ldramset (void * dst , unsigned int  elem_count , bfloat16_t  value )   \n void  __ldramset (void * dst , unsigned int  elem_count , half  value )   \n void  __ldramset (void * dst , unsigned int  elem_count , float  value )   \n void  __ldramset (void * dst , unsigned int  elem_count , int  value )   \n Sets a vector in  \\_\\_ldram\\_\\_  address space pointed by  <dst>  to the specified  <value> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements to be set.\n*  [in] value : Value to be set. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  must point to  \\_\\_ldram\\_\\_  address space\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.2.5. __memset_nram \n^^^^^^^^^^^^^^^\n void  __memset_nram (void * dst , unsigned int  elem_count , char  value )   \n void  __memset_nram (void * dst , unsigned int  elem_count , short  value )   \n void  __memset_nram (void * dst , unsigned int  elem_count , half  value )   \n void  __memset_nram (void * dst , unsigned int  elem_count , bfloat16_t  value )   \n void  __memset_nram (void * dst , unsigned int  elem_count , float  value )   \n void  __memset_nram (void * dst , unsigned int  elem_count , int  value )   \n Sets a vector in  \\_\\_nram\\_\\_  address space pointed by  <dst>  to the specified  <value> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements to be set.\n*  [in] value : Value to be set. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero\n Instruction Pipeline * Move. "
  },
  {
    "content": "\n 3.2.6. __memset_nram_async \n^^^^^^^^^^^^^^^\n void  __memset_nram_async (void * dst , unsigned int  elem_count , char  value )   \n void  __memset_nram_async (void * dst , unsigned int  elem_count , short  value )   \n void  __memset_nram_async (void * dst , unsigned int  elem_count , half  value )   \n void  __memset_nram_async (void * dst , unsigned int  elem_count , bfloat16_t  value )   \n void  __memset_nram_async (void * dst , unsigned int  elem_count , float  value )   \n void  __memset_nram_async (void * dst , unsigned int  elem_count , int  value )   \n Sets a vector in  \\_\\_nram\\_\\_  address space pointed by  <dst>  to the specified  <value>  asynchronously. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements to be set.\n*  [in] value : Value to be set. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero\n Instruction Pipeline * Move. \n"
  },
  {
    "content": "\n 3.2.7. __sramset \n^^^^^^^^^^^^^^^\n void  __sramset (void * dst , unsigned int  elem_count , char  value )   \n void  __sramset (void * dst , unsigned int  elem_count , half  value )   \n void  __sramset (void * dst , unsigned int  elem_count , bfloat16_t  value )   \n void  __sramset (void * dst , unsigned int  elem_count , short  value )   \n void  __sramset (void * dst , unsigned int  elem_count , float  value )   \n void  __sramset (void * dst , unsigned int  elem_count , int  value )   \n Sets a vector in  \\_\\_mlu\\_shared\\_\\_  address space pointed by  <dst>  to the specified  <value> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements to be set.\n*  [in] value : Value to be set. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  must point to  \\_\\_mlu\\_shared\\_\\_  address space\n Instruction Pipeline * Move instruction pipeline of MPU core. "
  },
  {
    "content": "\n 3.2.8. __sramset_async \n^^^^^^^^^^^^^^^\n void  __sramset_async (void * dst , unsigned int  elem_count , char  value )   \n void  __sramset_async (void * dst , unsigned int  elem_count , half  value )   \n void  __sramset_async (void * dst , unsigned int  elem_count , bfloat16_t  value )   \n void  __sramset_async (void * dst , unsigned int  elem_count , short  value )   \n void  __sramset_async (void * dst , unsigned int  elem_count , float  value )   \n void  __sramset_async (void * dst , unsigned int  elem_count , int  value )   \n Sets a vector in  \\_\\_mlu\\_shared\\_\\_  address space pointed by  <dst>  to the specified  <value>  asynchronously. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements to be set.\n*  [in] value : Value to be set. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  must point to  \\_\\_mlu\\_shared\\_\\_  address space\n Instruction Pipeline * Move instruction pipeline of MPU core. \n"
  },
  {
    "content": "\n 3.3.1. __bang_move \n^^^^^^^^^^^^^^^\n void  __bang_move (void * dst ,  const  void * src , unsigned int  size , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n Copies  <size>  bytes data from  <src>  source address to  <dst>  destination address. \n As shown in Figure Memory Copy Function with Stride , the blue background indicates the data to be copied. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination area.\n*  [in] src : The address of source area.\n*  [in] size : The number of bytes of one data segment.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of data segment minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * When  <segnum>  is 0, it means that it is copied once. The real segment number is the given value plus one;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride>  must be greater than or equal to  <size>  ;\n*  <src\\_stride>  must be greater than or equal to zero;\n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 64 \n define DST_STRIDE 512 \n define SRC_STRIDE 128 \n define SEGNUM 7 \n __mlu_entry__ void kernel2D(int8_t *dst, int8_t *src) {\n  __nram__ int8_t src1_nram[512];\n  __nram__ int8_t src2_nram[512];\n  __memcpy(src1_nram, src, 512, GDRAM2NRAM);\n  __bang_move(src2_nram, src1_nram, LEN, DST_STRIDE, SRC_STRIDE, SEGNUM);\n  __memcpy(dst, src2_nram, 512, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.3.2. __memcpy \n^^^^^^^^^^^^^^^\n void  __memcpy (void * dst ,  const  void * src , unsigned int  size , mluMemcpyDirection_t  dir , unsigned int  dst_stride , int  src_stride , unsigned int  segnum )   \n void  __memcpy (void * dst ,  const  void * src , unsigned int  size , mluMemcpyDirection_t  dir , unsigned int  dst_stride , int  src_stride , unsigned int  segnum , unsigned int  id_dst_cluster )   \n Copies  <size>  bytes data from source address  <src>  to destination address  <dst> . The copy direction is specified by  <dir> . \n Fig. 3.1 Memory Copy Function with Stride \n As shown in Figure Memory Copy Function with Stride , each cell represents 64 bytes and the cells with blue background indicate the data to be copied which is 128 bytes in each segment. There are 3 segments in source area and in each segment only the first 128 bytes of every 256 bytes are copied to destination area. Please note that  <segnum>  is the real segment number minus one, that is,  <segnum> = 2  in this case. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination area.\n*  [in] src : The address of source area.\n*  [in] size : The number of bytes of one segment.\n*  [in] dir : Copy direction.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one.\n*  [in] id\\_dst\\_cluster : Destination cluster ID. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n* The range of  <segnum>  is [0, 65535];\n* When the segment number is 0, it means that it is copied once. The real segment number value is the given value plus one;\n*  <dst\\_stride>  must be greater than or equal to  <size> ;\n*  \\_\\_memcpy  with  <id\\_dst\\_cluster>  is not supported on  (m)tp\\_5xx  or higher;\n*  <id\\_dst\\_cluster>  is necessarily used when  <dir>  is SRAM2SRAM and data is copied across different clusters. When there is no  <id\\_dst\\_cluster> , it means copy within cluster;\n* If the size of the vector with the address space of WRAM is not 8-byte aligned on each LT, the value of the unaligned part is uncertain on  tp\\_322  and  (m)tp\\_372 , and is 0 on other targets;\nInstruction Pipeline * If either  <src>  or  <dst>  is  off-chip address , execute in IO instruction pipeline, otherwise, execute in Move instruction pipeline;\n* If  <dir>  is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM or LDRAM2SRAM, execute on MPU core, otherwise, execute on MLU core. \n"
  },
  {
    "content": "\n 3.4.1. __gdramset \n^^^^^^^^^^^^^^^\n void  __gdramset (void * dst , unsigned int  elem_count , char  value , unsigned int  stride , unsigned int  segnum )   \n void  __gdramset (void * dst , unsigned int  elem_count , half  value , unsigned int  stride , unsigned int  segnum )   \n void  __gdramset (void * dst , unsigned int  elem_count , bfloat16_t  value , unsigned int  stride , unsigned int  segnum )   \n void  __gdramset (void * dst , unsigned int  elem_count , short  value , unsigned int  stride , unsigned int  segnum )   \n void  __gdramset (void * dst , unsigned int  elem_count , float  value , unsigned int  stride , unsigned int  segnum )   \n void  __gdramset (void * dst , unsigned int  elem_count , int  value , unsigned int  stride , unsigned int  segnum )   \n Sets the specified  <value>  to a two-dimensional block in the  \\_\\_mlu\\_device\\_\\_  address space pointed by  <dst> . The way of setting  <value>  is that takes the  <elem\\_count>  of the data, operates the  <segnum> + 1  times through the  <stride> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements of one segment.\n*  [in] value : The value to be set to  <dst> .\n*  [in] stride : The destination address stride(bytes).\n*  [in] segnum : The destination segment number. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;\n*  <stride>  must be greater than or equal to  <elem\\_count> \\* sizeof(type) ;\n* When  <segnum>  is 0, it represents 1, and when  <segnum>  is 1, it represents 2, and so on\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.4.2. __ldramset \n^^^^^^^^^^^^^^^\n void  __ldramset (void * dst , unsigned int  elem_count , char  value , unsigned int  stride , unsigned int  segnum )   \n void  __ldramset (void * dst , unsigned int  elem_count , half  value , unsigned int  stride , unsigned int  segnum )   \n void  __ldramset (void * dst , unsigned int  elem_count , bfloat16_t  value , unsigned int  stride , unsigned int  segnum )   \n void  __ldramset (void * dst , unsigned int  elem_count , short  value , unsigned int  stride , unsigned int  segnum )   \n void  __ldramset (void * dst , unsigned int  elem_count , float  value , unsigned int  stride , unsigned int  segnum )   \n void  __ldramset (void * dst , unsigned int  elem_count , int  value , unsigned int  stride , unsigned int  segnum )   \n Sets the specified  <value>  to a two-dimensional block in the  \\_\\_ldram\\_\\_  address space pointed by  <dst> . The way of setting  <value>  is that takes the  <elem\\_count>  of the data, operates the  <segnum> + 1  times through the  <stride> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements of one segment.\n*  [in] value : The value to be set to  <dst> .\n*  [in] stride : The destination address stride(bytes).\n*  [in] segnum : The destination segment number. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_ldram\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;\n*  <stride>  must be greater than or equal to  <elem\\_count> \\* sizeof(type) ;\n* When  <segnum>  is 0, it represents 1, and when  <segnum>  is 1, it represents 2, and so on\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.4.3. __nramset \n^^^^^^^^^^^^^^^\n void  __nramset (void * dst , unsigned int  elem_count , char  value , unsigned int  stride , unsigned int  segnum )   \n void  __nramset (void * dst , unsigned int  elem_count , half  value , unsigned int  stride , unsigned int  segnum )   \n void  __nramset (void * dst , unsigned int  elem_count , bfloat16_t  value , unsigned int  stride , unsigned int  segnum )   \n void  __nramset (void * dst , unsigned int  elem_count , short  value , unsigned int  stride , unsigned int  segnum )   \n void  __nramset (void * dst , unsigned int  elem_count , float  value , unsigned int  stride , unsigned int  segnum )   \n void  __nramset (void * dst , unsigned int  elem_count , int  value , unsigned int  stride , unsigned int  segnum )   \n Sets the specified  <value>  to a two-dimensional block in the  \\_\\_nram\\_\\_  address space pointed by  <dst> . The way of setting  <value>  is that takes the  <elem\\_count>  of the data, operates the  <segnum> + 1  times through the  <stride> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements of one segment.\n*  [in] value : The value to be set to  <dst> .\n*  [in] stride : The destination address stride(bytes).\n*  [in] segnum : The destination segment number. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;\n*  <stride>  must be greater than or equal to  <elem\\_count> \\* sizeof(type) ;\n* When  <segnum>  is 0, it represents 1, and when  <segnum>  is 1, it represents 2, and so on\n Instruction Pipeline * Move. "
  },
  {
    "content": "\n 3.4.4. __nramset_async \n^^^^^^^^^^^^^^^\n void  __nramset_async (void * dst , unsigned int  elem_count , char  value , unsigned int  stride , unsigned int  segnum )   \n void  __nramset_async (void * dst , unsigned int  elem_count , half  value , unsigned int  stride , unsigned int  segnum )   \n void  __nramset_async (void * dst , unsigned int  elem_count , bfloat16_t  value , unsigned int  stride , unsigned int  segnum )   \n void  __nramset_async (void * dst , unsigned int  elem_count , short  value , unsigned int  stride , unsigned int  segnum )   \n void  __nramset_async (void * dst , unsigned int  elem_count , float  value , unsigned int  stride , unsigned int  segnum )   \n void  __nramset_async (void * dst , unsigned int  elem_count , int  value , unsigned int  stride , unsigned int  segnum )   \n Sets the specified  <value>  to a two-dimensional block in the  \\_\\_nram\\_\\_  address space pointed by  <dst>  asynchronously. The way of setting  <value>  is that takes the  <elem\\_count>  of the data, operates the  <segnum> + 1  times through the  <stride> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements of one segment.\n*  [in] value : The value to be set to  <dst> .\n*  [in] stride : The destination address stride(bytes).\n*  [in] segnum : The destination segment number. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;\n*  <stride>  must be greater than or equal to  <elem\\_count> \\* sizeof(type) ;\n* When  <segnum>  is 0, it represents 1, and when  <segnum>  is 1, it represents 2, and so on\n Instruction Pipeline * Move. "
  },
  {
    "content": "\n 3.4.5. __sramset \n^^^^^^^^^^^^^^^\n void  __sramset (void * dst , unsigned int  elem_count , char  value , unsigned int  stride , unsigned int  segnum )   \n void  __sramset (void * dst , unsigned int  elem_count , half  value , unsigned int  stride , unsigned int  segnum )   \n void  __sramset (void * dst , unsigned int  elem_count , bfloat16_t  value , unsigned int  stride , unsigned int  segnum )   \n void  __sramset (void * dst , unsigned int  elem_count , short  value , unsigned int  stride , unsigned int  segnum )   \n void  __sramset (void * dst , unsigned int  elem_count , float  value , unsigned int  stride , unsigned int  segnum )   \n void  __sramset (void * dst , unsigned int  elem_count , int  value , unsigned int  stride , unsigned int  segnum )   \n Sets the specified  <value>  to a two-dimensional block in the  \\_\\_mlu\\_shared\\_\\_  address space pointed by  <dst> . The way of setting  <value>  is that takes the  <elem\\_count>  of the data, operates the  <segnum> + 1  times through the  <stride> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements of one segment.\n*  [in] value : The value to be set to  <dst> .\n*  [in] stride : The destination address stride(bytes).\n*  [in] segnum : The destination segment number. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_mlu\\_shared\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;\n*  <stride>  must be greater than or equal to  <elem\\_count> \\* sizeof(type) ;\n* When  <segnum>  is 0, it represents 1, and when  <segnum>  is 1, it represents 2, and so on\n Instruction Pipeline * Move instruction pipeline of MPU core. "
  },
  {
    "content": "\n 3.4.6. __sramset_async \n^^^^^^^^^^^^^^^\n void  __sramset_async (void * dst , unsigned int  elem_count , char  value , unsigned int  stride , unsigned int  segnum )   \n void  __sramset_async (void * dst , unsigned int  elem_count , half  value , unsigned int  stride , unsigned int  segnum )   \n void  __sramset_async (void * dst , unsigned int  elem_count , bfloat16_t  value , unsigned int  stride , unsigned int  segnum )   \n void  __sramset_async (void * dst , unsigned int  elem_count , short  value , unsigned int  stride , unsigned int  segnum )   \n void  __sramset_async (void * dst , unsigned int  elem_count , float  value , unsigned int  stride , unsigned int  segnum )   \n void  __sramset_async (void * dst , unsigned int  elem_count , int  value , unsigned int  stride , unsigned int  segnum )   \n Sets the specified  <value>  to a two-dimensional block in the  \\_\\_mlu\\_shared\\_\\_  address space pointed by  <dst>  asynchronously. The way of setting  <value>  is that takes the  <elem\\_count>  of the data, operates the  <segnum> + 1  times through the  <stride> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements of one segment.\n*  [in] value : The value to be set to  <dst> .\n*  [in] stride : The destination address stride(bytes).\n*  [in] segnum : The destination segment number. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_mlu\\_shared\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;\n*  <stride>  must be greater than or equal to  <elem\\_count> \\* sizeof(type) ;\n* When  <segnum>  is 0, it represents 1, and when  <segnum>  is 1, it represents 2, and so on\n Instruction Pipeline * Move instruction pipeline of MPU core. \n"
  },
  {
    "content": "\n 3.5.1. __bang_atomic_add \n^^^^^^^^^^^^^^^\n void  __bang_atomic_add (void * dst , void * src0 , void * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Copies  <src0>  to  <dst> , adds  <src1>  to  <src0>  element-wisely. That is:  <dst>  =  <src0> ;  <src0>  =  <src0>  +  <src1> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \nExample \n``` \n include  \n __mlu_entry__ void kernel() {\n  __nram__ short v[128];\n  __mlu_device__ short src0[128];\n  __nram__ short src1[128];\n  __bang_atomic_add(v, src0, src1, 16, 0, 0, 16, 16, 16, 16, 16, 16);\n} \n ``` \n"
  },
  {
    "content": "\n 3.5.2. __bang_atomic_add_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_add_async (void * dst , void * src0 , void * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Asynchronously copies  <src0>  to  <dst> , adds  <src1>  to  <src0>  element-wisely. That is:  <dst>  =  <src0> ;  <src0>  =  <src0>  +  <src1> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ Example \n``` \n include  \n __mlu_entry__ void kernel() {\n  __nram__ short v[128];\n  __mlu_device__ short src0[128];\n  __nram__ short src1[128];\n  __bang_atomic_add_async(v, src0, src1, 16, 0, 0, 16, 16, 16, 16, 16, 16);\n} \n ``` \n"
  },
  {
    "content": "\n 3.5.3. __bang_atomic_and \n^^^^^^^^^^^^^^^\n void  __bang_atomic_and (short * dst , short * src0 , short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_and (int * dst , int * src0 , int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Applies bitwise AND operation to the vector  <src0>  and  <src1> , stores the result in  <src0> , and stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  =  <src0>  &  <src1> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.4. __bang_atomic_and_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_and_async (short * dst , short * src0 , short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_and_async (int * dst , int * src0 , int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Asynchronously applies bitwise AND operation to the vector  <src0>  and  <src1> , stores the result in  <src0> , and stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  =  <src0>  &  <src1> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.5. __bang_atomic_dec \n^^^^^^^^^^^^^^^\n void  __bang_atomic_dec (unsigned short * dst , unsigned short * src0 , unsigned short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_dec (unsigned int * dst , unsigned int * src0 , unsigned int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_dec (short * dst , short * src0 , short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_dec (int * dst , int * src0 , int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Compares vector  <src0>  and  <src1>  element-wisely. If  <src0>  is larger than  <src1> , or the value of  <src0>  is 0, stores the int value  <src1>  in  <src0> ; otherwise, subtracts  <src0>  by 1. Stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  = ( <src0>  == 0 ||  <src0>  >  <src1> ) ?  <src1>  : ( <src0>  - 1). All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.6. __bang_atomic_dec_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_dec_async (unsigned short * dst , unsigned short * src0 , unsigned short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_dec_async (unsigned int * dst , unsigned int * src0 , unsigned int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_dec_async (short * dst , short * src0 , short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_dec_async (int * dst , int * src0 , int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Asynchronously compares vector  <src0>  and  <src1>  element-wisely. If  <src0>  is larger than  <src1> , or the value of  <src0>  is 0, stores the int value  <src1>  in  <src0> ; otherwise, subtracts  <src0>  by 1. Stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  = ( <src0>  == 0 ||  <src0>  >  <src1> ) ?  <src1>  : ( <src0>  - 1). All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.7. __bang_atomic_exch \n^^^^^^^^^^^^^^^\n void  __bang_atomic_exch (short * dst , short * src0 , short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_exch (int * dst , int * src0 , int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_exch (half * dst , half * src0 , half * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_exch (bfloat16_t * dst , bfloat16_t * src0 , bfloat16_t * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_exch (float * dst , float * src0 , float * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Stores vector  <src0>  in  <dst> . Stores  <src1>  in  <src0> . That is:  <dst>  =  <src0> ;  <src0>  =  <src1> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.8. __bang_atomic_exch_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_exch_async (short * dst , short * src0 , short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_exch_async (int * dst , int * src0 , int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_exch_async (half * dst , half * src0 , half * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_exch_async (bfloat16_t * dst , bfloat16_t * src0 , bfloat16_t * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_exch_async (float * dst , float * src0 , float * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Stores vector  <src0>  in  <dst>  asynchronously. Stores  <src1>  in  <src0>  asynchronously. That is:  <dst>  =  <src0> ;  <src0>  =  <src1> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.9. __bang_atomic_inc \n^^^^^^^^^^^^^^^\n void  __bang_atomic_inc (unsigned short * dst , unsigned short * src0 , unsigned short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_inc (unsigned int * dst , unsigned int * src0 , unsigned int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_inc (short * dst , short * src0 , short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_inc (int * dst , int * src0 , int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Compares vector  <src0>  and  <src1>  element-wisely. If  <src0>  is smaller than  <src1> , increases  <src0>  by 1; otherwise, sets  <src0>  to 0. Stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  = ( <src0>  >=  <src1> ) ? 0 : ( <src0>  + 1). All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.10. __bang_atomic_inc_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_inc_async (unsigned short * dst , unsigned short * src0 , unsigned short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_inc_async (unsigned int * dst , unsigned int * src0 , unsigned int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_inc_async (short * dst , short * src0 , short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_inc_async (int * dst , int * src0 , int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Asynchronously compares vector  <src0>  and  <src1>  element-wisely. If  <src0>  is smaller than  <src1> , increases  <src0>  by 1; otherwise, sets  <src0>  to 0. Stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  = ( <src0>  >=  <src1> ) ? 0 : ( <src0>  + 1). All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.11. __bang_atomic_max \n^^^^^^^^^^^^^^^\n void  __bang_atomic_max (unsigned short * dst , unsigned short * src0 , unsigned short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_max (unsigned int * dst , unsigned int * src0 , unsigned int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_max (short * dst , short * src0 , short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_max (int * dst , int * src0 , int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_max (half * dst , half * src0 , half * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_max (bfloat16_t * dst , bfloat16_t * src0 , bfloat16_t * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_max (float * dst , float * src0 , float * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n element-wisely stores the larger value of vector  <src0>  and  <src1>  in  <src0> . Stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  = ( <src0>  >  <src1> ) ?  <src0>  :  <src1> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.12. __bang_atomic_max_async \n^^^^^^^^^^^^^^^\n void __bang_atomic_max_async (void * dst , void * src0 , void * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Asynchronously and element-wisely stores the larger value of vector  <src0>  and  <src1>  in  <src0> . Stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  = ( <src0>  >  <src1> ) ?  <src0>  :  <src1> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.13. __bang_atomic_min \n^^^^^^^^^^^^^^^\n void  __bang_atomic_min (void * dst , void * src0 , void * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n element-wisely stores the smaller value of vector  <src0>  and  <src1>  in  <src0> . Stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  = ( <src0>  <  <src1> ) ?  <src0>  :  <src1> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.14. __bang_atomic_min_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_min_async (void * dst , void * src0 , void * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Asynchronously and element-wisely stores the smaller value of vector  <src0>  and  <src1>  in  <src0> . Stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  = ( <src0>  <  <src1> ) ?  <src0>  :  <src1> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.15. __bang_atomic_nan_max \n^^^^^^^^^^^^^^^\n void  __bang_atomic_nan_max (void * dst , void * src0 , void * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n element-wisely stores the larger value of vector  <src0>  and  <src1>  in  <src0> . Stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  = ( <src0>  >  <src1> ) ?  <src0>  :  <src1> . If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.16. __bang_atomic_nan_max_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_nan_max_async (void * dst , void * src0 , void * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Asynchronously and element-wisely stores the larger value of vector  <src0>  and  <src1>  in  <src0> . Stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  = ( <src0>  >  <src1> ) ?  <src0>  :  <src1> . If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.17. __bang_atomic_nan_min \n^^^^^^^^^^^^^^^\n void  __bang_atomic_nan_min (half * dst , half * src0 , half * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_nan_min (bfloat16_t * dst , bfloat16_t * src0 , bfloat16_t * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_nan_min (float * dst , float * src0 , float * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n element-wisely stores the smaller value of vector  <src0>  and  <src1>  in  <src0> . Stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  = ( <src0>  <  <src1> ) ?  <src0>  :  <src1> . If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.18. __bang_atomic_nan_min_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_nan_min_async (half * dst , half * src0 , half * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_nan_min_async (bfloat16_t * dst , bfloat16_t * src0 , bfloat16_t * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_nan_min_async (float * dst , float * src0 , float * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Asynchronously and element-wisely stores the smaller value of vector  <src0>  and  <src1>  in  <src0> . Stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  = ( <src0>  <  <src1> ) ?  <src0>  :  <src1> . If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.19. __bang_atomic_number_max \n^^^^^^^^^^^^^^^\n void  __bang_atomic_number_max (half * dst , half * src0 , half * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_number_max (bfloat16_t * dst , bfloat16_t * src0 , bfloat16_t * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_number_max (float * dst , float * src0 , float * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n element-wisely stores the larger value of vector  <src0>  and  <src1>  in  <src0> . Stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  = ( <src0>  >  <src1> ) ?  <src0>  :  <src1> . If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.20. __bang_atomic_number_max_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_number_max_async (half * dst , half * src0 , half * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_number_max_async (bfloat16_t * dst , bfloat16_t * src0 , bfloat16_t * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_number_max_async (float * dst , float * src0 , float * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Asynchronously and element-wisely stores the larger value of vector  <src0>  and  <src1>  in  <src0> . Stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  = ( <src0>  >  <src1> ) ?  <src0>  :  <src1> . If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.21. __bang_atomic_number_min \n^^^^^^^^^^^^^^^\n void  __bang_atomic_number_min (half * dst , half * src0 , half * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_number_min (bfloat16_t * dst , bfloat16_t * src0 , bfloat16_t * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_number_min (float * dst , float * src0 , float * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n element-wisely stores the smaller value of vector  <src0>  and  <src1>  in  <src0> . Stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  = ( <src0>  <  <src1> ) ?  <src0>  :  <src1> . If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.22. __bang_atomic_number_min_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_number_min_async (half * dst , half * src0 , half * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_number_min_async (bfloat16_t * dst , bfloat16_t * src0 , bfloat16_t * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_number_min_async (float * dst , float * src0 , float * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Asynchronously and element-wisely stores the smaller value of vector  <src0>  and  <src1>  in  <src0> . Stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  = ( <src0>  <  <src1> ) ?  <src0>  :  <src1> . If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.23. __bang_atomic_or \n^^^^^^^^^^^^^^^\n void  __bang_atomic_or (short * dst , short * src0 , short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_or (int * dst , int * src0 , int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Applies bitwise OR operation to the vector  <src0>  and  <src1> , stores the result in  <src0> , and stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  =  <src0>  |  <src1> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.24. __bang_atomic_or_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_or_async (short * dst , short * src0 , short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_or_async (int * dst , int * src0 , int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Asynchronously applies bitwise OR operation to the vector  <src0>  and  <src1> , stores the result in  <src0> , and stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  =  <src0>  |  <src1> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.25. __bang_atomic_xor \n^^^^^^^^^^^^^^^\n void  __bang_atomic_xor (short * dst , short * src0 , short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_xor (int * dst , int * src0 , int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Applies bitwise XOR operation to the vector  <src0>  and  <src1> , stores the result in  <src0> , and stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  =  <src0>  ^  <src1> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.5.26. __bang_atomic_xor_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_xor_async (short * dst , short * src0 , short * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n void  __bang_atomic_xor_async (int * dst , int * src0 , int * src1 , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src0_stride0 , unsigned int  src0_stride1 , unsigned int  src1_stride0 , unsigned int  src1_stride1 )   \n Asynchronously applies bitwise XOR operation to the vector  <src0>  and  <src1> , stores the result in  <src0> , and stores the original value of  <src0>  in  <dst> . That is:  <dst>  =  <src0> ;  <src0>  =  <src0>  ^  <src1> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] size : The first dimension iteration count.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src0\\_stride0 : The first dimension stride(bytes) of  <src0> .\n*  [in] src0\\_stride1 : The second dimension stride(bytes) of  <src0> .\n*  [in] src1\\_stride0 : The first dimension stride(bytes) of  <src1> .\n*  [in] src1\\_stride1 : The second dimension stride(bytes) of  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src1> ;\n* The address of  <src0>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src0>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src0\\_stride0>  and  <dst\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <src0\\_stride1>  must be greater than or equal to  <src0\\_stride0> \\* (<segnum1> + 1) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0> \\* (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.1. __bang_atomic_nan_reduce_max \n^^^^^^^^^^^^^^^\n void  __bang_atomic_nan_reduce_max (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_nan_reduce_max (half * dst ,  const  half * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_nan_reduce_max (float * dst ,  const  float * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n element-wisely stores the larger value of vector  <dst>  and  <src>  in  <dst> . That is:  <dst>  = ( <dst>  >  <src> ) ?  <dst>  :  <src> . If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of second source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.2. __bang_atomic_nan_reduce_max_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_nan_reduce_max_async (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_nan_reduce_max_async (half * dst ,  const  half * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_nan_reduce_max_async (float * dst ,  const  float * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Asynchronously element-wisely stores the larger value of vector  <dst>  and  <src>  in  <dst> . That is:  <dst>  = ( <dst>  >  <src> ) ?  <dst>  :  <src> . If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of second source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.3. __bang_atomic_nan_reduce_min \n^^^^^^^^^^^^^^^\n void  __bang_atomic_nan_reduce_min (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_nan_reduce_min (half * dst ,  const  half * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_nan_reduce_min (float * dst ,  const  float * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n element-wisely stores the smaller value of vector  <dst>  and  <src>  in  <dst> . That is:  <dst>  = ( <dst>  <  <src> ) ?  <dst>  :  <src> . If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of second source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.4. __bang_atomic_nan_reduce_min_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_nan_reduce_min_async (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_nan_reduce_min_async (half * dst ,  const  half * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_nan_reduce_min_async (float * dst ,  const  float * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Asynchronously element-wisely stores the smaller value of vector  <dst>  and  <src>  in  <dst> . That is:  <dst>  = ( <dst>  <  <src> ) ?  <dst>  :  <src> . If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of second source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.5. __bang_atomic_number_reduce_max \n^^^^^^^^^^^^^^^\n void  __bang_atomic_number_reduce_max (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_number_reduce_max (half * dst ,  const  half * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_number_reduce_max (float * dst ,  const  float * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n element-wisely stores the larger value of vector  <dst>  and  <src>  in  <dst> . That is:  <dst>  = ( <dst>  >  <src> ) ?  <dst>  :  <src> . If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of second source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.6. __bang_atomic_number_reduce_max_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_number_reduce_max_async (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_number_reduce_max_async (half * dst ,  const  half * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_number_reduce_max_async (float * dst ,  const  float * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Asynchronously element-wisely stores the larger value of vector  <dst>  and  <src>  in  <dst> . That is:  <dst>  = ( <dst>  >  <src> ) ?  <dst>  :  <src> . If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of second source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.7. __bang_atomic_number_reduce_min \n^^^^^^^^^^^^^^^\n void  __bang_atomic_number_reduce_min (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_number_reduce_min (half * dst ,  const  half * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_number_reduce_min (float * dst ,  const  float * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n element-wisely stores the smaller value of vector  <dst>  and  <src>  in  <dst> . That is:  <dst>  = ( <dst>  <  <src> ) ?  <dst>  :  <src> . If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of second source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.8. __bang_atomic_number_reduce_min_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_number_reduce_min_async (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_number_reduce_min_async (half * dst ,  const  half * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_number_reduce_min_async (float * dst ,  const  float * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Asynchronously element-wisely stores the smaller value of vector  <dst>  and  <src>  in  <dst> . That is:  <dst>  = ( <dst>  <  <src> ) ?  <dst>  :  <src> . If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of second source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.9. __bang_atomic_reduce_add \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_add (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_add (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_add (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_add (half * dst ,  const  half * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_add (float * dst ,  const  float * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Adds  <src>  to  <dst>  element-wisely. That is:  <dst>  =  <dst>  +  <src> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ Example \n``` \n include  \n __mlu_entry__ void kernel() {\n  __mlu_device__ short dst[128];\n  __nram__ short src[128];\n  __bang_atomic_reduce_add(dst, src, 16, 0, 0, 16, 16, 16, 16);\n} \n ``` \n"
  },
  {
    "content": "\n 3.6.10. __bang_atomic_reduce_add_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_add_async (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_add_async (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_add_async (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_add_async (half * dst ,  const  half * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_add_async (float * dst ,  const  float * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Asynchronously adds  <src>  to  <dst>  element-wisely. That is:  <dst>  =  <dst>  +  <src> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ Example \n``` \n include  \n __mlu_entry__ void kernel() {\n  __mlu_device__ short dst[128];\n  __nram__ short src[128];\n  __bang_atomic_reduce_add_async(dst, src, 16, 0, 0, 16, 16, 16, 16);\n} \n ``` \n"
  },
  {
    "content": "\n 3.6.11. __bang_atomic_reduce_and \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_and (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_and (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Applies bitwise AND operation to the vector  <dst>  and  <src> , stores the result in  <dst> . That is:  <dst>  =  <dst>  &  <src> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.12. __bang_atomic_reduce_and_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_and_async (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_and_async (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Asynchronously applies bitwise AND operation to the vector  <dst>  and  <src> , stores the result in  <dst> . That is:  <dst>  =  <dst>  &  <src> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.13. __bang_atomic_reduce_dec \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_dec (unsigned short * dst ,  const  unsigned short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_dec (unsigned int * dst ,  const  unsigned int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_dec (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_dec (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Compares vector  <dst>  and  <src>  element-wisely. If  <dst>  is larger than  <src> , or the value of  <dst>  is 0, stores the int value  <src>  in  <dst> ; otherwise, subtracts  <dst>  by 1. That is:  <dst>  = ( <dst>  == 0 ||  <dst>  >  <src> ) ?  <src>  : ( <dst>  - 1). All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.14. __bang_atomic_reduce_dec_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_dec_async (unsigned short * dst ,  const  unsigned short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_dec_async (unsigned int * dst ,  const  unsigned int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_dec_async (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_dec_async (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Asynchronously compares vector  <dst>  and  <src>  element-wisely. If  <dst>  is larger than  <src> , or the value of  <dst>  is 0, stores the int value  <src>  in  <dst> ; otherwise, subtracts  <dst>  by 1. That is:  <dst>  = ( <dst>  == 0 ||  <dst>  >  <src> ) ?  <src>  : ( <dst>  - 1). All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.15. __bang_atomic_reduce_exch \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_exch (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_exch (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_exch (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_exch (half * dst ,  const  half * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_exch (float * dst ,  const  float * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Stores  <src>  in  <dst> . That is:  <dst>  =  <src> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.16. __bang_atomic_reduce_exch_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_exch_async (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_exch_async (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_exch_async (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_exch_async (half * dst ,  const  half * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_exch_async (float * dst ,  const  float * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Asynchronously stores  <src>  in  <dst> . That is:  <dst>  =  <src> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.17. __bang_atomic_reduce_inc \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_inc (unsigned short * dst ,  const  unsigned short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_inc (unsigned int * dst ,  const  unsigned int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_inc (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_inc (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Compares vector  <dst>  and  <src>  element-wisely. If  <dst>  is smaller than  <src> , increases  <dst>  by 1; otherwise, sets  <dst>  to 0. That is:  <dst>  = ( <dst>  >=  <src> ) ? 0 : ( <dst>  + 1). All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.18. __bang_atomic_reduce_inc_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_inc_async (unsigned short * dst ,  const  unsigned short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_inc_async (unsigned int * dst ,  const  unsigned int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_inc_async (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_inc_async (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Asynchronously compares vector  <dst>  and  <src>  element-wisely. If  <dst>  is smaller than  <src> , increases  <dst>  by 1; otherwise, sets  <dst>  to 0. That is:  <dst>  = ( <dst>  >=  <src> ) ? 0 : ( <dst>  + 1). All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.19. __bang_atomic_reduce_max \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_max (unsigned short * dst ,  const  unsigned short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_max (unsigned int * dst ,  const  unsigned int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_max (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_max (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_max (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_max (half * dst ,  const  half * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_max (float * dst ,  const  float * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n element-wisely stores the larger value of vector  <dst>  and  <src>  in  <dst> . That is:  <dst>  = ( <dst>  >  <src> ) ?  <dst>  :  <src> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of second source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.20. __bang_atomic_reduce_max_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_max_async (unsigned short * dst ,  const  unsigned short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_max_async (unsigned int * dst ,  const  unsigned int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_max_async (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_max_async (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_max_async (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_max_async (half * dst ,  const  half * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_max_async (float * dst ,  const  float * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Asynchronously element-wisely stores the larger value of vector  <dst>  and  <src>  in  <dst> . That is:  <dst>  = ( <dst>  >  <src> ) ?  <dst>  :  <src> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of second source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.21. __bang_atomic_reduce_min \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_min (unsigned short * dst ,  const  unsigned short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_min (unsigned int * dst ,  const  unsigned int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_min (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_min (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_min (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_min (half * dst ,  const  half * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_min (float * dst ,  const  float * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n element-wisely stores the smaller value of vector  <dst>  and  <src>  in  <dst> . That is:  <dst>  = ( <dst>  <  <src> ) ?  <dst>  :  <src> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of second source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.22. __bang_atomic_reduce_min_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_min_async (unsigned short * dst ,  const  unsigned short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_min_async (unsigned int * dst ,  const  unsigned int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_min_async (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_min_async (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_min_async (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_min_async (half * dst ,  const  half * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_min_async (float * dst ,  const  float * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Asynchronously element-wisely stores the smaller value of vector  <dst>  and  <src>  in  <dst> . That is:  <dst>  = ( <dst>  <  <src> ) ?  <dst>  :  <src> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of second source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.23. __bang_atomic_reduce_or \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_or (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_or (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Applies bitwise OR operation to the vector  <dst>  and  <src> , stores the result in  <dst> . That is:  <dst>  =  <dst>  |  <src> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.24. __bang_atomic_reduce_or_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_or_async (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_or_async (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Asynchronously applies bitwise OR operation to the vector  <dst>  and  <src> , stores the result in  <dst> . That is:  <dst>  =  <dst>  |  <src> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.25. __bang_atomic_reduce_xor \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_xor (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_xor (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Applies bitwise XOR operation to the vector  <dst>  and  <src> , stores the result in  <dst> . That is:  <dst>  =  <dst>  ^  <src> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.6.26. __bang_atomic_reduce_xor_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_xor_async (short * dst ,  const  short * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n void  __bang_atomic_reduce_xor_async (int * dst ,  const  int * src , unsigned int  size , unsigned int  segnum1 , unsigned int  segnum2 , unsigned int  dst_stride0 , unsigned int  dst_stride1 , unsigned int  src_stride0 , unsigned int  src_stride1 )   \n Asynchronously applies bitwise XOR operation to the vector  <dst>  and  <src> , stores the result in  <dst> . That is:  <dst>  =  <dst>  ^  <src> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The number of elements in the first dimension of the source vector.\n*  [in] segnum1 : The second dimension iteration count minus 1.\n*  [in] segnum2 : The third dimension iteration count minus 1.\n*  [in] dst\\_stride0 : The first dimension stride(bytes) of  <dst> .\n*  [in] dst\\_stride1 : The second dimension stride(bytes) of  <dst> .\n*  [in] src\\_stride0 : The first dimension stride(bytes) of  <src> .\n*  [in] src\\_stride1 : The second dimension stride(bytes) of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * The address of  <dst>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <src\\_stride0>  must be greater than or equal to  <size> \\* sizeof(type) ;\n*  <dst\\_stride1>  must be greater than or equal to  <dst\\_stride0>  *  (<segnum1> + 1) ;\n*  <src\\_stride1>  must be greater than or equal to  <src\\_stride0>  *  (<segnum1> + 1) . \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^ "
  },
  {
    "content": "\n 3.7.1. __bang_move \n^^^^^^^^^^^^^^^\n void  __bang_move (void * dst ,  const  void * src , unsigned int  size , unsigned int  dst_stride0 , unsigned int  dst_segnum1 , unsigned int  dst_stride1 , unsigned int  dst_segnum2 , unsigned int  src_stride0 , unsigned int  src_segnum1 , unsigned int  src_stride1 , unsigned int  src_segnum2 )   \n Copies data from  <src>  to  <dst>  in 3 dimensions. \n As shown in Figure 3D Memory Copy Function with Stride , the cells with blue background indicate  <size>  of data to be copied in each segment. In this case, there are 3 segments in the first dimension. In each segment,  <src\\_stride0>  of data are copied to destination area  <src\\_segnum1>  times. There are 2 segments in the second dimension. In each segment,  <src\\_stride1>  of data are copied to destination area  <src\\_segnum2>  times. Then, copy the data into corresponding segments and dimensions of  <dst> . Please note that  <src\\_segnum1> ,  <dst\\_segnum1> ,  <src\\_segnum2>  and  <dst\\_segnum2>  are the real segment number minus one. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination area.\n*  [in] src : The address of source area.\n*  [in] size : The number of bytes of one segment.\n*  [in] dst\\_stride0 : The destination address stride(bytes) in the first dimension.\n*  [in] dst\\_segnum1 : The destination segment number in the first dimension.\n*  [in] dst\\_stride1 : The destination address stride(bytes) in the second dimension.\n*  [in] dst\\_segnum2 : The destination segment number in the second dimension.\n*  [in] src\\_stride0 : The source address stride(bytes) in the first dimension.\n*  [in] src\\_segnum1 : The source segment number in the first dimension.\n*  [in] src\\_stride1 : The source address stride(bytes) in the second dimension.\n*  [in] src\\_segnum2 : The source segment number in the second dimension. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst\\_stride0>  and  <dst\\_stride1>  must be greater than or equal to  <size> ;\n*  <src\\_stride0>  and  <src\\_stride1>  must be greater than or equal to 0;\n* The total number of iterations at the source must be equal to the total number of iterations at the destination, i.e., ( <dst\\_segnum1>  + 1) * ( <dst\\_segnum2>  + 1) = ( <src\\_segnum1>  + 1) * ( <src\\_segnum2>  + 1);\n* When the segment number of destination and source is 0, it means that it is copied once in this dimension. The real segment number value is the given value plus one;\n*  <dst>  can be overlapped with  <src> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 7 \n define IN_STRIDE_0 11 \n define IN_STRIDE_1 103 \n define IN_SEGNUM_1 7 \n define IN_SEGNUM_2 2 \n define OUT_STRIDE_0 9 \n define OUT_STRIDE_1 67 \n define OUT_SEGNUM_1 5 \n define OUT_SEGNUM_2 3 \n define SIZE (LEN * (IN_SEGNUM_1 + 1) * (IN_SEGNUM_2 + 1)) \n define SIZE_IN (IN_STRIDE_1 * (IN_SEGNUM_2 + 1)) \n define SIZE_OUT (OUT_STRIDE_1 * (OUT_SEGNUM_2 + 1)) \n __mlu_entry__ void kernel(int8_t *dst, int8_t *src) {\n  __nram__ int8_t src1_nram[512];\n  __nram__ int8_t src2_nram[512];\n  __memcpy(src1_nram, src, 512, GDRAM2NRAM);\n  __bang_move(src2_nram, src1_nram, LEN, OUT_STRIDE_0, OUT_SEGNUM_1,\n              OUT_STRIDE_1, OUT_SEGNUM_2, IN_STRIDE_0, IN_SEGNUM_1,\n              IN_STRIDE_1, IN_SEGNUM_2);\n  __memcpy(dst, src2_nram, 512, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.7.2. __memcpy \n^^^^^^^^^^^^^^^\n void  __memcpy (void * dst ,  const  void * src , unsigned int  size , mluMemcpyDirection_t  dir , int  dst_stride0 , unsigned int  dst_segnum1 , int  dst_stride1 , unsigned int  dst_segnum2 , int  src_stride0 , unsigned int  src_segnum1 , int  src_stride1 , unsigned int  src_segnum2 , unsigned int  id_dst_cluster )   \n void  __memcpy (void * dst ,  const  void * src , unsigned int  size , mluMemcpyDirection_t  dir , int  dst_stride0 , unsigned int  dst_segnum1 , int  dst_stride1 , unsigned int  dst_segnum2 , int  src_stride0 , unsigned int  src_segnum1 , int  src_stride1 , unsigned int  src_segnum2 )   \n Copies data from the  <src>  address space to the  <dst>  address space in three dimensions. \n As shown in Figure 3D Memory Copy Function with Stride , the cells with blue background indicate  <size>  of data to be copied in each segment. In this case, there are 3 segments in the first dimension.  <src\\_stride0>  of data in each segment are copied to destination area  <src\\_segnum1> +1  times. There are 2 segments in the second dimension.  <src\\_stride1>  of data in each segment are copied to destination area  <src\\_segnum2> +1  times. Then, copy the data into corresponding segments and dimensions of  <dst> . \n Fig. 3.3 3D Memory Copy Function with Stride \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination area.\n*  [in] src : The address of source area.\n*  [in] size : The number of bytes of one segment.\n*  [in] dir : Copy direction.\n*  [in] dst\\_stride0 : The destination stride(bytes) in the first dimension.\n*  [in] dst\\_segnum1 : The destination segment number minus one in the first dimension.\n*  [in] dst\\_stride1 : The destination stride(bytes) in the second dimension.\n*  [in] dst\\_segnum2 : The destination segment number minus one in the second dimension.\n*  [in] src\\_stride0 : The source stride(bytes) in the first dimension.\n*  [in] src\\_segnum1 : The source segment number minus one in the first dimension.\n*  [in] src\\_stride1 : The source stride(bytes) in the second dimension.\n*  [in] src\\_segnum2 : The source segment number minus one in the second dimension.\n*  [in] id\\_dst\\_cluster : Destination cluster ID. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * When the segment number of destination and source is 0, it means that it is copied once in this dimension. The real segment number value is the given value plus one;\n* The total number of iterations at the source must be equal to the total number of iterations at the destination. That is, the segment numbers need to satisfy: ( <dst\\_segnum1>  + 1) * ( <dst\\_segnum2>  + 1) = ( <src\\_segnum1>  + 1) * ( <src\\_segnum2>  + 1);\n* The  <size>  must be greater than zero, and the absolute value of  <dst\\_stride0>  must be greater than or equal to  <size>  unless the value of  <dst\\_stride0>  and  <dst\\_segnum1>  are equal to zero. The absolute value of  <dst\\_stride1>  must be greater than or equal to  <size>  unless the value of  <dst\\_stride1>  and  <dst\\_segnum2>  are equal to zero;\n* When  <dir>  is SRAM2SRAM, copy data across different clusters is not supported on  (m)tp\\_5xx  or higher;\n* When  <dir>  is SRAM2SRAM, and there is no  <id\\_dst\\_cluster> , it means copy data within cluster;\n* This function supports transferring data within NRAM, WRAM, SRAM, LDRAM and GDRAM except for WRAM2WRAM;\n* When  <dst>  address space is WRAM,  <dst\\_stride0>  and  <dst\\_stride1>  must be divisible by 8;\n* If the size of the vector with the address space of WRAM is not 8-byte aligned on each LT, the value of the unaligned part is uncertain on  tp\\_322  and  (m)tp\\_372 , and is 0 on other targets;\n* When  <dir>  is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM, LDRAM2SRAM, SRAM2NRAM, NRAM2SRAM, SRAM2WRAM or WRAM2SRAM, it is not supported on  tp\\_322  and  tp\\_520 . \n Instruction Pipeline * If either  <src>  or  <dst>  is  off-chip address , execute in IO instruction pipeline, otherwise, execute in Move instruction pipeline;\n* If  <dir>  is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM or LDRAM2SRAM, execute on MPU core, otherwise, execute on MLU core. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 7 \n define IN_STRIDE_0 11 \n define IN_STRIDE_1 103 \n define IN_SEGNUM_1 7 \n define IN_SEGNUM_2 2 \n define OUT_STRIDE_0 9 \n define OUT_STRIDE_1 67 \n define OUT_SEGNUM_1 5 \n define OUT_SEGNUM_2 3 \n define SIZE (LEN * (IN_SEGNUM_1 + 1) * (IN_SEGNUM_2 + 1)) \n define SIZE_IN (IN_STRIDE_1 * (IN_SEGNUM_2 + 1)) \n define SIZE_OUT (OUT_STRIDE_1 * (OUT_SEGNUM_2 + 1)) \n __mlu_entry__ void kernel(unsigned char *dst, unsigned char *src) {\n  __memcpy(dst, src, LEN, GDRAM2GDRAM, OUT_STRIDE_0, OUT_SEGNUM_1,\n           OUT_STRIDE_1, OUT_SEGNUM_2, IN_STRIDE_0, IN_SEGNUM_1,\n           IN_STRIDE_1, IN_SEGNUM_2);\n} \n ``` \n"
  },
  {
    "content": "\n 3.7.3. __memcpy_async \n^^^^^^^^^^^^^^^\n void  __memcpy_async (void * dst ,  const  void * src , unsigned int  size , mluMemcpyDirection_t  dir , int  dst_stride0 , unsigned int  dst_segnum1 , int  dst_stride1 , unsigned int  dst_segnum2 , int  src_stride0 , unsigned int  src_segnum1 , int  src_stride1 , unsigned int  src_segnum2 , unsigned int  id_dst_cluster )   \n void  __memcpy_async (void * dst ,  const  void * src , unsigned int  size , mluMemcpyDirection_t  dir , int  dst_stride0 , unsigned int  dst_segnum1 , int  dst_stride1 , unsigned int  dst_segnum2 , int  src_stride0 , unsigned int  src_segnum1 , int  src_stride1 , unsigned int  src_segnum2 )   \n Copies data from the  <src>  address space to the  <dst>  address space in three dimensions asynchronously. Data operation in the source space is: take the  <size>  of the data, operate the  <src\\_segnum1>  times through the  <src\\_stride0> , and then take the  <src\\_stride1>  size to iterate the number of  <src\\_segnum2> . Data operation in the destination space is: take the  <size>  of the data, operate the  <dst\\_segnum1>  times through the  <dst\\_stride0> , and then take the  <dst\\_stride1>  size to iterate the number of  <dst\\_segnum2> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination area.\n*  [in] src : The address of source area.\n*  [in] size : The number of bytes of one segment.\n*  [in] dir : Copy direction.\n*  [in] dst\\_stride0 : The destination stride(bytes) in the first dimension.\n*  [in] dst\\_segnum1 : The destination segment number minus one in the first dimension.\n*  [in] dst\\_stride1 : The destination stride(bytes) in the second dimension.\n*  [in] dst\\_segnum2 : The destination segment number minus one in the second dimension.\n*  [in] src\\_stride0 : The source stride(bytes) in the first dimension.\n*  [in] src\\_segnum1 : The source segment number minus one in the first dimension.\n*  [in] src\\_stride1 : The source stride(bytes) in the second dimension.\n*  [in] src\\_segnum2 : The source segment number minus one in the second dimension.\n*  [in] id\\_dst\\_cluster : Destination cluster ID. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * When the segment number of destination and source is 0, it means that it is copied once in this dimension. The real segment number value is the given value plus one;\n* The total number of iterations at the source must be equal to the total number of iterations at the destination. That is, the segment numbers need to satisfy: ( <dst\\_segnum1>  + 1) * ( <dst\\_segnum2>  + 1) = ( <src\\_segnum1>  + 1) * ( <src\\_segnum2>  + 1);\n* The  <size>  must be greater than zero, and the absolute value of  <dst\\_stride0>  must be greater than or equal to  <size>  unless the value of  <dst\\_stride0>  and  <dst\\_segnum1>  are equal to zero. The absolute value of  <dst\\_stride1>  must be greater than or equal to  <size>  unless the value of  <dst\\_stride1>  and  <dst\\_segnum2>  are equal to zero;\n* When  <dir>  is SRAM2SRAM, copy data across different clusters is not supported on  (m)tp\\_5xx  or higher;\n* When  <dir>  is SRAM2SRAM, and there is no  <id\\_dst\\_cluster> , it means copy data within cluster;\n* This function supports transferring data within NRAM, WRAM, SRAM, LDRAM and GDRAM except for WRAM2WRAM;\n* When  <dst>  address space is WRAM,  <dst\\_stride0>  and  <dst\\_stride1>  must be divisible by 8;\n* If the size of the vector with the address space of WRAM is not 8-byte aligned on each LT, the value of the unaligned part is uncertain on  tp\\_322  and  (m)tp\\_372 , and is 0 on other targets.\n*  \\_\\_memcpy\\_async  with  <id\\_dst\\_cluster>  is not supported on  (m)tp\\_5xx  or higher;\n* When  <dir>  is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM, LDRAM2SRAM, SRAM2NRAM, NRAM2SRAM, SRAM2WRAM or WRAM2SRAM, it is not supported on  tp\\_322  and  tp\\_520 . \n Instruction Pipeline * If either  <src>  or  <dst>  is  off-chip address , execute in IO instruction pipeline, otherwise, execute in Move instruction pipeline;\n* If  <dir>  is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM or LDRAM2SRAM, execute on MPU core, otherwise, execute on MLU core. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 7 \n define IN_STRIDE_0 11 \n define IN_STRIDE_1 103 \n define IN_SEGNUM_1 7 \n define IN_SEGNUM_2 2 \n define OUT_STRIDE_0 9 \n define OUT_STRIDE_1 67 \n define OUT_SEGNUM_1 5 \n define OUT_SEGNUM_2 3 \n define SIZE (LEN * (IN_SEGNUM_1 + 1) * (IN_SEGNUM_2 + 1)) \n define SIZE_IN (IN_STRIDE_1 * (IN_SEGNUM_2 + 1)) \n define SIZE_OUT (OUT_STRIDE_1 * (OUT_SEGNUM_2 + 1)) \n __mlu_entry__ void kernel(unsigned char *dst, unsigned char *src) {\n  __memcpy_async(dst, src, LEN, GDRAM2GDRAM, OUT_STRIDE_0, OUT_SEGNUM_1,\n                 OUT_STRIDE_1, OUT_SEGNUM_2, IN_STRIDE_0, IN_SEGNUM_1,\n                 IN_STRIDE_1, IN_SEGNUM_2);\n} \n ``` \n"
  },
  {
    "content": "\n 3.8.1. __bang_write_value \n^^^^^^^^^^^^^^^\n void  __bang_write_value (void * dst , unsigned int  elem_count , char  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __bang_write_value (void * dst , unsigned int  elem_count , half  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __bang_write_value (void * dst , unsigned int  elem_count , bfloat16_t  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __bang_write_value (void * dst , unsigned int  elem_count , short  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __bang_write_value (void * dst , unsigned int  elem_count , float  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __bang_write_value (void * dst , unsigned int  elem_count , int  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n Sets a three-dimensional block in the  \\_\\_nram\\_\\_  address space pointed by  <dst>  to the specified  <value> . The way of setting  <value>  is that takes the  <elem\\_count>  of the data, operates the  <segnum1> + 1  times through the  <stride0> , and then take the  <stride1>  size to iterate the number of  <segnum2> + 1 . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements of one segment.\n*  [in] value : The value to be set to  <dst> .\n*  [in] stride0 : The destination address stride(bytes) in the first dimension.\n*  [in] segnum1 : The destination segment number in the first dimension.\n*  [in] stride1 : The destination address stride(bytes) in the second dimension.\n*  [in] segnum2 : The destination segment number in the second dimension. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;\n*  <stride0>  must be greater than or equal to  <elem\\_count> \\* sizeof(type) , and  <stride1>  must be greater than or equal to  <stride0> \\* (<segnum1> + 1) ;\n* When the value of  <segnum1>  and  <segnum2>  is 0, it represents 1, and when the value is 1, it represents 2, and so on\n "
  },
  {
    "content": "\n 3.8.2. __gdramset \n^^^^^^^^^^^^^^^\n void  __gdramset (void * dst , unsigned int  elem_count , char  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __gdramset (void * dst , unsigned int  elem_count , half  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __gdramset (void * dst , unsigned int  elem_count , bfloat16_t  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __gdramset (void * dst , unsigned int  elem_count , short  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __gdramset (void * dst , unsigned int  elem_count , float  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __gdramset (void * dst , unsigned int  elem_count , int  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n Sets the specified  <value>  to a three-dimensional block in the  \\_\\_mlu\\_device\\_\\_  address space pointed by  <dst> . The way of setting  <value>  is that takes the  <elem\\_count>  of the data, operates the  <segnum1> + 1  times through the  <stride0> , and then takes the  <stride1>  size to iterate the number of  <segnum2> + 1 . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements of one segment.\n*  [in] value : The value to be set to  <dst> .\n*  [in] stride0 : The destination address stride(bytes) in the first dimension.\n*  [in] segnum1 : The destination segment number in the first dimension.\n*  [in] stride1 : The destination address stride(bytes) in the second dimension.\n*  [in] segnum2 : The destination segment number in the second dimension. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;\n*  <stride0>  must be greater than or equal to  <elem\\_count> \\* sizeof(type) , and  <stride1>  must be greater than or equal to  <stride0> \\* (<segnum1> + 1) ;\n* When  <segnum1>  and  <segnum2>  are 0, they represent 1, and when  <segnum1>  and  <segnum2>  are 1, they represent 2, and so on\n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^"
  },
  {
    "content": "\n 3.8.3. __ldramset \n^^^^^^^^^^^^^^^\n void  __ldramset (void * dst , unsigned int  elem_count , char  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __ldramset (void * dst , unsigned int  elem_count , half  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __ldramset (void * dst , unsigned int  elem_count , bfloat16_t  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __ldramset (void * dst , unsigned int  elem_count , short  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __ldramset (void * dst , unsigned int  elem_count , float  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __ldramset (void * dst , unsigned int  elem_count , int  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n Sets the specified  <value>  to a three-dimensional block in the  \\_\\_ldram\\_\\_  address space pointed by  <dst> . The way of setting  <value>  is that takes the  <elem\\_count>  of the data, operates the  <segnum1> + 1  times through the  <stride0> , and then takes the  <stride1>  size to iterate the number of  <segnum2> + 1 . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements of one segment.\n*  [in] value : The value to be set to  <dst> .\n*  [in] stride0 : The destination address stride(bytes) in the first dimension.\n*  [in] segnum1 : The destination segment number in the first dimension.\n*  [in] stride1 : The destination address stride(bytes) in the second dimension.\n*  [in] segnum2 : The destination segment number in the second dimension. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_ldram\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;\n*  <stride0>  must be greater than or equal to  <elem\\_count> \\* sizeof(type) , and  <stride1>  must be greater than or equal to  <stride0> \\* (<segnum1> + 1) ;\n* When  <segnum1>  and  <segnum2>  are 0, they represent 1, and when  <segnum1>  and  <segnum2>  are 1, they represent 2, and so on\n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^"
  },
  {
    "content": "\n 3.8.4. __nramset \n^^^^^^^^^^^^^^^\n void  __nramset (void * dst , unsigned int  elem_count , char  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __nramset (void * dst , unsigned int  elem_count , half  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __nramset (void * dst , unsigned int  elem_count , bfloat16_t  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __nramset (void * dst , unsigned int  elem_count , short  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __nramset (void * dst , unsigned int  elem_count , float  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __nramset (void * dst , unsigned int  elem_count , int  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n Sets the specified  <value>  to a three-dimensional block in the  \\_\\_nram\\_\\_  address space pointed by  <dst> . The way of setting  <value>  is that takes the  <elem\\_count>  of the data, operates the  <segnum1> + 1  times through the  <stride0> , and then takes the  <stride1>  size to iterate the number of  <segnum2> + 1 . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements of one segment.\n*  [in] value : The value to be set to  <dst> .\n*  [in] stride0 : The destination address stride(bytes) in the first dimension.\n*  [in] segnum1 : The destination segment number in the first dimension.\n*  [in] stride1 : The destination address stride(bytes) in the second dimension.\n*  [in] segnum2 : The destination segment number in the second dimension. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;\n*  <stride0>  must be greater than or equal to  <elem\\_count> \\* sizeof(type) , and  <stride1>  must be greater than or equal to  <stride0> \\* (<segnum1> + 1) ;\n* When  <segnum1>  and  <segnum2>  are 0, they represent 1, and when  <segnum1>  and  <segnum2>  are 1, they represent 2, and so on\n Instruction Pipeline * Move. \n^^^^^^^^^^^^^^^"
  },
  {
    "content": "\n 3.8.5. __nramset_async \n^^^^^^^^^^^^^^^\n void  __nramset_async (void * dst , unsigned int  elem_count , char  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __nramset_async (void * dst , unsigned int  elem_count , half  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __nramset_async (void * dst , unsigned int  elem_count , bfloat16_t  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __nramset_async (void * dst , unsigned int  elem_count , short  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __nramset_async (void * dst , unsigned int  elem_count , float  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __nramset_async (void * dst , unsigned int  elem_count , int  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n Sets the specified  <value>  to a three-dimensional block in the  \\_\\_nram\\_\\_  address space pointed by  <dst>  asynchronously. The way of setting  <value>  is that takes the  <elem\\_count>  of the data, operates the  <segnum1> + 1  times through the  <stride0> , and then takes the  <stride1>  size to iterate the number of  <segnum2> + 1 . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements of one segment.\n*  [in] value : The value to be set to  <dst> .\n*  [in] stride0 : The destination address stride(bytes) in the first dimension.\n*  [in] segnum1 : The destination segment number in the first dimension.\n*  [in] stride1 : The destination address stride(bytes) in the second dimension.\n*  [in] segnum2 : The destination segment number in the second dimension. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;\n*  <stride0>  must be greater than or equal to  <elem\\_count> \\* sizeof(type) , and  <stride1>  must be greater than or equal to  <stride0> \\* (<segnum1> + 1) ;\n* When  <segnum1>  and  <segnum2>  are 0, they represent 1, and when  <segnum1>  and  <segnum2>  are 1, they represent 2, and so on\n Instruction Pipeline * Move. "
  },
  {
    "content": "\n 3.8.6. __sramset \n^^^^^^^^^^^^^^^\n void  __sramset (void * dst , unsigned int  elem_count , char  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __sramset (void * dst , unsigned int  elem_count , half  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __sramset (void * dst , unsigned int  elem_count , bfloat16_t  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __sramset (void * dst , unsigned int  elem_count , short  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __sramset (void * dst , unsigned int  elem_count , float  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __sramset (void * dst , unsigned int  elem_count , int  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n Sets the specified  <value>  to a three-dimensional block in the  \\_\\_mlu\\_shared\\_\\_  address space pointed by  <dst> . The way of setting  <value>  is that takes the  <elem\\_count>  of the data, operates the  <segnum1> + 1  times through the  <stride0> , and then takes the  <stride1>  size to iterate the number of  <segnum2> + 1 . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements of one segment.\n*  [in] value : The value to be set to  <dst> .\n*  [in] stride0 : The destination address stride(bytes) in the first dimension.\n*  [in] segnum1 : The destination segment number in the first dimension.\n*  [in] stride1 : The destination address stride(bytes) in the second dimension.\n*  [in] segnum2 : The destination segment number in the second dimension. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_mlu\\_shared\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;\n*  <stride0>  must be greater than or equal to  <elem\\_count> \\* sizeof(type) , and  <stride1>  must be greater than or equal to  <stride0> \\* (<segnum1> + 1) ;\n* When  <segnum1>  and  <segnum2>  are 0, they represent 1, and when  <segnum1>  and  <segnum2>  are 1, they represent 2, and so on\n Instruction Pipeline * Move instruction pipeline of MPU core. "
  },
  {
    "content": "\n 3.8.7. __sramset_async \n^^^^^^^^^^^^^^^\n void  __sramset_async (void * dst , unsigned int  elem_count , char  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __sramset_async (void * dst , unsigned int  elem_count , half  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __sramset_async (void * dst , unsigned int  elem_count , bfloat16_t  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __sramset_async (void * dst , unsigned int  elem_count , short  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __sramset_async (void * dst , unsigned int  elem_count , float  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n void  __sramset_async (void * dst , unsigned int  elem_count , int  value , unsigned int  stride0 , unsigned int  segnum1 , unsigned int  stride1 , unsigned int  segnum2 )   \n Sets the specified  <value>  to a three-dimensional block in the  \\_\\_mlu\\_shared\\_\\_  address space pointed by  <dst>  asynchronously. The way of setting  <value>  is that takes the  <elem\\_count>  of the data, operates the  <segnum1> + 1  times through the  <stride0> , and then takes the  <stride1>  size to iterate the number of  <segnum2> + 1 . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements of one segment.\n*  [in] value : The value to be set to  <dst> .\n*  [in] stride0 : The destination address stride(bytes) in the first dimension.\n*  [in] segnum1 : The destination segment number in the first dimension.\n*  [in] stride1 : The destination address stride(bytes) in the second dimension.\n*  [in] segnum2 : The destination segment number in the second dimension. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_mlu\\_shared\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;\n*  <stride0>  must be greater than or equal to  <elem\\_count> \\* sizeof(type) , and  <stride1>  must be greater than or equal to  <stride0> \\* (<segnum1> + 1) ;\n* When  <segnum1>  and  <segnum2>  are 0, they represent 1, and when  <segnum1>  and  <segnum2>  are 1, they represent 2, and so on\n Instruction Pipeline * Move instruction pipeline of MPU core. \n"
  },
  {
    "content": "\n 3.9.1. __is_dram \n^^^^^^^^^^^^^^^\n bool  __is_dram ( const  void * ptr )   \n^^^^^^^^^^^^^^^\n Returns  true  if  <ptr>  points to  \\_\\_mlu\\_device\\_\\_  or  \\_\\_ldram\\_\\_  address space. \n^^^^^^^^^^^^^^^\n Parameters *  [in] ptr : The input pointer. \n^^^^^^^^^^^^^^^\n Return *  bool . \n^^^^^^^^^^^^^^^\n Remark * None. \n Instruction Pipeline * Scalar. \n"
  },
  {
    "content": "\n 3.9.2. __is_nram \n^^^^^^^^^^^^^^^\n bool  __is_nram ( const  void * ptr )   \n^^^^^^^^^^^^^^^\n Returns  true  if  <ptr>  points to  \\_\\_nram\\_\\_  address space. \n^^^^^^^^^^^^^^^\n Parameters *  [in] ptr : The input pointer. \n^^^^^^^^^^^^^^^\n Return *  bool . \n^^^^^^^^^^^^^^^\n Remark * None. \n Instruction Pipeline * Scalar. \n"
  },
  {
    "content": "\n 3.9.3. __is_sram \n^^^^^^^^^^^^^^^\n bool  __is_sram ( const  void * ptr )   \n^^^^^^^^^^^^^^^\n Returns  true  if  <ptr>  points to  \\_\\_mlu\\_shared\\_\\_  address space. \n^^^^^^^^^^^^^^^\n Parameters *  [in] ptr : The input pointer. \n^^^^^^^^^^^^^^^\n Return *  bool . \n^^^^^^^^^^^^^^^\n Remark * None. \n Instruction Pipeline * Scalar. \n"
  },
  {
    "content": "\n 3.9.4. __is_wram \n^^^^^^^^^^^^^^^\n bool  __is_wram ( const  void * ptr )   \n^^^^^^^^^^^^^^^\n Returns  true  if  <ptr>  points to  \\_\\_wram\\_\\_  address space. \n^^^^^^^^^^^^^^^\n Parameters *  [in] ptr : The input pointer. \n^^^^^^^^^^^^^^^\n Return *  bool . \n^^^^^^^^^^^^^^^\n Remark * None. \n Instruction Pipeline * Scalar. \n"
  },
  {
    "content": "\n 3.10.1. __load_gdram \n^^^^^^^^^^^^^^^\n int32_t  __load_gdram ( const  int32_t * src )   \n int8_t  __load_gdram ( const  int8_t * src )   \n int16_t  __load_gdram ( const  int16_t * src )   \n uint32_t  __load_gdram ( const  uint32_t * src )   \n uint8_t  __load_gdram ( const  uint8_t * src )   \n uint16_t  __load_gdram ( const  uint16_t * src )   \n float  __load_gdram ( const  float * src )   \n half  __load_gdram ( const  half * src )   \n bfloat16_t  __load_gdram ( const  bfloat16_t * src )   \n This function loads data from  <src>  of GDRAM. \n^^^^^^^^^^^^^^^\n Parameters *  [in] src : The address to load the data. \n^^^^^^^^^^^^^^^\n Return * The data in memory address  <src> . \n^^^^^^^^^^^^^^^\n Remark *  <src>  must point to  \\_\\_mlu\\_device\\_\\_  address space\n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(int32_t* dst) {\n  __mlu_device__ int32_t x = 1;\n  int32_t y  = __load_gdram(&x);\n  *dst = y;\n} \n ``` \n"
  },
  {
    "content": "\n 3.10.2. __load_ldram \n^^^^^^^^^^^^^^^\n int32_t  __load_ldram ( const  int32_t * src )   \n int8_t  __load_ldram ( const  int8_t * src )   \n int16_t  __load_ldram ( const  int16_t * src )   \n uint32_t  __load_ldram ( const  uint32_t * src )   \n uint8_t  __load_ldram ( const  uint8_t * src )   \n uint16_t  __load_ldram ( const  uint16_t * src )   \n float  __load_ldram ( const  float * src )   \n half  __load_ldram ( const  half * src )   \n bfloat16_t  __load_ldram ( const  bfloat16_t * src )   \n This function loads data from  <src>  of LDRAM. \n^^^^^^^^^^^^^^^\n Parameters *  [in] src : The address to load the data. \n^^^^^^^^^^^^^^^\n Return * The data in memory address  <src> . \n^^^^^^^^^^^^^^^\n Remark *  <src>  must point to  \\_\\_ldram\\_\\_  address space\n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(int32_t* dst) {\n  __ldram__ int32_t x = 1;\n  int32_t y  = __load_ldram(&x);\n  *dst = y;\n} \n ``` \n"
  },
  {
    "content": "\n 3.10.3. __load_nram \n^^^^^^^^^^^^^^^\n int32_t  __load_nram ( const  int32_t * src )   \n int8_t  __load_nram ( const  int8_t * src )   \n int16_t  __load_nram ( const  int16_t * src )   \n uint32_t  __load_nram ( const  uint32_t * src )   \n uint8_t  __load_nram ( const  uint8_t * src )   \n uint16_t  __load_nram ( const  uint16_t * src )   \n float  __load_nram ( const  float * src )   \n half  __load_nram ( const  half * src )   \n bfloat16_t  __load_nram ( const  bfloat16_t * src )   \n This function loads data from  <src>  of NRAM. \n^^^^^^^^^^^^^^^\n Parameters *  [in] src : The address to load the data. \n^^^^^^^^^^^^^^^\n Return * The data in memory address  <src> . \n^^^^^^^^^^^^^^^\n Remark *  <src>  must point to  \\_\\_nram\\_\\_  address space\n \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(int32_t* dst) {\n  __nram__ int32_t x = 1;\n  int32_t y  = __load_nram(&x);\n  *dst = y;\n} \n ``` \n"
  },
  {
    "content": "\n 3.10.4. __load_sram \n^^^^^^^^^^^^^^^\n int32_t  __load_sram ( const  int32_t * src )   \n int8_t  __load_sram ( const  int8_t * src )   \n int16_t  __load_sram ( const  int16_t * src )   \n uint32_t  __load_sram ( const  uint32_t * src )   \n uint8_t  __load_sram ( const  uint8_t * src )   \n uint16_t  __load_sram ( const  uint16_t * src )   \n float  __load_sram ( const  float * src )   \n half  __load_sram ( const  half * src )   \n bfloat16_t  __load_sram ( const  bfloat16_t * src )   \n This function loads data from  <src>  of SRAM. \n^^^^^^^^^^^^^^^\n Parameters *  [in] src : The address to load the data. \n^^^^^^^^^^^^^^^\n Return * The data in memory address  <src> . \n^^^^^^^^^^^^^^^\n Remark *  <src>  must point to  \\_\\_mlu\\_shared\\_\\_  address space\n Instruction Pipeline * Move. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(int32_t* dst) {\n  __mlu_shared__ int32_t x = 1;\n  int32_t y  = __load_sram(&x);\n  *dst = y;\n} \n ``` \n"
  },
  {
    "content": "\n 3.11.1. __store_gdram \n^^^^^^^^^^^^^^^\n void  __store_gdram (int32_t * dst , int32_t  value )   \n void  __store_gdram (int8_t * dst , int8_t  value )   \n void  __store_gdram (int16_t * dst , int16_t  value )   \n void  __store_gdram (uint32_t * dst , uint32_t  value )   \n void  __store_gdram (uint8_t * dst , uint8_t  value )   \n void  __store_gdram (uint16_t * dst , uint16_t  value )   \n void  __store_gdram (float * dst , float  value )   \n void  __store_gdram (half * dst , half  value )   \n void  __store_gdram (bfloat16_t * dst , bfloat16_t  value )   \n Stores  <value>  into  <dst>  of GDRAM. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address to store the data.\n*  [in] value : The source value to be stored. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space\n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(int32_t* dst) {\n  __mlu_device__ int32_t x;\n  int32_t y = *dst;\n  __store_gdram(&x, y);\n} \n ``` \n"
  },
  {
    "content": "\n 3.11.2. __store_ldram \n^^^^^^^^^^^^^^^\n void  __store_ldram (int32_t * dst , int32_t  value )   \n void  __store_ldram (int8_t * dst , int8_t  value )   \n void  __store_ldram (int16_t * dst , int16_t  value )   \n void  __store_ldram (uint32_t * dst , uint32_t  value )   \n void  __store_ldram (uint8_t * dst , uint8_t  value )   \n void  __store_ldram (uint16_t * dst , uint16_t  value )   \n void  __store_ldram (float * dst , float  value )   \n void  __store_ldram (half * dst , half  value )   \n void  __store_ldram (bfloat16_t * dst , bfloat16_t  value )   \n Stores  <value>  into  <dst>  of LDRAM. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address to store the data.\n*  [in] value : The source value to be stored. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_ldram\\_\\_  address space\n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(int32_t* dst) {\n  __ldram__ int32_t x;\n  int32_t y = *dst;\n  __store_ldram(&x, y);\n} \n ``` \n"
  },
  {
    "content": "\n 3.11.3. __store_nram \n^^^^^^^^^^^^^^^\n void  __store_nram (int32_t * dst , int32_t  value )   \n void  __store_nram (int8_t * dst , int8_t  value )   \n void  __store_nram (int16_t * dst , int16_t  value )   \n void  __store_nram (uint32_t * dst , uint32_t  value )   \n void  __store_nram (uint8_t * dst , uint8_t  value )   \n void  __store_nram (uint16_t * dst , uint16_t  value )   \n void  __store_nram (float * dst , float  value )   \n void  __store_nram (half * dst , half  value )   \n void  __store_nram (bfloat16_t * dst , bfloat16_t  value )   \n Stores  <value>  into  <dst>  of NRAM. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address to store the data.\n*  [in] value : The source value to be stored. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_nram\\_\\_  address space\n \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(int32_t* dst) {\n  __nram__ int32_t x;\n  int32_t y = *dst;\n  __store_nram(&x, y);\n} \n ``` \n"
  },
  {
    "content": "\n 3.11.4. __store_sram \n^^^^^^^^^^^^^^^\n void  __store_sram (int32_t * dst , int32_t  value )   \n void  __store_sram (int8_t * dst , int8_t  value )   \n void  __store_sram (int16_t * dst , int16_t  value )   \n void  __store_sram (uint32_t * dst , uint32_t  value )   \n void  __store_sram (uint8_t * dst , uint8_t  value )   \n void  __store_sram (uint16_t * dst , uint16_t  value )   \n void  __store_sram (float * dst , float  value )   \n void  __store_sram (half * dst , half  value )   \n void  __store_sram (bfloat16_t * dst , bfloat16_t  value )   \n Stores  <value>  into  <dst>  of SRAM. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address to store the data.\n*  [in] value : The source value to be stored. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_mlu\\_shared\\_\\_  address space\n Instruction Pipeline * Move. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(int32_t* dst) {\n  __mlu_shared__ int32_t x;\n  int32_t y = *dst;\n  __store_sram(&x, y);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.1. __bang_bexpand \n^^^^^^^^^^^^^^^\n void  __bang_bexpand (char * dst ,  const  void * src , unsigned int  dst_dim_n , unsigned int  dst_dim_h , unsigned int  dst_dim_w , unsigned int  dst_dim_c )   \n void  __bang_bexpand (short * dst ,  const  void * src , unsigned int  dst_dim_n , unsigned int  dst_dim_h , unsigned int  dst_dim_w , unsigned int  dst_dim_c )   \n void  __bang_bexpand (int * dst ,  const  void * src , unsigned int  dst_dim_n , unsigned int  dst_dim_h , unsigned int  dst_dim_w , unsigned int  dst_dim_c )   \n This function converts each binary bit in  <src>  to value of specified data type and saves the result in  <dst>  . The bit  1  and  0  will be converted to value  1  and  0  of corresponding data type. For example, if the data type of  <dst>  is  char  and  <src>  is  0b11001101  , the  <dst>  will be  0b 00000001 00000001 00000000 00000000 00000001 00000001 00000000 00000001  . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor.\n*  [in] src : The address of source binary vector.\n*  [in] dst\\_dim\\_n : The dimension N of destination tensor.\n*  [in] dst\\_dim\\_h : The dimension H of destination tensor.\n*  [in] dst\\_dim\\_w : The dimension W of destination tensor.\n*  [in] dst\\_dim\\_c : The dimension C of destination tensor. \n^^^^^^^^^^^^^^^\n Return *  void . * \n^^^^^^^^^^^^^^^\n Remark *  <dst>  and  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <dst\\_dim\\_c>  must be divisible by 8;\n*  <dst\\_dim\\_n> ,  <dst\\_dim\\_h> ,  <dst\\_dim\\_w>  and  <dst\\_dim\\_c>  must be greater than 0 and less than 65536. \n^^^^^^^^^^^^^^^\n Example \n``` \n include \"bang.h\" \n define N 1 \n define H 2 \n define W 8 \n define C 32 \n define DST_NUM (N * H * W * C) \n define SRC_NUM (DST_NUM / 8) \n __mlu_entry__ void kernel(int* dst, unsigned char* src) {\n  __nram__ unsigned char src_tmp[SRC_NUM];\n  __nram__ int dst_tmp[DST_NUM];\n  __memcpy(src_tmp, src, SRC_NUM * sizeof(unsigned char), GDRAM2NRAM);\n  __bang_bexpand(dst_tmp, src_tmp, N, H, W, C);\n  __memcpy(dst, dst_tmp, DST_NUM * sizeof(int), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.2. __bang_breduce \n^^^^^^^^^^^^^^^\n void  __bang_breduce (void * dst ,  const  char * src , unsigned int  src_dim_n , unsigned int  src_dim_h , unsigned int  src_dim_w , unsigned int  src_dim_c )   \n void  __bang_breduce (void * dst ,  const  short * src , unsigned int  src_dim_n , unsigned int  src_dim_h , unsigned int  src_dim_w , unsigned int  src_dim_c )   \n void  __bang_breduce (char * dst ,  const  int * src , unsigned int  src_dim_n , unsigned int  src_dim_h , unsigned int  src_dim_w , unsigned int  src_dim_c )   \n This function converts each value in  <src>  to binary bit and saves the result in  <dst>  . Value  0  will be converted to bit  0  and other value will be converted to bit 1. For example, if the data type of  <src>  is  char  and  <src>  is  0b 00000001 10000001 00000000 00000000 11111111 01000000 00000000 11000000  , the  <dst>  will be  0b11001101  . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination binary vector.\n*  [in] src : The address of source tensor.\n*  [in] src\\_dim\\_n : The dimension N of source tensor.\n*  [in] src\\_dim\\_h : The dimension H of source tensor.\n*  [in] src\\_dim\\_w : The dimension W of source tensor.\n*  [in] src\\_dim\\_c : The dimension C of source tensor. \n^^^^^^^^^^^^^^^\n Return *  void . * \n^^^^^^^^^^^^^^^\n Remark *  <dst>  and  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <src\\_dim\\_c>  must be divisible by 8;\n*  <src\\_dim\\_n> ,  <src\\_dim\\_h> ,  <src\\_dim\\_w>  and  <src\\_dim\\_c>  must be greater than zero and less than 65536. \n^^^^^^^^^^^^^^^\n Example \n``` \n include \"bang.h\" \n define N 1 \n define H 2 \n define W 8 \n define C 32 \n define SRC_NUM (N * H * W * C) \n define DST_NUM (SRC_NUM / 8) \n __mlu_entry__ void kernel(unsigned char* dst, int* src) {\n  __nram__ int src_tmp[SRC_NUM];\n  __nram__ char dst_tmp[DST_NUM];\n  __memcpy(src_tmp, src, SRC_NUM * sizeof(int), GDRAM2NRAM);\n  __bang_breduce(dst_tmp, src_tmp, N, H, W, C);\n  __memcpy(dst, dst_tmp, DST_NUM * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.3. __bang_conv \n^^^^^^^^^^^^^^^\n void  __bang_conv (int16_t * dst ,  const  int16_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (int16_t * dst ,  const  int16_t * src ,  const  int8_t * kernel ,  const  int16_t * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (int16_t * dst ,  const  int16_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (int16_t * dst ,  const  int16_t * src ,  const  int16_t * kernel ,  const  int16_t * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int16_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int16_t * src ,  const  int16_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (int16_t * dst ,  const  int8_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (int16_t * dst ,  const  int8_t * src ,  const  int8_t * kernel ,  const  int16_t * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int16_t * src ,  const  int8_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int16_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (half * dst ,  const  int16_t * src ,  const  int8_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int8_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int8_t * src ,  const  int8_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (half * dst ,  const  int16_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (half * dst ,  const  int16_t * src ,  const  int16_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (half * dst ,  const  int16_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (int16_t * dst ,  const  int8_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (int16_t * dst ,  const  int16_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (int16_t * dst ,  const  int16_t * src ,  const  int16_t * kernel ,  const  int16_t * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int8_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (half * dst ,  const  int8_t * src ,  const  int8_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (half * dst ,  const  int8_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int8_t * src ,  const  int16_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int8_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int8_t * src ,  const  int16_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int8_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (half * dst ,  const  int8_t * src ,  const  int16_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int8_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  dilation_width , unsigned int  dilation_height )   \n void  __bang_conv (float * dst ,  const  int8_t * src ,  const  int16_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  dilation_width , unsigned int  dilation_height )   \n void  __bang_conv (half * dst ,  const  int8_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  out_dilation_width , unsigned int  out_dilation_height )   \n void  __bang_conv (float * dst ,  const  int8_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  dilation_width , unsigned int  dilation_height , unsigned int  out_dilation_width , unsigned int  out_dilation_height )   \n void  __bang_conv (int16_t * dst ,  const  int8_t * src ,  const  int8_t * kernel ,  const  int16_t * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (int16_t * dst ,  const  int16_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (int16_t * dst ,  const  int16_t * src ,  const  int8_t * kernel ,  const  int16_t * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int16_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int16_t * src ,  const  int8_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int16_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int16_t * src ,  const  int16_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int16_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int16_t * src ,  const  int8_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int8_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int8_t * src ,  const  int8_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int8_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int8_t * src ,  const  int8_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int16_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int16_t * src ,  const  int16_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  float * src ,  const  float * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv (float * dst ,  const  half * src ,  const  half * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv (float * dst ,  const  float * src ,  const  half * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv (float * dst ,  const  half * src ,  const  float * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv (float * dst ,  const  bfloat16_t * src ,  const  float * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv (float * dst ,  const  float * src ,  const  bfloat16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv (float * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv (float * dst ,  const  float * src ,  const  float * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv (float * dst ,  const  half * src ,  const  half * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv (float * dst ,  const  half * src ,  const  float * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv (float * dst ,  const  float * src ,  const  half * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv (float * dst ,  const  float * src ,  const  bfloat16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv (float * dst ,  const  bfloat16_t * src ,  const  float * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv (half * dst ,  const  int4x2_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int4x2_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int4x2_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int4x2_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int4x2_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int4x2_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int8_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int8_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int16_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int16_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int4x2_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int4x2_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (half * dst ,  const  int4x2_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int4x2_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (half * dst ,  const  int4x2_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int4x2_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (half * dst ,  const  int8_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int8_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (half * dst ,  const  int16_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int16_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (half * dst ,  const  int4x2_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv (float * dst ,  const  int4x2_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv (half * dst ,  const  int4x2_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , int  fix_position , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv (float * dst ,  const  int4x2_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv (half * dst ,  const  int4x2_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv (float * dst ,  const  int4x2_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv (half * dst ,  const  int8_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv (float * dst ,  const  int8_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv (half * dst ,  const  int16_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv (float * dst ,  const  int16_t * src ,  const  int4x2_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv (half * dst ,  const  int4x2_t * src ,  const  int4x2_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int4x2_t * src ,  const  int4x2_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int4x2_t * src ,  const  int8_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int4x2_t * src ,  const  int8_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int4x2_t * src ,  const  int16_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int4x2_t * src ,  const  int16_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int8_t * src ,  const  int4x2_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int8_t * src ,  const  int4x2_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int16_t * src ,  const  int4x2_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (float * dst ,  const  int16_t * src ,  const  int4x2_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv (half * dst ,  const  int4x2_t * src ,  const  int4x2_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int4x2_t * src ,  const  int4x2_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (half * dst ,  const  int4x2_t * src ,  const  int8_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int4x2_t * src ,  const  int8_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (half * dst ,  const  int4x2_t * src ,  const  int16_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int4x2_t * src ,  const  int16_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (half * dst ,  const  int8_t * src ,  const  int4x2_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int8_t * src ,  const  int4x2_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (half * dst ,  const  int16_t * src ,  const  int4x2_t * kernel ,  const  half * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  int16_t * src ,  const  int4x2_t * kernel ,  const  float * bias , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv (float * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n In  \\_\\_nram\\_\\_  address space, uses the four-dimensional convolution kernel  <kernel>[<channel\\_output>, <kernel\\_height>, <kernel\\_width>, <channel\\_input>]  to perform a convolution operation on the three-dimensional tensor  <src>[<height>, <width>, <channel\\_input>]  with an interactive step size of  [<stride\\_width>, <stride\\_height>] , and stores the result in the three-dimensional tensor  <dst>[<dst\\_height>, <dst\\_width>, <channel\\_output>] . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor which has (NH_oW_oC_o) data layout.\n*  [in] src : The address of source tensor which has (NH_iW_iC_i) data layout.\n*  [in] kernel : The address of filter tensor which has (C_oH_kW_kC_i) data layout.\n*  [in] bias : The address of bias tensor which has ([C_o]) shape.\n*  [in] channel\\_input : Number of input channels.\n*  [in] height : The height of source tensor.\n*  [in] width : The width of source tensor.\n*  [in] kernel\\_height : The height of filter tensor.\n*  [in] kernel\\_width : The width of filter tensor.\n*  [in] stride\\_width : The stride in W direction.\n*  [in] stride\\_height : The stride in H direction.\n*  [in] channel\\_output : Number of output channels.\n*  [in] fix\\_position : Sum of the scale factor of  <src>  and  <kernel> .\n*  [in] indilation\\_width : Input dilation in W direction.\n*  [in] indilation\\_height : Input dilation in H direction.\n*  [in] outdilation\\_width : Output dilation in W direction.\n*  [in] outdilation\\_height : Output dilation in H direction. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src> ,  <dst>  and  <bias>  must point to  \\_\\_nram\\_\\_  address space;\n*  <kernel>  must point to  \\_\\_wram\\_\\_  address space;\n*  <fix\\_position>  is the sum of the scale factor of  <src>  and  <kernel> ;\n*  <fix\\_position>  must be in the range  [-127, 127] ;\n On  (m)tp\\_3xx  and higher, there is no alignment constraint for parameter  <channel\\_input> , but when allocating memory, the  ci  dimension of the memory space of  <kernel>  must satisfy the following alignment constraints: \n If the types of  <src>  and  <kernel>  are both floating point: \n If  sizeof(typeof<src>) / sizeof(typeof<kernel>) == 2 , (C_i) *  sizeof(typeof<kernel>)  must be 32-byte aligned; \n Otherwise, (C_i) *  sizeof(typeof<kernel>)  must be 64-byte aligned; \n If the types of  <src>  and  <kernel>  are both integer: \n If  --wram-align 64  or  #pragma bang walign(64) \n On  (m)tp\\_3xx  and higher, there is no alignment constraint for parameter  <channel\\_output> , but when allocating memory, the  co  dimension of memory space of  <kernel>  must be 64 aligned; \n The space size of  <bias>  is identical to  <channel\\_output> ; \n <kernel\\_height> ,  <kernel\\_width> ,  <channel\\_input>  and  <channel\\_output>  must be greater than 0; \n <stride\\_width>  and  <stride\\_height>  must be in range [1, 1023]; \n <indilation\\_width> ,  <indilation\\_height> ,  <outdilation\\_width>  and  <outdilation\\_height>  must be in range [1, 1023], and 1 means no dilation; \n If  <indilation\\_height>  is used,  (<height> - ((<kernel\\_height> - 1) \\* <indilation\\_height> + 1)) / <stride\\_height> + 1  must be greater than 0; otherwise,  (<height> - <kernel\\_height>) / <stride\\_height> + 1  must be greater than 0; \n If  <indilation\\_width>  is used,  (<width> - ((<kernel\\_width> - 1) \\* <indilation\\_width> + 1)) / <stride\\_width> + 1  must be greater than 0; otherwise,  (<width> - <kernel\\_width>) / <stride\\_width> + 1  must be greater than 0; \n On target  (m)tp\\_322  , if use  <indilation\\_height>  ,  (<height> - ((<kernel\\_height> - 1) \\* <indilation\\_height> + 1)) / <stride\\_height> + 1  must be in the range  [1, 1024]  ; \n On target  (m)tp\\_322  , if use  <dilation\\_height>  ,  (<height> - ((<kernel\\_height> - 1) \\* <dilation\\_height> + 1)) / <stride\\_height> + 1  must be in the range  [1, 1024]  ; \n On target  (m)tp\\_322  , if neither  <dilation\\_height>  nor  <indilation\\_height>  are used,  (<height> - <kernel\\_height>) / <stride\\_height> + 1  must be in range  [1, 1024]  ; "
  },
  {
    "content": "\n 3.12.4. __bang_conv_partial \n^^^^^^^^^^^^^^^\n void  __bang_conv_partial (half * dst ,  const  int8_t * src ,  const  int8_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (half * dst ,  const  int16_t * src ,  const  int8_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (half * dst ,  const  int16_t * src ,  const  int16_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (float * dst ,  const  int8_t * src ,  const  int8_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (half * dst ,  const  int8_t * src ,  const  int16_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (float * dst ,  const  int8_t * src ,  const  int16_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (float * dst ,  const  int16_t * src ,  const  int8_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (float * dst ,  const  int16_t * src ,  const  int16_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (half * dst ,  const  int8_t * src ,  const  int16_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  in_dilation_width , unsigned int  in_dilation_height )   \n void  __bang_conv_partial (float * dst ,  const  int8_t * src ,  const  int16_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  in_dilation_width , unsigned int  in_dilation_height )   \n void  __bang_conv_partial (half * dst ,  const  int8_t * src ,  const  int8_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv_partial (half * dst ,  const  int16_t * src ,  const  int8_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv_partial (half * dst ,  const  int16_t * src ,  const  int16_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv_partial (float * dst ,  const  int8_t * src ,  const  int8_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv_partial (float * dst ,  const  int16_t * src ,  const  int8_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv_partial (float * dst ,  const  int16_t * src ,  const  int16_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv_partial (float * dst ,  const  half * src ,  const  half * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv_partial (float * dst ,  const  half * src ,  const  float * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv_partial (float * dst ,  const  float * src ,  const  half * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv_partial (float * dst ,  const  float * src ,  const  float * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv_partial (float * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv_partial (float * dst ,  const  bfloat16_t * src ,  const  float * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv_partial (float * dst ,  const  float * src ,  const  bfloat16_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv_partial (half * dst ,  const  int8_t * src ,  const  int16_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  in_dilation_width , unsigned int  in_dilation_height , unsigned int  out_dilation_width , unsigned int  out_dilation_height )   \n void  __bang_conv_partial (float * dst ,  const  int8_t * src ,  const  int16_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  in_dilation_width , unsigned int  in_dilation_height , unsigned int  out_dilation_width , unsigned int  out_dilation_height )   \n void  __bang_conv_partial (float * dst ,  const  half * src ,  const  half * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv_partial (float * dst ,  const  float * src ,  const  float * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv_partial (float * dst ,  const  float * src ,  const  half * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv_partial (float * dst ,  const  half * src ,  const  float * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv_partial (float * dst ,  const  float * src ,  const  bfloat16_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv_partial (float * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv_partial (half * dst ,  const  int4x2_t * src ,  const  int4x2_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (float * dst ,  const  int4x2_t * src ,  const  int4x2_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (half * dst ,  const  int4x2_t * src ,  const  int8_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (float * dst ,  const  int4x2_t * src ,  const  int8_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (half * dst ,  const  int4x2_t * src ,  const  int16_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (float * dst ,  const  int4x2_t * src ,  const  int16_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (half * dst ,  const  int8_t * src ,  const  int4x2_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (float * dst ,  const  int8_t * src ,  const  int4x2_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (half * dst ,  const  int16_t * src ,  const  int4x2_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (float * dst ,  const  int16_t * src ,  const  int4x2_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_partial (half * dst ,  const  int4x2_t * src ,  const  int4x2_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv_partial (float * dst ,  const  int4x2_t * src ,  const  int4x2_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv_partial (half * dst ,  const  int4x2_t * src ,  const  int8_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv_partial (float * dst ,  const  int4x2_t * src ,  const  int8_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv_partial (half * dst ,  const  int4x2_t * src ,  const  int16_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv_partial (float * dst ,  const  int4x2_t * src ,  const  int16_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv_partial (half * dst ,  const  int8_t * src ,  const  int4x2_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv_partial (float * dst ,  const  int8_t * src ,  const  int4x2_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv_partial (half * dst ,  const  int16_t * src ,  const  int4x2_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv_partial (float * dst ,  const  int16_t * src ,  const  int4x2_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height )   \n void  __bang_conv_partial (half * dst ,  const  int4x2_t * src ,  const  int4x2_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv_partial (float * dst ,  const  int4x2_t * src ,  const  int4x2_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv_partial (half * dst ,  const  int4x2_t * src ,  const  int8_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv_partial (float * dst ,  const  int4x2_t * src ,  const  int8_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv_partial (half * dst ,  const  int4x2_t * src ,  const  int16_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv_partial (float * dst ,  const  int4x2_t * src ,  const  int16_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv_partial (half * dst ,  const  int8_t * src ,  const  int4x2_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv_partial (float * dst ,  const  int8_t * src ,  const  int4x2_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv_partial (half * dst ,  const  int16_t * src ,  const  int4x2_t * kernel ,  const  half * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv_partial (float * dst ,  const  int16_t * src ,  const  int4x2_t * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n void  __bang_conv_partial (float * dst ,  const  bfloat16_t * src ,  const  float * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n In  \\_\\_nram\\_\\_  address space, uses the four-dimensional convolution kernel  <kernel>[<channel\\_output>, <kernel\\_height>, <kernel\\_width>, <channel\\_input>]  to perform a partial convolution operation on the three-dimensional tensor  <src>[<height>, <width>, <channel\\_input>]  with an interactive step size of  [<stride\\_width>, <stride\\_height>] , then adds the three-dimensional tensor  <partial>[<dst\\_height>, <dst\\_width>, <channel\\_output>] , and stores the result in the three-dimensional tensor  <dst>[<dst\\_height>, <dst\\_width>, <channel\\_output>] . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor which has (NH_oW_oC_o) data layout.\n*  [in] src : The address of source tensor which has (NH_iW_iC_i) data layout.\n*  [in] kernel : The address of filter tensor which has (C_oH_kW_kC_i) data layout.\n*  [in] partial : The address of partial_sum tensor which has (NH_oW_oC_o) data layout.\n*  [in] channel\\_input : Number of input channels.\n*  [in] height : The height of source tensor.\n*  [in] width : The width of source tensor.\n*  [in] kernel\\_height : The height of filter tensor.\n*  [in] kernel\\_width : The width of filter tensor.\n*  [in] stride\\_width : The stride in W direction.\n*  [in] stride\\_height : The stride in H direction.\n*  [in] channel\\_output : Number of output channels.\n*  [in] fix\\_position : Scale Sum of the scale of  <src>  and  <kernel> .\n*  [in] indilation\\_width : Input dilation in W direction.\n*  [in] indilation\\_height : Input dilation in H direction.\n*  [in] outdilation\\_width : Output dilation in W direction.\n*  [in] outdilation\\_height : Output dilation in H direction. \n^^^^^^^^^^^^^^^\n Return *  void \n^^^^^^^^^^^^^^^\n Remark *  <src> ,  <dst>  and  <partial>  must point to  \\_\\_nram\\_\\_  address space;\n*  <kernel>  must point to  \\_\\_wram\\_\\_  address space;\n*  <fix\\_position>  is the sum of the scale factor of  <src>  and  <kernel> ;\n*  <fix\\_position>  must be in the range [-127, 127];\n* The address of  <dst> ,  <src>  or  <partial>  must be 64-byte aligned on  (m)tp\\_2xx ;\n* The address of  <kernel>  must be 32-byte aligned;\n*  <channel\\_input> \\* sizeof(typeof<src>)  must be 64-byte aligned on  (m)tp\\_2xx ;\n*  <channel\\_output>  must be divisible by 64 on  (m)tp\\_2xx ;\n*  <channel\\_output> \\* sizeof(typeof<dst>)  must be 64-byte aligned on  (m)tp\\_2xx ;\n On  (m)tp\\_3xx  and higher, there is no alignment constraint for parameter  <channel\\_input> , but when allocating memory, the  ci  dimension of the memory space of  <kernel>  must satisfy the following alignment constraints: \n If the types of  <src>  and  <kernel>  are both floating point: \n If  sizeof(typeof<src>) / sizeof(typeof<kernel>) == 2 , (C_i) *  sizeof(typeof<kernel>)  must be 32-byte aligned; \n Otherwise, (C_i) *  sizeof(typeof<kernel>)  must be 64-byte aligned; \n If the types of  <src>  and  <kernel>  are both integer: \n If  --wram-align 64  or  #pragma bang walign(64) \n  On  (m)tp\\_3xx  and higher, there is no alignment constraint for parameter  <channel\\_output> , but when allocating memory, the  co  dimension of memory space of  <kernel>  must be 64 aligned; \n The difference between __bang_conv_partial and __bang_conv with bias version is: the parameter  <partial>  of __bang_conv_partial is a tensor with the same shape as the  <dst> ; and the parameter  <bias>  of __bang_conv is a vector whose length is the same with the numbers of channels of  <dst> ; \n <kernel\\_height> ,  <kernel\\_width> ,  <channel\\_input>  and  <channel\\_output>  must be greater than 0; \n <stride\\_width>  and  <stride\\_height>  must be in range [1, 1023]; \n <indilation\\_width> ,  <indilation\\_height> ,  <outdilation\\_width>  and  <outdilation\\_height>  must be in range [1, 1023], and 1 means no dilation; \n If  <indilation\\_height>  is used,  (<height> - ((<kernel\\_height> - 1) \\* <indilation\\_height> + 1)) / <stride\\_height> + 1  must be greater than 0; otherwise,  (<height> - <kernel\\_height>) / <stride\\_height> + 1  must be greater than 0; \n If  <indilation\\_width>  is used,  (<width> - ((<kernel\\_width> - 1) \\* <indilation\\_width> + 1)) / <stride\\_width> + 1  must be greater than 0; otherwise,  (<width> - <kernel\\_width>) / <stride\\_width> + 1  must be greater than 0; \n On target  (m)tp\\_322  ,  <kernel>  must be  int4 ,  int8\\_t  or  int16\\_t ; \n On target  (m)tp\\_322  , if use  <indilation\\_height>  ,  (<height> - ((<kernel\\_height> - 1) \\* <indilation\\_height> + 1)) / <stride\\_height> + 1  must be in the range  [1, 1024]  ; \n On target  (m)tp\\_322  , if use  <dilation\\_height>  ,  (<height> - ((<kernel\\_height> - 1) \\* <dilation\\_height> + 1)) / <stride\\_height> + 1  must be in the range  [1, 1024]  ; \n On target  (m)tp\\_322  , if neither  <dilation\\_height>  nor  <indilation\\_height>  are used,  (<height> - <kernel\\_height>) / <stride\\_height> + 1  must be in the range  [1, 1024]  ; \n <dst>  cannot be overlapped with  <src> ; \n <dst>  can be overlapped with  <partial> ; \n float ,  half , and  bfloat16\\_t  for  src  are not supported on  tp\\_322  and  tp\\_520 . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define IN_CHANNEL 128 \n define IN_HEIGHT 9 \n define IN_WIDTH 8 \n define FILTER_HEIGHT 2 \n define FILTER_WIDTH 3 \n define STRIDE_HEIGHT 4 \n define STRIDE_WIDTH 3 \n define OUT_CHANNEL 64 \n define POS 2 \n define DILATION_HEIGHT 4 \n define DILATION_WIDTH 2 \n define NEW_FILTER_HEIGHT ((FILTER_HEIGHT - 1) * DILATION_HEIGHT + 1) \n define NEW_FILTER_WIDTH ((FILTER_WIDTH - 1) * DILATION_WIDTH + 1) \n define OUT_HEIGHT ((((IN_HEIGHT) - (NEW_FILTER_HEIGHT)) / (STRIDE_HEIGHT)) + 1) \n define OUT_WIDTH ((((IN_WIDTH) - (NEW_FILTER_WIDTH)) / (STRIDE_WIDTH)) + 1) \n define OUT_DATA_NUM ((OUT_HEIGHT) * (OUT_WIDTH) * (OUT_CHANNEL)) \n define IN_DATA_NUM ((IN_HEIGHT) * (IN_WIDTH) * (IN_CHANNEL)) \n #define FILTER_DATA_NUM ((FILTER_HEIGHT) * (FILTER_WIDTH) *\\\n                        (IN_CHANNEL) * (OUT_CHANNEL)) \n __mlu_entry__ void ConvKernel(float *out_data, int16_t *in_data,\n                              int16_t *filter_data, float *partial_data) {\n  __nram__ float nram_out_data[OUT_DATA_NUM];\n  __nram__ int16_t nram_in_data[IN_DATA_NUM];\n  __nram__ float nram_partial_data[OUT_DATA_NUM];\n  __wram__ int16_t wram_filter[FILTER_DATA_NUM]; \n __memcpy(nram_in_data, in_data, IN_DATA_NUM * sizeof(int16_t), GDRAM2NRAM);\n  __memcpy(wram_filter, filter_data, FILTER_DATA_NUM * sizeof(int16_t), GDRAM2WRAM);\n  __memcpy(nram_partial_data, partial_data, OUT_DATA_NUM * sizeof(float),\n           GDRAM2NRAM); \n __bang_conv_partial(nram_out_data, nram_in_data, wram_filter,\n                      nram_partial_data, IN_CHANNEL, IN_HEIGHT, IN_WIDTH,\n                      FILTER_HEIGHT, FILTER_WIDTH, STRIDE_WIDTH, STRIDE_HEIGHT,\n                      OUT_CHANNEL, POS, DILATION_WIDTH, DILATION_HEIGHT);\n  __memcpy(out_data, nram_out_data, OUT_DATA_NUM * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.5. __bang_conv_partial_tf32 \n^^^^^^^^^^^^^^^\n void  __bang_conv_partial_tf32 (float * dst ,  const  float * src ,  const  float * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv_partial_tf32 (float * dst ,  const  float * src ,  const  float * kernel ,  const  float * partial , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n In  \\_\\_nram\\_\\_  address space, uses the four-dimensional convolution kernel  <kernel>[<channel\\_output>, <kernel\\_height>, <kernel\\_width>, <channel\\_input>]  to perform a partial convolution operation on the three-dimensional tensor  <src>[<height>, <width>, <channel\\_input>]  with an interactive step size of  [<stride\\_width>, <stride\\_height>] , then adds the three-dimensional tensor  <partial>[<dst\\_height>, <dst\\_width>, <channel\\_output>] , and stores the result in the three-dimensional tensor  <dst>[<dst\\_height>, <dst\\_width>, <channel\\_output>] . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor which has (NH_oW_oC_o) data layout.\n*  [in] src : The address of source tensor which has (NH_iW_iC_i) data layout.\n*  [in] kernel : The address of filter tensor which has (C_oH_kW_kC_i) data layout.\n*  [in] partial : The address of partial_sum tensor which has (NH_oW_oC_o) data layout.\n*  [in] channel\\_input : Number of input channels.\n*  [in] height : The height of source tensor.\n*  [in] width : The width of source tensor.\n*  [in] kernel\\_height : The height of filter tensor.\n*  [in] kernel\\_width : The width of filter tensor.\n*  [in] stride\\_width : The stride in W direction.\n*  [in] stride\\_height : The stride in H direction.\n*  [in] channel\\_output : Number of output channels.\n*  [in] indilation\\_width : Input dilation in W direction.\n*  [in] indilation\\_height : Input dilation in H direction.\n*  [in] outdilation\\_width : Output dilation in W direction.\n*  [in] outdilation\\_height : Output dilation in H direction. \n^^^^^^^^^^^^^^^\n Return *  void \n^^^^^^^^^^^^^^^\n Remark *  <src> ,  <dst>  and  <partial>  must point to  \\_\\_nram\\_\\_  address space;\n*  <kernel>  must point to  \\_\\_wram\\_\\_  address space;\n* The address of  <kernel>  must be 32-byte aligned;\n* The byte size of  <kernel>  must be 64-byte aligned; otherwise, the non-aligned part will be set to zero;\n* There is no alignment constraint for parameter  <channel\\_input> , but when allocating memory, (C_i) *  sizeof(typeof<kernel>)  must be 64-byte aligned;\n* There is no alignment constraint for parameter  <channel\\_output> , but when allocating memory, the  co  dimension of memory space of  <kernel>  must be 64 aligned;\n*  <kernel\\_height> ,  <kernel\\_width> ,  <channel\\_input>  and  <channel\\_output>  must be greater than 0;\n*  <stride\\_width>  and  <stride\\_height>  must be in range [1, 1023];\n*  <indilation\\_width> ,  <indilation\\_height> ,  <outdilation\\_width>  and  <outdilation\\_height>  must be in range [1, 1023], and 1 means no dilation;\n* If  <indilation\\_height>  is used,  (<height> - ((<kernel\\_height> - 1) \\* <indilation\\_height> + 1)) / <stride\\_height> + 1  must be greater than 0; otherwise,  (<height> - <kernel\\_height>) / <stride\\_height> + 1  must be greater than 0;\n* If  <indilation\\_width>  is used,  (<width> - ((<kernel\\_width> - 1) \\* <indilation\\_width> + 1)) / <stride\\_width> + 1  must be greater than 0; otherwise,  (<width> - <kernel\\_width>) / <stride\\_width> + 1  must be greater than 0;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <dst>  can be overlapped with  <partial> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define IN_CHANNEL 128 \n define IN_HEIGHT 9 \n define IN_WIDTH 8 \n define FILTER_HEIGHT 2 \n define FILTER_WIDTH 3 \n define STRIDE_HEIGHT 4 \n define STRIDE_WIDTH 3 \n define OUT_CHANNEL 64 \n define DILATION_HEIGHT 4 \n define DILATION_WIDTH 2 \n define NEW_FILTER_HEIGHT ((FILTER_HEIGHT - 1) * DILATION_HEIGHT + 1) \n define NEW_FILTER_WIDTH ((FILTER_WIDTH - 1) * DILATION_WIDTH + 1) \n define OUT_HEIGHT ((((IN_HEIGHT) - (NEW_FILTER_HEIGHT)) / (STRIDE_HEIGHT)) + 1) \n define OUT_WIDTH ((((IN_WIDTH) - (NEW_FILTER_WIDTH)) / (STRIDE_WIDTH)) + 1) \n define OUT_DATA_NUM ((OUT_HEIGHT) * (OUT_WIDTH) * (OUT_CHANNEL)) \n define IN_DATA_NUM ((IN_HEIGHT) * (IN_WIDTH) * (IN_CHANNEL)) \n define FILTER_DATA_NUM ((FILTER_HEIGHT) * (FILTER_WIDTH) * (IN_CHANNEL) * (OUT_CHANNEL)) \n __mlu_entry__ void ConvKernel(float *out_data, float *in_data,\n                              float *filter_data, float *partial_data) {\n  __nram__ float nram_out_data[OUT_DATA_NUM];\n  __nram__ float nram_in_data[IN_DATA_NUM];\n  __nram__ float nram_partial_data[OUT_DATA_NUM];\n  __wram__ float wram_filter[FILTER_DATA_NUM]; \n __memcpy(nram_in_data, in_data, IN_DATA_NUM * sizeof(float), GDRAM2NRAM);\n  __memcpy(wram_filter, filter_data, FILTER_DATA_NUM * sizeof(float), GDRAM2WRAM);\n  __memcpy(nram_partial_data, partial_data, OUT_DATA_NUM * sizeof(float),\n           GDRAM2NRAM); \n __bang_conv_partial_tf32(nram_out_data, nram_in_data, wram_filter,\n                           nram_partial_data, IN_CHANNEL, IN_HEIGHT, IN_WIDTH,\n                           FILTER_HEIGHT, FILTER_WIDTH, STRIDE_WIDTH, STRIDE_HEIGHT,\n                           OUT_CHANNEL, POS, DILATION_WIDTH, DILATION_HEIGHT);\n  __memcpy(out_data, nram_out_data, OUT_DATA_NUM * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.6. __bang_conv_sparse \n^^^^^^^^^^^^^^^\n void  __bang_conv_sparse (float * dst ,  const  float * src ,  const  float * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv_sparse (float * dst ,  const  half * src ,  const  half * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv_sparse (float * dst ,  const  int8_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_sparse (float * dst ,  const  int8_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_sparse (float * dst ,  const  int16_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_sparse (float * dst ,  const  int16_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_sparse (half * dst ,  const  int8_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_sparse (half * dst ,  const  int8_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_sparse (half * dst ,  const  int16_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_sparse (half * dst ,  const  int16_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_sparse (int16_t * dst ,  const  int8_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_sparse (int16_t * dst ,  const  int16_t * src ,  const  int8_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n void  __bang_conv_sparse (int16_t * dst ,  const  int16_t * src ,  const  int16_t * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , int  fix_position )   \n In  \\_\\_nram\\_\\_  address space, uses the four-dimensional convolution kernel  <kernel>[<channel\\_output>, <kernel\\_height>, <kernel\\_width>, <channel\\_input>]  to perform a convolution operation on the three-dimensional tensor  <src>[<height>, <width>, <channel\\_input>]  in sparse mode with an interactive step size of  [<stride\\_width>, <stride\\_height>] , and stores the result in the three-dimensional tensor  <dst>[<dst\\_height>, <dst\\_width>, <channel\\_output>] . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor which has (NH_oW_oC_o) data layout.\n*  [in] src : The address of source tensor which has (NH_iW_iC_i) data layout.\n*  [in] kernel : The address of filter tensor which has (C_oH_kW_kC_i) data layout.\n*  [in] channel\\_input : Number of input channels.\n*  [in] height : The height of source tensor.\n*  [in] width : The width of source tensor.\n*  [in] kernel\\_height : The height of filter tensor.\n*  [in] kernel\\_width : The width of filter tensor.\n*  [in] stride\\_width : The stride in W direction.\n*  [in] stride\\_height : The stride in H direction.\n*  [in] channel\\_output : Number of output channels.\n*  [in] fix\\_position : Sum of scale factor of  <src>  and  <kernel> . \n^^^^^^^^^^^^^^^\n Return *  void \n^^^^^^^^^^^^^^^\n Remark * In sparse mode,  <kernel>  is in form of 96-byte structure with 64-byte data and 32-byte index.  <kernel>  can either be generated online by __bang_ssparse_filter_union related function or be prepared offline by programmers. \n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <kernel>  must point to  \\_\\_wram\\_\\_  address space;\n*  <fix\\_position>  is the sum of the scale factor of  <src>  and  <kernel> , and must be in the range  [-127, 127] ;\n* The address of  <kernel>  must be 32-byte aligned;\n* The byte size of  <kernel>  must be 64-byte aligned; otherwise, the non-aligned part of  <kernel>  will be zero; \n There is no alignment constraint for parameter  <channel\\_input> , but when allocating memory, the  ci  dimension of the memory space of  <kernel>  must satisfy the following alignment constraints: \n If the types of  <src>  and  <kernel>  are both floating point: \n If  sizeof(typeof<src>) / sizeof(typeof<kernel>) == 2 , (C_i) *  sizeof(typeof<kernel>)  must be 32-byte aligned; \n Otherwise, (C_i) *  sizeof(typeof<kernel>)  must be 64-byte aligned; \n If the types of  <src>  and  <kernel>  are both integer: \n If  --wram-align 64  or  #pragma bang walign(64) \n  There is no alignment constraint for parameter  <channel\\_output> , but when allocating memory, the  co  dimension of memory space of  <kernel>  must be 64 aligned; \n The space size of  <bias>  is identical to  <channel\\_output> ; \n <kernel\\_height> ,  <kernel\\_width> ,  <channel\\_input>  and  <channel\\_output>  must be greater than 0; \n <stride\\_width>  and  <stride\\_height>  must be in range [1, 1023]; \n (<height> - <kernel\\_height>) / <stride\\_height> + 1  must be greater than 0; \n (<width> - <kernel\\_width>) / <stride\\_width> + 1  must be greater than 0; \n <dst>  cannot be overlapped with  <src> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include \"bang.h\" \n define IN_CHANNEL 128 \n define IN_HEIGHT 2 \n define IN_WIDTH 2 \n define FILTER_HEIGHT 1 \n define FILTER_WIDTH 1 \n define STRIDE_HEIGHT 1 \n define STRIDE_WIDTH 1 \n define OUT_CHANNEL 64 \n define LT_NUM 16 \n define ESP 1e-7 \n define OUT_HEIGHT ((((IN_HEIGHT) - (FILTER_HEIGHT)) / (STRIDE_HEIGHT)) + 1) \n define OUT_WIDTH ((((IN_WIDTH) - (FILTER_WIDTH)) / (STRIDE_WIDTH)) + 1) \n define OUT_DATA_NUM ((OUT_HEIGHT) * (OUT_WIDTH) * (OUT_CHANNEL)) \n define IN_DATA_NUM ((IN_HEIGHT) * (IN_WIDTH) * (IN_CHANNEL)) \n define FILTER_DATA_NUM (FILTER_HEIGHT * FILTER_WIDTH * IN_CHANNEL * OUT_CHANNEL) \n define FILTER_WITH_INDEX_DATA_NUM (FILTER_DATA_NUM / 128 * 96) \n __mlu_global__ void kernel(float* dst, int16_t* src, int16_t* filter) {\n  __nram__ float nram_out_data[OUT_DATA_NUM];\n  __nram__ int16_t nram_in_data[IN_DATA_NUM];\n  __nram__ int16_t nram_filter[FILTER_DATA_NUM];\n  __nram__ int16_t nram_filter_with_index[FILTER_WITH_INDEX_DATA_NUM];\n  __wram__ int16_t wram_filter_with_index[FILTER_WITH_INDEX_DATA_NUM]; \n __memcpy(nram_in_data, src, IN_DATA_NUM * sizeof(int16_t), GDRAM2NRAM);\n  __memcpy(nram_filter, filter, FILTER_DATA_NUM * sizeof(int16_t), GDRAM2NRAM);\n  __bang_ssparse_filter_union(nram_filter_with_index, nram_filter,\n                              IN_CHANNEL * sizeof(int16_t), FILTER_HEIGHT,\n                              FILTER_WIDTH, OUT_CHANNEL);\n  __memcpy(wram_filter_with_index, nram_filter_with_index,\n           FILTER_WITH_INDEX_DATA_NUM * sizeof(int16_t), NRAM2WRAM);\n  __bang_conv_sparse(nram_out_data, nram_in_data, wram_filter_with_index,\n                     IN_CHANNEL, IN_HEIGHT, IN_WIDTH, FILTER_HEIGHT,\n                     FILTER_WIDTH, STRIDE_WIDTH, STRIDE_HEIGHT, OUT_CHANNEL, 0);\n  __memcpy(dst, nram_out_data, OUT_DATA_NUM * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.7. __bang_conv_tf32 \n^^^^^^^^^^^^^^^\n void  __bang_conv_tf32 (float * dst ,  const  float * src ,  const  float * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output )   \n void  __bang_conv_tf32 (float * dst ,  const  float * src ,  const  float * kernel , unsigned int  channel_input , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  channel_output , unsigned int  indilation_width , unsigned int  indilation_height , unsigned int  outdilation_width , unsigned int  outdilation_height )   \n In  \\_\\_nram\\_\\_  address space, uses the four-dimensional convolution kernel  <kernel>[<channel\\_output>, <kernel\\_height>, <kernel\\_width>, <channel\\_input>]  to perform a convolution operation on the three-dimensional tensor  <src>[<height>, <width>, <channel\\_input>]  with an interactive step size of  [<stride\\_width>, <stride\\_height>] , and stores the result in the three-dimensional tensor  <dst>[<dst\\_height>, <dst\\_width>, <channel\\_output>] . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor which has (NH_oW_oC_o) data layout.\n*  [in] src : The address of source tensor which has (NH_iW_iC_i) data layout.\n*  [in] kernel : The address of filter tensor which has (C_oH_kW_kC_i) data layout.\n*  [in] channel\\_input : Number of input channels.\n*  [in] height : The height of source tensor.\n*  [in] width : The width of source tensor.\n*  [in] kernel\\_height : The height of filter tensor.\n*  [in] kernel\\_width : The width of filter tensor.\n*  [in] stride\\_width : The stride in W direction.\n*  [in] stride\\_height : The stride in H direction.\n*  [in] channel\\_output : Number of output channels.\n*  [in] indilation\\_width : Input dilation in W direction.\n*  [in] indilation\\_height : Input dilation in H direction.\n*  [in] outdilation\\_width : Output dilation in W direction.\n*  [in] outdilation\\_height : Output dilation in H direction. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src> ,  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <kernel>  must point to  \\_\\_wram\\_\\_  address space;\n* The address of  <kernel>  must be 32-byte aligned;\n* The byte size of  <kernel>  must be 64-byte aligned; otherwise, the non-aligned part will be set to zero;\n* There is no alignment constraint for parameter  <channel\\_input> , but when allocating memory, (C_i) *  sizeof(typeof<kernel>)  must be 64-byte aligned;\n* There is no alignment constraint for parameter  <channel\\_output> , but when allocating memory, the  co  dimension of memory space of  <kernel>  must be 64 aligned;\n*  <kernel\\_height> ,  <kernel\\_width> ,  <channel\\_input>  and  <channel\\_output>  must be greater than 0;\n*  <stride\\_width>  and  <stride\\_height>  must be in range [1, 1023];\n*  <indilation\\_width> ,  <indilation\\_height> ,  <outdilation\\_width>  and  <outdilation\\_height>  must be in range [1, 1023], and 1 means no dilation;\n* If  <indilation\\_height>  is used,  (<height> - ((<kernel\\_height> - 1) \\* <indilation\\_height> + 1)) / <stride\\_height> + 1  must be greater than 0; otherwise,  (<height> - <kernel\\_height>) / <stride\\_height> + 1  must be greater than 0;\n* If  <indilation\\_width>  is used,  (<width> - ((<kernel\\_width> - 1) \\* <indilation\\_width> + 1)) / <stride\\_width> + 1  must be greater than 0; otherwise,  (<width> - <kernel\\_width>) / <stride\\_width> + 1  must be greater than 0;\n*  <dst>  cannot be overlapped with  <src> . \n ^^^^^^^^^^^^^^^\n Example * See the example of __bang_conv_partial_tf32 for more detail. \n"
  },
  {
    "content": "\n 3.12.8. __bang_maxpool \n^^^^^^^^^^^^^^^\n void  __bang_maxpool (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width )   \n void  __bang_maxpool (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height )   \n void  __bang_maxpool (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height )   \n void  __bang_maxpool (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_maxpool (float * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_maxpool (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n"
  },
  {
    "content": "\n 3.12.9. __bang_maxpool_bp \n^^^^^^^^^^^^^^^\n void  __bang_maxpool_bp (half * dst ,  const  half * src , short * mask , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , mluPoolBPOverlap  overlap  = OVERLAP_ACC)   \n void  __bang_maxpool_bp (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned short * mask , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , mluPoolBPOverlap  overlap  = OVERLAP_ACC)   \n void  __bang_maxpool_bp (float * dst ,  const  float * src , int * mask , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , mluPoolBPOverlap  overlap  = OVERLAP_ACC)   \n Applies maxpooling backward propagation operation on  <src>  [ <height> ,  <width> ,  <channel> ], a three-dimensional tensor, with sliding window [ <kernel\\_height> ,  <kernel\\_width> ] and stride [ <stride\\_width> ,  <stride\\_height> ], and selects the index with the maximum value.  <overlap>  indicates the type of overlap options.  <overlap>  is assigned to an enumerated type called  mluPoolBPOverlap  that contains 2 enumerators listed in the table below. When window is slid in certain direction (H or W direction), if the left elements number doesn\u2019t match the window size, these elements will be discarded. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor whose data layout is HWC.\n*  [in] src : The address of source tensor whose data layout is HWC.\n*  [in] mask : The index of the maximum value inside a kernel, and the tensor data layout is HWC.\n*  [in] channel : Input channel.\n*  [in] height : The height of output feature map.\n*  [in] width : The width of output feature map.\n*  [in] kernel\\_height : The height of kernel.\n*  [in] kernel\\_width : The width of kernel.\n*  [in] stride\\_width : Stride of sliding window in W direction.\n*  [in] stride\\_height : Stride of sliding window in H direction.\n*  [in] overlap : The type of overlap options. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src> ,  <mask>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* The address of  <src> ,  <mask>  and  <dst>  must be 64-byte aligned on  (m)tp\\_2xx ;\n* When the data type of  <src>  and  <dst>  is  half  or  bfloat16\\_t , the data type of  <mask>  must be  short . When the data type of  <src>  and  <dst>  are float, the data type of  <mask>  must be  int ;\n*  <dst>  cannot be overlapped with  <src> ;\n* The default  mluPoolBPOverlap  option is  OVERLAP\\_ACC ;\n*  [input\\_height]  and  [input\\_width]  of  <src>  must be greater than 0;\n*  <channel> ,  <height> ,  <width> ,  <kernel\\_height> ,  <kernel\\_width> ,  <stride\\_height>  and  <stride\\_width>  must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16}). \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void PoolMaxBpKernel(half* output, half* input, int16_t* mask,\n                                   int channels, int out_height,\n                                   int out_width, int kernel_height,\n                                   int kernel_width, int stride_width,\n                                   int stride_height) {\n  __nram__ half a_tmp[INPUT_COUNT];\n  __nram__ half b_tmp[OUTPUT_COUNT];\n  __nram__ int16_t c_tmp[INPUT_COUNT]; \n __memcpy(b_tmp, output, OUTPUT_COUNT * sizeof(half), GDRAM2NRAM);\n  __memcpy(a_tmp, input, INPUT_COUNT * sizeof(half), GDRAM2NRAM);\n  __memcpy(c_tmp, mask, INPUT_COUNT * sizeof(int16_t), GDRAM2NRAM); \n __bang_maxpool_bp(b_tmp, a_tmp, c_tmp, channels, out_height, out_width,\n                    kernel_height, kernel_width, stride_width, stride_height); \n __memcpy(output, b_tmp, OUTPUT_COUNT * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.10. __bang_maxpool_index \n^^^^^^^^^^^^^^^\n void  __bang_maxpool_index (unsigned short * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width )   \n void  __bang_maxpool_index (unsigned short * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height )   \n void  __bang_maxpool_index (unsigned short * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height )   \n void  __bang_maxpool_index (unsigned short * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_maxpool_index (unsigned int * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_maxpool_index (unsigned short * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_maxpool_index (unsigned int * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height )   \n Applies maxpooling forward operation with index on  <src>  [ <height> ,  <width> ,  <channel> ], a three-dimensional tensor, with sliding window [ <kernel\\_height> ,  <kernel\\_width> ] and stride [ <stride\\_width> ,  <stride\\_height> ], and selects the index of the maximum value in each window. When the data type of  <src>  is  half  or  bfloat16\\_t , the data type of  <dst>  is  unsigned short . When the data type of  <src>  is  float , the data type of  <dst>  is  unsigned int . When window is slid in certain direction (H or W direction), if the left elements number doesn\u2019t match the window size, these elements will be discarded.If there are multiple maximum values, the index is the position of the first maximum value. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor whose data layout is HWC.\n*  [in] src : The address of source tensor whose data layout is HWC.\n*  [in] channel : Input channel.\n*  [in] height : The height of input feature map.\n*  [in] width : The width of input feature map.\n*  [in] kernel\\_height : The height of kernel.\n*  [in] kernel\\_width : The width of kernel.\n*  [in] stride\\_width : Stride of sliding window in W direction.\n*  [in] stride\\_height : Stride of sliding window in H direction.\n*  [in] in\\_dh : Dilation in H direction of input.\n*  [in] in\\_dw : Dilation in W direction of input.\n*  [in] out\\_dh : Dilation in H direction of output.\n*  [in] out\\_dw : Dilation in W direction of output. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* The function with dilation is supported on  (m)tp\\_3xx  or higher;\n*  <dst>  cannot be overlapped with  <src> ;\n* In the function without stride,  <stride\\_width>  equals  <kernel\\_width>  and  <stride\\_height>  equals  <kernel\\_height> ;\n*  <channel> ,  <height> ,  <width> ,  <kernel\\_height> ,  <kernel\\_width> ,  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  must be greater than 0;\n*  <stride\\_height>  and  <stride\\_width>  must be greater than 0 if specified;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  is 1 which means no dilation. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define CHANNELS 64 \n define HEIGHT 9 \n define WIDTH 12 \n define KERNEL_HEIGHT 5 \n define KERNEL_WIDTH 4 \n define BOTTOM_DATA_COUNT ((CHANNELS) * (WIDTH) * (HEIGHT)) \n #define TOP_DATA_COUNT \\\n  ((CHANNELS) * (HEIGHT / KERNEL_HEIGHT) * (WIDTH / KERNEL_WIDTH)) \n __mlu_entry__ void MaxPoolIndexKernel(half* bottom_data, int16_t* top_data,\n                                      int channels, int height, int width,\n                                      int pooled_height, int pooled_width) {\n  __nram__ half a_tmp[BOTTOM_DATA_COUNT];\n  __nram__ uint16_t b_tmp[TOP_DATA_COUNT];\n  __memcpy(a_tmp, bottom_data, BOTTOM_DATA_COUNT * sizeof(half), GDRAM2NRAM);\n  __bang_maxpool_index(b_tmp, a_tmp, CHANNELS, HEIGHT, WIDTH,\n                       KERNEL_HEIGHT, KERNEL_WIDTH);\n  __memcpy(top_data, b_tmp, TOP_DATA_COUNT * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.11. __bang_maxpool_value_index \n^^^^^^^^^^^^^^^\n void  __bang_maxpool_value_index (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride )   \n void  __bang_maxpool_value_index (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride )   \n void  __bang_maxpool_value_index (float * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride )   \n void  __bang_maxpool_value_index (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_maxpool_value_index (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_maxpool_value_index (float * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n Performs maximum pooling operation with the kernel  [kernel\\_height, kernel\\_width]  and the stride  [stride\\_width, stride\\_height]  on the tensor  <src>[channel, height, width]  in  \\_\\_nram\\_\\_  address space, then stores the maximum value and the corresponding index to  <dst> . When the data type of  <src>  is  half , the data type of  value  in  <dst>  is  half  and the data type of  index  in  <dst>  is  unsigned short . When the data type of  <src>  is  float , the data type of  value  in  <dst>  is  float  and the data type of  index  in  <dst>  is  unsigned int . When the kernel moves to the edge of input  <width>  and the kernel overflows, it will automatically adapt to the size of  <kernel\\_width> , so as to ensure that useless input is not included.If there are multiple maximum values, the index is the position of the first maximum value. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor whose data layout is HWC.\n*  [in] src : The address of source tensor whose data layout is HWC.\n*  [in] channel : The input channel.\n*  [in] height : The height of input source.\n*  [in] width : The width of input source.\n*  [in] kernel\\_height : The height of kernel.\n*  [in] kernel\\_width : The width of kernel.\n*  [in] stride\\_width : The stride in W direction.\n*  [in] stride\\_height : The stride in H direction.\n*  [in] value\\_index\\_stride : The offset from the beginning of data value to index value in bytes.\n*  [in] in\\_dh : Dilation in H direction of input.\n*  [in] in\\_dw : Dilation in W direction of input.\n*  [in] out\\_dh : Dilation in H direction of output.\n*  [in] out\\_dw : Dilation in W direction of output. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  and  <src>  must point to  \\_\\_nram\\_\\_  address space;\n* For the output tensor  <dst>[output\\_channel, output\\_height, output\\_width] ,  [output\\_channel] = <channel> , and  [output\\_height, output\\_width]  are obtained by deducing from  [height, width] ,  [kernel\\_height, kernel\\_width]  and  [stride\\_width, stride\\_height] ;\n* For the value part of  <dst> , when  <value\\_index\\_stride> > 0 , the address operands  <dst>  can be overlapped with  <src> ;\n*  <channel> ,  <height> ,  <width> ,  <kernel\\_height> ,  <kernel\\_width> ,  <stride\\_height> ,  <stride\\_width> ,  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  is 1 which means no dilation.\n*  bfloat16\\_t  is supported on  (m)tp\\_5xx  or higher. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_NUM 64 \n __mlu_entry__ void kernel(half *dst, half *src, float *dst_f,\n                          float *src_f, int channel,\n                          int height, int width,\n                          int kernel_height, int kernel_width,\n                          int stride_width, int stride_height,\n                          int value_index_stride,\n                          int in_dh, int in_dw,\n                          int out_dh, int out_dw) {\n  __nram__ half svc_dst[DATA_NUM];\n  __nram__ half svc_src[DATA_NUM];\n  int datasize = DATA_NUM * sizeof(half);\n  __memcpy(svc_src, src, datasize, GDRAM2NRAM);\n  __bang_maxpool_value_index(svc_dst, svc_src, channel, height,\n                             width, kernel_height, kernel_width,\n                             stride_width, stride_height,\n                             value_index_stride,\n                             in_dh, in_dw, out_dh, out_dw);\n  __memcpy(dst, svc_dst, datasize, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.12. __bang_minpool \n^^^^^^^^^^^^^^^\n void  __bang_minpool (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width )   \n void  __bang_minpool (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height )   \n void  __bang_minpool (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height )   \n void  __bang_minpool (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_minpool (float * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_minpool (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_minpool (float * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height )   \n Applies minpooling forward operation on  <src>``[``<height> ,  <width> ,  <channel> ], a three-dimensional tensor, with sliding window [ <kernel\\_height> ,  <kernel\\_width> ] and stride [ <stride\\_width> ,  <stride\\_height> ], and selects the minimum value in each window. When window is slid in certain direction (H or W direction), if the left elements number doesn\u2019t match the window size, these elements will be discarded.If there are multiple minimum values, the result is the first minimum value. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor whose data layout is HWC.\n*  [in] src : The address of source tensor whose data layout is HWC.\n*  [in] channel : Input channel.\n*  [in] height : The height of input feature map.\n*  [in] width : The width of input feature map.\n*  [in] kernel\\_height : The height of sliding window.\n*  [in] kernel\\_width : The width of sliding window.\n*  [in] stride\\_width : Stride of sliding window in W direction.\n*  [in] stride\\_height : Stride of sliding window in H direction.\n*  [in] in\\_dh : Dilation in H direction of input.\n*  [in] in\\_dw : Dilation in W direction of input.\n*  [in] out\\_dh : Dilation in H direction of output.\n*  [in] out\\_dw : Dilation in W direction of output. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* The function with dilation is supported on  (m)tp\\_3xx  or higher;\n*  <dst>  cannot be overlapped with  <src> ;\n* In the function without stride,  <stride\\_width>  equals  <kernel\\_width>  and  <stride\\_height>  equals  <kernel\\_height> ;\n*  <channel> ,  <height> ,  <width> ,  <kernel\\_height> ,  <kernel\\_width> ,  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  must be greater than 0;\n*  <stride\\_height>  and  <stride\\_width>  must be greater than 0 if specified;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  is 1 which means no dilation. "
  },
  {
    "content": "\n 3.12.13. __bang_minpool_index \n^^^^^^^^^^^^^^^\n void  __bang_minpool_index (unsigned short * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width )   \n void  __bang_minpool_index (unsigned short * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height )   \n void  __bang_minpool_index (unsigned short * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height )   \n void  __bang_minpool_index (unsigned short * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_minpool_index (unsigned int * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_minpool_index (unsigned short * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_minpool_index (unsigned int * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height )   \n Applies minpooling forward operation with index on  <src>  [ <height> ,  <width> ,  <channel> ], a three-dimensional tensor, with sliding window [ <kernel\\_height> ,  <kernel\\_width> ] and stride [ <stride\\_width> ,  <stride\\_height> ], and selects the index with the minimum value in each window. When the data type of  <src>  is  half  or  bfloat16\\_t , the data type of  <dst>  is  unsigned short . When the data type of  <src>  is  float , the data type of  <dst>  is  unsigned int . When window is slid in certain direction (H or W direction), if the left elements number doesn\u2019t match the window size, these elements will be discarded.If there are multiple minimum values, the index is the position of the first minimum value. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor whose data layout is HWC.\n*  [in] src : The address of source tensor whose data layout is HWC.\n*  [in] channel : Input channel.\n*  [in] height : The height of input feature map.\n*  [in] width : The width of input feature map.\n*  [in] kernel\\_height : The height of sliding window.\n*  [in] kernel\\_width : The width of sliding window.\n*  [in] stride\\_width : Stride of sliding window in W direction.\n*  [in] stride\\_height : Stride of sliding window in H direction.\n*  [in] in\\_dh : Dilation in H direction of input.\n*  [in] in\\_dw : Dilation in W direction of input.\n*  [in] out\\_dh : Dilation in H direction of output.\n*  [in] out\\_dw : Dilation in W direction of output. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* The function with dilation is supported on  (m)tp\\_3xx  or higher;\n*  <dst>  cannot be overlapped with  <src> ;\n* In the function without stride,  <stride\\_width>  equals  <kernel\\_width>  and  <stride\\_height>  equals  <kernel\\_height> ;\n*  <channel> ,  <height> ,  <width> ,  <kernel\\_height> ,  <kernel\\_width> ,  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  must be greater than 0;\n*  <stride\\_height>  and  <stride\\_width>  must be greater than 0 if specified;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  is 1 which means no dilation. "
  },
  {
    "content": "\n 3.12.14. __bang_minpool_value_index \n^^^^^^^^^^^^^^^\n void  __bang_minpool_value_index (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride )   \n void  __bang_minpool_value_index (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride )   \n void  __bang_minpool_value_index (float * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride )   \n void  __bang_minpool_value_index (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_minpool_value_index (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_minpool_value_index (float * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n Performs minimum pooling operation with the kernel [ <kernel\\_height> ,  <kernel\\_width> ] and the stride [ <stride\\_width> ,  <stride\\_height> ] on the tensor  <src>``[``<channel> ,  <height> ,  <width> ] in  \\_\\_nram\\_\\_  address space, and stores the minimum value and the corresponding index to  <dst> . When the data type of  <src>  is  half  or  bfloat16\\_t , the data type of  value  in  <dst>  is  half  and the data type of  index  in  <dst>  is  unsigned short . When the data type of  <src>  is  float , the data type of  value  in  <dst>  is  float  and the data type of  index  in  <dst>  is  unsigned int . When the kernel moves to the edge of input  <width>  and the kernel overflows, it will automatically adapt to the size of  <kernel\\_width> , so as to ensure that useless input is not included.If there are multiple minimum values, the index is the position of the first minimum value. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor whose data layout is HWC.\n*  [in] src : The address of source tensor whose data layout is HWC.\n*  [in] channel : The input channel.\n*  [in] height : The height of input source.\n*  [in] width : The width of input source.\n*  [in] kernel\\_height : The height of kernel.\n*  [in] kernel\\_width : The width of kernel.\n*  [in] stride\\_width : The stride in W direction.\n*  [in] stride\\_height : The stride in H direction.\n*  [in] value\\_index\\_stride : The offset from the beginning of data value to index value in bytes.\n*  [in] in\\_dh : Dilation in H direction of input.\n*  [in] in\\_dw : Dilation in W direction of input.\n*  [in] out\\_dh : Dilation in H direction of output.\n*  [in] out\\_dw : Dilation in W direction of output. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  and  <src>  must point to  \\_\\_nram\\_\\_  address space;\n* For the output tensor  <dst>[output\\_channel, output\\_height, output\\_width] ,  [output\\_channel] = <channel> , and  [output\\_height, output\\_width]  are obtained by deducing from  [height, width] ,  [kernel\\_height, kernel\\_width]  and  [stride\\_width, stride\\_height] ;\n* For the value part of  <dst> , when  <value\\_index\\_stride> > 0 , the address operands  <dst>  can be overlapped with  <src> ;\n*  <channel> ,  <height> ,  <width> ,  <kernel\\_height> ,  <kernel\\_width> ,  <stride\\_height> ,  <stride\\_width> ,  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  is 1 which means no dilation.\n*  bfloat16\\_t  is supported on  (m)tp\\_5xx  or higher. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_NUM 64 \n __mlu_entry__ void kernel(half *dst, half *src, float *dst_f, float *src_f,\n                          int channel, int height, int width, int kernel_height,\n                          int kernel_width, int stride_width, int stride_height,\n                          int value_index_stride, int in_dh, int in_dw,\n                          int out_dh, int out_dw);\n  int datasize = DATA_NUM * sizeof(half);\n  __nram__ half svc_dst[DATA_NUM];\n  __nram__ half svc_src[DATA_NUM];\n  __memcpy(svc_src, src, datasize, GDRAM2NRAM);\n  __bang_minpool_value_index(svc_dst, svc_src, channel, height, width,\n                             kernel_height, kernel_width, stride_width,\n                             stride_height, value_index_stride,\n                             in_dh, in_dw, out_dh, out_dw);\n  __memcpy(dst, svc_dst, datasize, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.15. __bang_mlp \n^^^^^^^^^^^^^^^\n void  __bang_mlp (half * dst ,  const  int4x2_t * src ,  const  int4x2_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int4x2_t * src ,  const  int8_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int4x2_t * src ,  const  int16_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int8_t * src ,  const  int4x2_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int8_t * src ,  const  int8_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int8_t * src ,  const  int16_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int16_t * src ,  const  int4x2_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int16_t * src ,  const  int8_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int16_t * src ,  const  int16_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int4x2_t * src ,  const  int4x2_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int4x2_t * src ,  const  int8_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int4x2_t * src ,  const  int16_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int8_t * src ,  const  int4x2_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int8_t * src ,  const  int8_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int8_t * src ,  const  int16_t * filter , int  height , int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int16_t * src ,  const  int4x2_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int16_t * src ,  const  int8_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int16_t * src ,  const  int16_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  half * src ,  const  half * filter , int  height , int  width )   \n void  __bang_mlp (float * dst ,  const  float * src ,  const  float * filter , int  height , int  width )   \n void  __bang_mlp (float * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * filter , int  height , int  width )   \n void  __bang_mlp (int16_t * dst ,  const  int8_t * src ,  const  int8_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (int16_t * dst ,  const  int16_t * src ,  const  int8_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (int16_t * dst ,  const  int16_t * src ,  const  int16_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int4x2_t * src ,  const  half * bias ,  const  int4x2_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int4x2_t * src ,  const  half * bias ,  const  int8_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int4x2_t * src ,  const  half * bias ,  const  int16_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int8_t * src ,  const  half * bias ,  const  int4x2_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int8_t * src ,  const  half * bias ,  const  int8_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int8_t * src ,  const  half * bias ,  const  int16_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int16_t * src ,  const  half * bias ,  const  int4x2_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int16_t * src ,  const  half * bias ,  const  int8_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (half * dst ,  const  int16_t * src ,  const  half * bias ,  const  int16_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int4x2_t * src ,  const  float * bias ,  const  int4x2_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int4x2_t * src ,  const  float * bias ,  const  int8_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int4x2_t * src ,  const  float * bias ,  const  int16_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int8_t * src ,  const  float * bias ,  const  int4x2_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int8_t * src ,  const  float * bias ,  const  int8_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int16_t * src ,  const  float * bias ,  const  int4x2_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int16_t * src ,  const  float * bias ,  const  int8_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (float * dst ,  const  int16_t * src ,  const  float * bias ,  const  int16_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (int16_t * dst ,  const  int8_t * src ,  const  int16_t * bias ,  const  int8_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (int16_t * dst ,  const  int16_t * src ,  const  int16_t * bias ,  const  int8_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n void  __bang_mlp (int16_t * dst ,  const  int16_t * src ,  const  int16_t * bias ,  const  int16_t * filter , unsigned int  height , unsigned int  width , int  fix_position )   \n Applies multilayer perception operation. \n For version with  <bias> : (  =   \\times   +  ). \n For version without  <bias> : (  =   \\times  ). \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] bias : The address of bias vector.\n*  [in] filter : The address of filter matrix which has row-major data layout.\n*  [in] height : The height of  .\n*  [in] width : The width of  .\n*  [in] fix\\_position : Sum of scale factor of  <src>  and  <kernel> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst> ,  <src>  and  <bias>  must point to  \\_\\_nram\\_\\_  address space;\n*  <filter>  must point to  \\_\\_wram\\_\\_  address space;\n* The matrix  <filter>  must be reshaped either on host or on device with  \\_\\_bang\\_reshape() ;\n*  <fix\\_position>  is the sum of the scale factor of  <src>  and  <filter> ;\n*  <fix\\_position>  must be in the range  [-127, 127] ;\n* The address of  <dst> ,  <src>  and  <bias>  must be 64-byte aligned on  (m)tp\\_2xx ;\n* The address of  <filter>  must be 32-byte aligned;\n*  <height>  must be divisible by 64 on  (m)tp\\_2xx ;\n*  <width> \\* sizeof(typeof<src>)  must be 64-byte aligned on  (m)tp\\_2xx ; \n On  (m)tp\\_3xx  and higher,  width  dimension space of  <filter>  must satisfy the following alignment constraints: \n If the types of  <src>  and  <filter>  are both floating point: \n If  sizeof(typeof<src>) / sizeof(typeof<filter>) == 2 ,  width \\* sizeof(typeof<filter>)  must be 32-byte aligned; \n Otherwise,  width \\* sizeof(typeof<filter>)  must be 64-byte aligned; \n If the types of  <src>  and  <filter>  are both integer: \n If  --wram-align 64  or  #pragma bang walign(64) ,  width \\* sizeof(typeof<filter>)  must be 64-byte aligned; \n On  (m)tp\\_3xx  and higher, there is no alignment constraint for parameter  <height> , but when allocating memory, the  height  dimension of memory space of  <filter>  must be 64 aligned; \n <width>  and  <height>  must be greater than 0; \n If have  <bias> , the data type of  <bias>  must be same with  <dst> ; \n <dst>  cannot be overlapped with  <src> ; \n <dst>  cannot be overlapped with  <bias> . \nExample \n```\n #include  \n #define HEIGHT 64\n #define WIDTH 64\n #define POS 0 \n __mlu_entry__ void MlpKernel(half* out_data, int16_t* in_data,\n                              int16_t* filter_data, half* bias_data,\n                              int height, int width, int pos) {\n  __nram__ half nram_out_data[HEIGHT];\n  __nram__ half nram_bias_data[HEIGHT];\n  __nram__ int16_t nram_in_data[WIDTH];\n  __wram__ int16_t wram_filter[HEIGHT * WIDTH];\n  __memcpy(nram_in_data, in_data, WIDTH * sizeof(int16_t), GDRAM2NRAM);\n  __memcpy(nram_bias_data, bias_data, HEIGHT * sizeof(half), GDRAM2NRAM);\n  __memcpy(wram_filter, filter_data, HEIGHT * WIDTH * sizeof(int16_t),\n           GDRAM2WRAM);\n  __bang_mlp(nram_out_data, nram_in_data, nram_bias_data, wram_filter,\n             HEIGHT, WIDTH, POS);\n  __memcpy(out_data, nram_out_data, HEIGHT * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.16. __bang_nan_maxpool \n^^^^^^^^^^^^^^^\n void  __bang_nan_maxpool (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_nan_maxpool (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_nan_maxpool (float * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n Applies maxpooling forward operation on  <src>  [ <height> ,  <width> ,  <channel> ], a three-dimensional tensor with sliding window [ <kernel\\_height> ,  <kernel\\_width> ] and stride [ <stride\\_width> ,  <stride\\_height> ], and selects the maximum value in each window. When window is slid in certain direction (H or W direction), if the left elements number doesn\u2019t match the window size, these elements will be discarded. If one of the elements being compared is a NaN, returns the element. If there are multiple maximum values, the result is the first maximum value. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor. And the tensor data layout is HWC.\n*  [in] src : The address of source tensor. And the tensor data layout is HWC.\n*  [in] channel : Input channel.\n*  [in] height : The height of input feature map.\n*  [in] width : The width of input feature map.\n*  [in] kernel\\_height : The height of sliding window.\n*  [in] kernel\\_width : The width of sliding window.\n*  [in] stride\\_width : Stride of sliding window in W direction.\n*  [in] stride\\_height : Stride of sliding window in H direction.\n*  [in] in\\_dh : Dilation in H direction of input.\n*  [in] in\\_dw : Dilation in W direction of input.\n*  [in] out\\_dh : Dilation in H direction of output.\n*  [in] out\\_dw : Dilation in W direction of output. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <channel> ,  <height> ,  <width> ,  <kernel\\_height> ,  <kernel\\_width> ,  <stride\\_height> ,  <stride\\_width> ,  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  is 1 which means no dilation. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define CHANNELS 64 \n define HEIGHT 4 \n define WIDTH 4 \n define KERNEL_HEIGHT 2 \n define KERNEL_WIDTH 2 \n define BOTTOM_DATA_COUNT ((CHANNELS) * (WIDTH) * (HEIGHT)) \n #define TOP_DATA_COUNT \\\n  ((CHANNELS) * (HEIGHT / KERNEL_HEIGHT) * (WIDTH / KERNEL_WIDTH)) \n __mlu_entry__ void maxPoolingKernel(half* bottom_data, half* top_data,\n                                    int channels, int height, int width,\n                                    int pooled_height, int pooled_width) {\n  __nram__ half a_tmp[BOTTOM_DATA_COUNT];\n  __nram__ half b_tmp[TOP_DATA_COUNT];\n  __memcpy(a_tmp, bottom_data, BOTTOM_DATA_COUNT * sizeof(half), GDRAM2NRAM);\n  __bang_nan_maxpool(b_tmp, a_tmp, CHANNELS, HEIGHT, WIDTH, KERNEL_HEIGHT, KERNEL_WIDTH);\n  __memcpy(top_data, b_tmp, TOP_DATA_COUNT * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.17. __bang_nan_maxpool_index \n^^^^^^^^^^^^^^^\n void  __bang_nan_maxpool_index (unsigned short * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_nan_maxpool_index (unsigned short * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_nan_maxpool_index (unsigned int * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n Applies maxpooling forward operation with index on  <src>  [ <height> ,  <width> ,  <channel> ], a three-dimensional tensor, with sliding window [ <kernel\\_height> ,  <kernel\\_width> ] and stride [ <stride\\_width> ,  <stride\\_height> ], and selects the index of the maximum value in each window. When the data type of  <src>  is  half  or  bfloat16\\_t , the data type of  <dst>  is  unsigned short . When the data type of  <src>  is  float , the data type of  <dst>  is  unsigned int . When window is slid in certain direction (H or W direction), if the left elements number doesn\u2019t match the window size, these elements will be discarded. If one of the elements being compared is a NaN, returns the element. If there are multiple NaN values, the index is the position of the first NaN value. If there are multiple maximum values, the index is the position of the first maximum value. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor whose data layout is HWC.\n*  [in] src : The address of source tensor whose data layout is HWC.\n*  [in] channel : Input channel.\n*  [in] height : The height of input feature map.\n*  [in] width : The width of input feature map.\n*  [in] kernel\\_height : The height of kernel.\n*  [in] kernel\\_width : The width of kernel.\n*  [in] stride\\_width : Stride of sliding window in W direction.\n*  [in] stride\\_height : Stride of sliding window in H direction.\n*  [in] in\\_dh : Dilation in H direction of input.\n*  [in] in\\_dw : Dilation in W direction of input.\n*  [in] out\\_dh : Dilation in H direction of output.\n*  [in] out\\_dw : Dilation in W direction of output. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <channel> ,  <height> ,  <width> ,  <kernel\\_height> ,  <kernel\\_width> ,  <stride\\_height> ,  <stride\\_width> ,  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  is 1 which means no dilation. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define CHANNELS 64 \n define HEIGHT 9 \n define WIDTH 12 \n define KERNEL_HEIGHT 5 \n define KERNEL_WIDTH 4 \n define BOTTOM_DATA_COUNT ((CHANNELS) * (WIDTH) * (HEIGHT)) \n #define TOP_DATA_COUNT \\\n  ((CHANNELS) * (HEIGHT / KERNEL_HEIGHT) * (WIDTH / KERNEL_WIDTH)) \n __mlu_entry__ void MaxPoolIndexKernel(half* bottom_data, int16_t* top_data,\n                                      int channels, int height, int width,\n                                      int pooled_height, int pooled_width) {\n  __nram__ half a_tmp[BOTTOM_DATA_COUNT];\n  __nram__ uint16_t b_tmp[TOP_DATA_COUNT];\n  __memcpy(a_tmp, bottom_data, BOTTOM_DATA_COUNT * sizeof(half), GDRAM2NRAM);\n  __bang_nan_maxpool_index(b_tmp, a_tmp, CHANNELS, HEIGHT, WIDTH,\n                           KERNEL_HEIGHT, KERNEL_WIDTH);\n  __memcpy(top_data, b_tmp, TOP_DATA_COUNT * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.18. __bang_nan_maxpool_value_index \n^^^^^^^^^^^^^^^\n void  __bang_nan_maxpool_value_index (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_nan_maxpool_value_index (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_nan_maxpool_value_index (float * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n Performs maximum pooling operation with the kernel  [kernel\\_height, kernel\\_width]  and the stride  [stride\\_width, stride\\_height]  on the tensor  <src>[channel, height, width]  in  \\_\\_nram\\_\\_  address space, then stores the maximum value and the corresponding index to  <dst> . When the data type of  <src>  is  half , the data type of  value  in  <dst>  is  half  and the data type of  index  in  <dst>  is  unsigned short . When the data type of  <src>  is  float , the data type of  value  in  <dst>  is  float  and the data type of  index  in  <dst>  is  unsigned int . When the kernel moves to the edge of input  <width>  and the kernel overflows, it will automatically adapt to the size of  <kernel\\_width> , so as to ensure that useless input is not included. If one of the elements being compared is a NaN, returns the element. If there are multiple NaN values, the index is the position of the first NaN value. If there are multiple maximum values, the index is the position of the first maximum value. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor whose data layout is HWC.\n*  [in] src : The address of source tensor whose data layout is HWC.\n*  [in] channel : The input channel.\n*  [in] height : The height of input source.\n*  [in] width : The width of input source.\n*  [in] kernel\\_height : The height of kernel.\n*  [in] kernel\\_width : The width of kernel.\n*  [in] stride\\_width : The stride in W direction.\n*  [in] stride\\_height : The stride in H direction.\n*  [in] value\\_index\\_stride : The offset from the beginning of data value to index value in bytes.\n*  [in] in\\_dh : Dilation in H direction of input.\n*  [in] in\\_dw : Dilation in W direction of input.\n*  [in] out\\_dh : Dilation in H direction of output.\n*  [in] out\\_dw : Dilation in W direction of output. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  and  <src>  must point to  \\_\\_nram\\_\\_  address space;\n* For the output tensor  <dst>[output\\_channel, output\\_height, output\\_width] ,  [output\\_channel] = <channel> , and  [output\\_height, output\\_width]  are obtained by deducing from  [height, width] ,  [kernel\\_height, kernel\\_width]  and  [stride\\_width, stride\\_height] ;\n* For the value part of  <dst> , when  <value\\_index\\_stride> > 0 , the address operands  <dst>  can be overlapped with  <src> ;\n*  <channel> ,  <height> ,  <width> ,  <kernel\\_height> ,  <kernel\\_width> ,  <stride\\_height> ,  <stride\\_width> ,  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  is 1 which means no dilation. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_NUM 64 \n __mlu_entry__ void kernel(half *dst, half *src, float *dst_f,\n                          float *src_f, int channel,\n                          int height, int width,\n                          int kernel_height, int kernel_width,\n                          int stride_width, int stride_height,\n                          int value_index_stride,\n                          int in_dh, int in_dw,\n                          int out_dh, int out_dw) {\n  __nram__ half svc_dst[DATA_NUM];\n  __nram__ half svc_src[DATA_NUM];\n  int datasize = DATA_NUM * sizeof(half);\n  __memcpy(svc_src, src, datasize, GDRAM2NRAM);\n  __bang_nan_maxpool_value_index(svc_dst, svc_src, channel, height,\n                                 width, kernel_height, kernel_width,\n                                 stride_width, stride_height,\n                                 value_index_stride,\n                                 in_dh, in_dw, out_dh, out_dw);\n  __memcpy(dst, svc_dst, datasize, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.19. __bang_nan_minpool \n^^^^^^^^^^^^^^^\n void  __bang_nan_minpool (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_nan_minpool (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_nan_minpool (float * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n Applies minpooling forward operation on  <src>``[``<height> ,  <width> ,  <channel> ], a three-dimensional tensor, with sliding window [ <kernel\\_height> ,  <kernel\\_width> ] and stride [ <stride\\_width> ,  <stride\\_height> ], and selects the minimum value in each window. When window is slid in certain direction (H or W direction), if the left elements number doesn\u2019t match the window size, these elements will be discarded. If one of the elements being compared is a NaN, returns the element. If there are multiple minimum values, the result is the first minimum value. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor whose data layout is HWC.\n*  [in] src : The address of source tensor whose data layout is HWC.\n*  [in] channel : Input channel.\n*  [in] height : The height of input feature map.\n*  [in] width : The width of input feature map.\n*  [in] kernel\\_height : The height of sliding window.\n*  [in] kernel\\_width : The width of sliding window.\n*  [in] stride\\_width : Stride of sliding window in W direction.\n*  [in] stride\\_height : Stride of sliding window in H direction.\n*  [in] in\\_dh : Dilation in H direction of input.\n*  [in] in\\_dw : Dilation in W direction of input.\n*  [in] out\\_dh : Dilation in H direction of output.\n*  [in] out\\_dw : Dilation in W direction of output. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <channel> ,  <height> ,  <width> ,  <kernel\\_height> ,  <kernel\\_width> ,  <stride\\_height> ,  <stride\\_width> ,  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  is 1 which means no dilation. "
  },
  {
    "content": "\n 3.12.20. __bang_nan_minpool_index \n^^^^^^^^^^^^^^^\n void  __bang_nan_minpool_index (unsigned short * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_nan_minpool_index (unsigned short * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_nan_minpool_index (unsigned int * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n Applies minpooling forward operation with index on  <src>  [ <height> ,  <width> ,  <channel> ], a three-dimensional tensor, with sliding window [ <kernel\\_height> ,  <kernel\\_width> ] and stride [ <stride\\_width> ,  <stride\\_height> ], and selects the index with the minimum value in each window. When the data type of  <src>  is  half  or  bfloat16\\_t , the data type of  <dst>  is  unsigned short . When the data type of  <src>  is  float , the data type of  <dst>  is  unsigned int . When window is slid in certain direction (H or W direction), if the left elements number doesn\u2019t match the window size, these elements will be discarded. If one of the elements being compared is a NaN, returns the element. If there are multiple NaN values, the index is the position of the first NaN value. If there are multiple minimum values, the index is the position of the first minimum value. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor whose data layout is HWC.\n*  [in] src : The address of source tensor whose data layout is HWC.\n*  [in] channel : Input channel.\n*  [in] height : The height of input feature map.\n*  [in] width : The width of input feature map.\n*  [in] kernel\\_height : The height of sliding window.\n*  [in] kernel\\_width : The width of sliding window.\n*  [in] stride\\_width : Stride of sliding window in W direction.\n*  [in] stride\\_height : Stride of sliding window in H direction.\n*  [in] in\\_dh : Dilation in H direction of input.\n*  [in] in\\_dw : Dilation in W direction of input.\n*  [in] out\\_dh : Dilation in H direction of output.\n*  [in] out\\_dw : Dilation in W direction of output. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <channel> ,  <height> ,  <width> ,  <kernel\\_height> ,  <kernel\\_width> ,  <stride\\_height> ,  <stride\\_width> ,  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  is 1 which means no dilation. "
  },
  {
    "content": "\n 3.12.21. __bang_nan_minpool_value_index \n^^^^^^^^^^^^^^^\n void  __bang_nan_minpool_value_index (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_nan_minpool_value_index (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n void  __bang_nan_minpool_value_index (float * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  value_index_stride , unsigned int  in_dh , unsigned int  in_dw , unsigned int  out_dh , unsigned int  out_dw )   \n Performs minimum pooling operation with the kernel [ <kernel\\_height> ,  <kernel\\_width> ] and the stride [ <stride\\_width> ,  <stride\\_height> ] on the tensor  <src>``[``<channel> ,  <height> ,  <width> ] in  \\_\\_nram\\_\\_  address space, and stores the minimum value and the corresponding index to  <dst> . When the data type of  <src>  is  half  or  bfloat16\\_t , the data type of  value  in  <dst>  is  half  and the data type of  index  in  <dst>  is  unsigned short . When the data type of  <src>  is  float , the data type of  value  in  <dst>  is  float  and the data type of  index  in  <dst>  is  unsigned int . When the kernel moves to the edge of input  <width>  and the kernel overflows, it will automatically adapt to the size of  <kernel\\_width> , so as to ensure that useless input is not included. If one of the elements being compared is a NaN, returns the element. If there are multiple NaN values, the index is the position of the first NaN value. If there are multiple minimum values, the index is the position of the first minimum value. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor whose data layout is HWC.\n*  [in] src : The address of source tensor whose data layout is HWC.\n*  [in] channel : The input channel.\n*  [in] height : The height of input source.\n*  [in] width : The width of input source.\n*  [in] kernel\\_height : The height of kernel.\n*  [in] kernel\\_width : The width of kernel.\n*  [in] stride\\_width : The stride in W direction.\n*  [in] stride\\_height : The stride in H direction.\n*  [in] value\\_index\\_stride : The offset from the beginning of data value to index value in bytes.\n*  [in] in\\_dh : Dilation in H direction of input.\n*  [in] in\\_dw : Dilation in W direction of input.\n*  [in] out\\_dh : Dilation in H direction of output.\n*  [in] out\\_dw : Dilation in W direction of output. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  and  <src>  must point to  \\_\\_nram\\_\\_  address space;\n* For the output tensor  <dst>[output\\_channel, output\\_height, output\\_width] ,  [output\\_channel] = <channel> , and  [output\\_height, output\\_width]  are obtained by deducing from  [height, width] ,  [kernel\\_height, kernel\\_width]  and  [stride\\_width, stride\\_height] ;\n* For the value part of  <dst> , when  <value\\_index\\_stride> > 0 , the address operands  <dst>  can be overlapped with  <src> ;\n*  <channel> ,  <height> ,  <width> ,  <kernel\\_height> ,  <kernel\\_width> ,  <stride\\_height> ,  <stride\\_width> ,  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for  <in\\_dh> ,  <in\\_dw> ,  <out\\_dh>  and  <out\\_dw>  is 1 which means no dilation. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_NUM 64 \n __mlu_entry__ void kernel(half *dst, half *src, float *dst_f, float *src_f,\n                          int channel, int height, int width, int kernel_height,\n                          int kernel_width, int stride_width, int stride_height,\n                          int value_index_stride, int in_dh, int in_dw,\n                          int out_dh, int out_dw);\n  int datasize = DATA_NUM * sizeof(half);\n  __nram__ half svc_dst[DATA_NUM];\n  __nram__ half svc_src[DATA_NUM];\n  __memcpy(svc_src, src, datasize, GDRAM2NRAM);\n  __bang_nan_minpool_value_index(svc_dst, svc_src, channel, height, width,\n                                 kernel_height, kernel_width, stride_width,\n                                 stride_height, value_index_stride,\n                                 in_dh, in_dw, out_dh, out_dw);\n  __memcpy(dst, svc_dst, datasize, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.22. __bang_relu \n^^^^^^^^^^^^^^^\n void  __bang_relu (char * dst ,  const  char * src , unsigned int  elem_count )   \n void  __bang_relu (short * dst ,  const  short * src , unsigned int  elem_count )   \n void  __bang_relu (int * dst ,  const  int * src , unsigned int  elem_count )   \n void  __bang_relu (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_relu (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count )   \n void  __bang_relu (float * dst ,  const  float * src , unsigned int  elem_count )   \n This instruction performs relu operation on each element in vector  <src>  and saves the result to vector  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  int ,  short  and  char  are not supported on  tp\\_520 ;\n*  <dst>  and  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_NUM 64 \n __mlu_entry__ void kernel(half *dst_h, half *src_h) {\n  __nram__ half nram_dst_h[DATA_NUM];\n  __nram__ half nram_src_h[DATA_NUM];\n  __memcpy(nram_src_h, src_h, DATA_NUM * sizeof(half), GDRAM2NRAM);\n  __bang_relu(nram_dst_h, nram_src_h, DATA_NUM);\n  __memcpy(dst_h, nram_dst_h, DATA_NUM * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.23. __bang_relun \n^^^^^^^^^^^^^^^\n void  __bang_relun (int * dst ,  const  int * src , unsigned int  elem_count , int  nvalue )   \n void  __bang_relun (short * dst ,  const  short * src , unsigned int  elem_count , short  nvalue )   \n void  __bang_relun (char * dst ,  const  char * src , unsigned int  elem_count , char  nvalue )   \n void  __bang_relun (half * dst ,  const  half * src , unsigned int  elem_count , half  nvalue )   \n void  __bang_relun (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count , bfloat16_t  nvalue )   \n void  __bang_relun (float * dst ,  const  float * src , unsigned int  elem_count , float  nvalue )   \n The instruction performs relun operation on each element in  <src> . If the element in  <src>  is less than 0, corresponding element in  <dst>  will be  0 . If the element is greater than  <nvalue> , corresponding element in  <dst>  will be  <nvalue> . Otherwise, the element in  <dst>  will be itself. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source.\n*  [in] nvalue : The N value of instruction. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  int ,  short  and  char  are not supported on  tp\\_520 ;\n*  <dst>  and  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <nvalue>  must be greater than zero, and cannot be  INF  or  NaN . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_NUM 64 \n __mlu_entry__ void kernel(half *dst_h, half *src_h, half const_h) {\n  __nram__ half nram_dst_h[DATA_NUM];\n  __nram__ half nram_src_h[DATA_NUM];\n  __memcpy(nram_src_h, src_h, DATA_NUM * sizeof(half), GDRAM2NRAM);\n  __bang_relun(nram_dst_h, nram_src_h, DATA_NUM, const_h);\n  __memcpy(dst_h, nram_dst_h, DATA_NUM * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.24. __bang_reshape_filter \n^^^^^^^^^^^^^^^\n void  __bang_reshape_filter (half * dst ,  const  half * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_filter (short * dst ,  const  short * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_filter (unsigned short * dst ,  const  unsigned short * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_filter (int8_t * dst ,  const  int8_t * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_filter (char * dst ,  const  char * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_filter (unsigned char * dst ,  const  unsigned char * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_filter (float * dst ,  const  float * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_filter (int * dst ,  const  int * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_filter (unsigned int * dst ,  const  unsigned int * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n Reshapes the vector  <src>  to  <n> / 64  along  n  dimension and suit for  \\_\\_bang\\_mlp()  and  \\_\\_bang\\_conv() , where the vector  <src>  is in  \\_\\_nram\\_\\_  space, then gives the result to the vector  <dst>  in  \\_\\_nram\\_\\_  space. \n``` \n include  \n __mlu_entry__ void MlpKernel(half *out_data,\n                             int8_t *in_data,\n                             int8_t *filter_data,\n                             half *bias_data,\n                             int height,\n                             int width,\n                             int pos) {\n __nram__ half nram_out_data[height];\n __nram__ half nram_bias_data[height];\n __nram__ int8_t nram_in_data[width];\n __wram__ int8_t wram_filter[height * width];\n __nram__ int8_t nram_filter1[height * width];\n __nram__ int8_t nram_filter2[height * width]; \n __memcpy(nram_in_data, in_data, width * sizeof(int8_t), GDRAM2NRAM);\n __memcpy(nram_bias_data, bias_data, height * sizeof(half), GDRAM2NRAM);\n __memcpy(nram_filter1, filter_data, height * width * sizeof(int8_t), GDRAM2NRAM); \n // __bang_mlp() height means channel output, width means channel input.\n // if filter_data all ready be shaped on host, don't need reshape again on MLU\n __bang_reshape_filter(nram_filter2, nram_filter1, height, 1, 1, width); \n __memcpy(wram_filter, nram_filter2, height * width * sizeof(int8_t), NRAM2WRAM);\n __bang_mlp(nram_out_data, nram_in_data, nram_bias_data, wram_filter, width, width, pos);\n __memcpy(out_data, nram_out_data, height * sizeof(half), NRAM2GDRAM);\n} \n ``` \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of output kernel whose data layout is  NHWC  .\n*  [in] src : The address of input kernel whose data layout is  NHWC  .\n*  [in] n : The batch number of input kernel, also can represent channel output.\n*  [in] h : The height of input kernel.\n*  [in] w : The width of input kernel.\n*  [in] c : The channel input of kernel. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <n>  must be divisible by 64;\n* (  \\times   \\times   \\times sizeof(type)) must be divisible by 128 on  (m)tp\\_2xx ;\n* (  \\times   \\times   \\times sizeof(type)) must be divisible by 32 on  (m)tp\\_3xx or higher ;\n*  <dst>  cannot be overlapped with  <src> . \n^^^^^^^^^^^^^^^\n Example \n"
  },
  {
    "content": "\n 3.12.25. __bang_reshape_nchw2nhwc \n^^^^^^^^^^^^^^^\n void  __bang_reshape_nchw2nhwc (half * dst ,  const  half * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_nchw2nhwc (short * dst ,  const  short * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_nchw2nhwc (unsigned short * dst ,  const  unsigned short * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_nchw2nhwc (int8_t * dst ,  const  int8_t * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_nchw2nhwc (char * dst ,  const  char * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_nchw2nhwc (unsigned char * dst ,  const  unsigned char * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_nchw2nhwc (float * dst ,  const  float * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_nchw2nhwc (int * dst ,  const  int * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_nchw2nhwc (unsigned int * dst ,  const  unsigned int * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n Reshapes the vector  <src>  from  NCHW  to  NHWC , where the vector  <src>  is in  \\_\\_nram\\_\\_  space and has an order of  NCHW , then gives the result to the vector  <dst>  in  \\_\\_nram\\_\\_  space and has an order of  NHWC . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of output kernel whose data layout is  NHWC  .\n*  [in] src : The address of input kernel whose data layout is  NCHW  .\n*  [in] n : The batch number of input kernel, also can represent channel output..\n*  [in] h : The height of input kernel.\n*  [in] w : The width of input kernel.\n*  [in] c : The channel input of kernel. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* (  \\times   \\times sizeof(type)) must be divisible by 64;\n* (  \\times sizeof(type)) must be divisible by 64;\n*  <dst>  cannot be overlapped with  <src> . "
  },
  {
    "content": "\n 3.12.26. __bang_reshape_nhwc2nchw \n^^^^^^^^^^^^^^^\n void  __bang_reshape_nhwc2nchw (half * dst ,  const  half * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_nhwc2nchw (short * dst ,  const  short * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_nhwc2nchw (unsigned short * dst ,  const  unsigned short * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_nhwc2nchw (int8_t * dst ,  const  int8_t * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_nhwc2nchw (char * dst ,  const  char * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_nhwc2nchw (unsigned char * dst ,  const  unsigned char * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_nhwc2nchw (float * dst ,  const  float * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_nhwc2nchw (int * dst ,  const  int * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n void  __bang_reshape_nhwc2nchw (unsigned int * dst ,  const  unsigned int * src , unsigned int  n , unsigned int  h , unsigned int  w , unsigned int  c )   \n Reshapes the vector  <src>  from  NHWC  to  NCHW , where the vector  <src>  is in  \\_\\_nram\\_\\_  space and has an order of  NHWC , then gives the result to the vector  <dst>  in  \\_\\_nram\\_\\_  space and has an order of  NCHW  . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of output kernel whose data layout is  NCHW  .\n*  [in] src : The address of input kernel whose data layout is  NHWC  .\n*  [in] n : The batch number of input kernel, also can represent channel output.\n*  [in] h : The height of input kernel.\n*  [in] w : The width of input kernel.\n*  [in] c : The channel input of kernel. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* (  \\times   \\times sizeof(type)) must be divisible by 64;\n* (  \\times sizeof(type)) must be divisible by 64;\n*  <dst>  cannot be overlapped with  <src> . "
  },
  {
    "content": "\n 3.12.27. __bang_ssparse_filter_index \n^^^^^^^^^^^^^^^\n void  __bang_ssparse_filter_index (half * dst ,  const  half * src , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_index (float * dst ,  const  float * src , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_index (int8_t * dst ,  const  int8_t * src , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_index (int16_t * dst ,  const  int16_t * src , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_index (int * dst ,  const  int * src , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_index (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n Selects 2 elements with larger absolute value from every 4 elements of  <src>  and stores the index of selected elements in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] input\\_channel : The number of input channel of source vector.\n*  [in] src\\_height : The height of source vector.\n*  [in] src\\_width : The width of source vector.\n*  [in] output\\_channel : The number of channel of destination vector. \n^^^^^^^^^^^^^^^\n Return *  void \n^^^^^^^^^^^^^^^\n Remark *  <dst>  and  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  is split by 8 elements on  input\\_channel  dimension. When the split part is less than 8 elements, hardware will pad to 8 elements with zero;\n* Each bit in index corresponds to one element in  <src> ;\n* There is no alignment constraint for parameter  <input\\_channel> , but the size of  input\\_channel  dimension of  <dst>  must align to  ceil(<input\\_channel> / (8 \\* (sizeof(typeof(<src>)))))  byte(s). \n^^^^^^^^^^^^^^^\n Example \n``` \n include \"bang.h\" \n define SRC_CHANNEL_BYTES (2 * 128) \n define KERNEL_HEIGHT 2 \n define KERNEL_WIDTH 3 \n define DST_CHANNEL 4 \n define INPUT_BYTES (SRC_CHANNEL_BYTES * KERNEL_HEIGHT * KERNEL_WIDTH * DST_CHANNEL) \n define OUTPUT_BYTES ((INPUT_BYTES) / 4) \n define TOTAL_INPUT_BYTES ((INPUT_BYTES)*2) \n define TOTAL_OUTPUT_BYTES ((OUTPUT_BYTES)*2) \n __mlu_global__ void kernel_ssparse_filter_index(bfloat16_t* dst, bfloat16_t* src) {\n  __nram__ bfloat16_t dst_nram[TOTAL_OUTPUT_BYTES / sizeof(bfloat16_t)];\n  __nram__ bfloat16_t src_nram[TOTAL_INPUT_BYTES / sizeof(bfloat16_t)]; \n __memcpy(src_nram, src, TOTAL_INPUT_BYTES, GDRAM2NRAM); \n __bang_ssparse_filter_index(dst_nram, src_nram, SRC_CHANNEL_BYTES,\n                              KERNEL_HEIGHT, KERNEL_WIDTH, DST_CHANNEL);\n  __bang_ssparse_filter_index(\n      dst_nram + (INPUT_BYTES / (sizeof(bfloat16_t) * 8 * sizeof(bfloat16_t))),\n      src_nram + (INPUT_BYTES / sizeof(bfloat16_t)), SRC_CHANNEL_BYTES, KERNEL_HEIGHT,\n      KERNEL_WIDTH, DST_CHANNEL); \n __memcpy(dst, dst_nram, TOTAL_OUTPUT_BYTES, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.28. __bang_ssparse_filter_sparse_index \n^^^^^^^^^^^^^^^\n void  __bang_ssparse_filter_sparse_index (half * dst ,  const  half * src ,  const  half * index , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_sparse_index (float * dst ,  const  float * src ,  const  float * index , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_sparse_index (int8_t * dst ,  const  int8_t * src ,  const  int8_t * index , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_sparse_index (int16_t * dst ,  const  int16_t * src ,  const  int16_t * index , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_sparse_index (int * dst ,  const  int * src ,  const  int * index , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_sparse_index (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * index , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n Selects 2 elements based on  <index>  from every 4 elements of  <src> , sets the unselected elements to zero and stores the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] index : The address of index vector.\n*  [in] input\\_channel : The number of input channel of source vector.\n*  [in] src\\_height : The height of source vector.\n*  [in] src\\_width : The width of source vector.\n*  [in] output\\_channel : The number of channel of destination vector. \n^^^^^^^^^^^^^^^\n Return *  void \n^^^^^^^^^^^^^^^\n Remark *  <dst> ,  <src>  and  <index>  must point to  \\_\\_nram\\_\\_  address space;\n* Each bit in  <index>  corresponds to one element in  <src> ;\n*  <dst>  and  <src>  have the same  <input\\_channel>  dimension size;\n* The byte size of  <input\\_channel>  dimension of  <index>  equals  ceil(<input\\_channel> / bit\\_size(typeof(<src>))) ;\n* If  <index>  is split by 4 bits and some parts do not belong to  {4'b0011, 4'b0101, 4'b1001, 4'b0110, 4'b1010, 4'b1100} , hardware will set illegal parts to  4'b0011  to keep the propram running. \n^^^^^^^^^^^^^^^\n Example \n``` \n include \"bang.h\" \n define SRC_CHANNEL_BYTES (2 * 128) \n define KERNEL_HEIGHT 1 \n define KERNEL_WIDTH 1 \n define DST_CHANNEL 1 \n define INPUT_BYTES ((SRC_CHANNEL_BYTES) * (KERNEL_HEIGHT) * (KERNEL_WIDTH) * (DST_CHANNEL)) \n define OUTPUT_BYTES (INPUT_BYTES) \n define TOTAL_INPUT_BYTES (2 * (INPUT_BYTES)) \n define TOTAL_OUTPUT_BYTES (2 * (OUTPUT_BYTES)) \n __mlu_global__ void kernel(bfloat16_t* dst, bfloat16_t* src) {\n  __nram__ bfloat16_t dst_nram[TOTAL_OUTPUT_BYTES / sizeof(bfloat16_t)];\n  __nram__ bfloat16_t src_nram[TOTAL_INPUT_BYTES / sizeof(bfloat16_t)];\n  __nram__ bfloat16_t idx_nram[TOTAL_INPUT_BYTES / sizeof(bfloat16_t) / 4]; \n __memcpy(src_nram, src, TOTAL_INPUT_BYTES, GDRAM2NRAM); \n __bang_ssparse_filter_index(idx_nram,\n                              src_nram,\n                              SRC_CHANNEL_BYTES,\n                              SRC_HEIGHT,\n                              SRC_WIDTH,\n                              DST_CHANNEL); \n __bang_ssparse_filter_sparse_index(dst_nram,\n                                     src_nram,\n                                     idx_nram,\n                                     SRC_CHANNEL_BYTES,\n                                     SRC_HEIGHT,\n                                     SRC_WIDTH,\n                                     DST_CHANNEL);\n  __bang_ssparse_filter_index(\n      (bfloat16_t*)((char*)(idx_nram) + INPUT_BYTES / (sizeof(bfloat16_t) * 8)),\n      (bfloat16_t*)((char*)(src_nram) + INPUT_BYTES), SRC_CHANNEL_BYTES, KERNEL_HEIGHT,\n      KERNEL_WIDTH, DST_CHANNEL);\n  __bang_ssparse_filter_sparse_index(\n      (bfloat16_t*)((char*)(dst_nram) + OUTPUT_BYTES),\n      (bfloat16_t*)((char*)(src_nram) + INPUT_BYTES),\n      (bfloat16_t*)((char*)(idx_nram) + (INPUT_BYTES / (sizeof(bfloat16_t) * 8))),\n      SRC_CHANNEL_BYTES, KERNEL_HEIGHT, KERNEL_WIDTH, DST_CHANNEL);\n  __memcpy(dst, dst_nram, TOTAL_OUTPUT_BYTES, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.29. __bang_ssparse_filter_union \n^^^^^^^^^^^^^^^\n void  __bang_ssparse_filter_union (half * dst ,  const  half * src , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_union (float * dst ,  const  float * src , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_union (int8_t * dst ,  const  int8_t * src , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_union (int16_t * dst ,  const  int16_t * src , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_union (int * dst ,  const  int * src , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_union (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n Selects 2 elements with larger absolute value from every 4 elements of  <src>  and stores the selected elements and corresponding indexes in  <dst>  in form of 96-byte structure. Each structure consists of 64-byte data and 32-byte index. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] input\\_channel : The number of input channel of source vector.\n*  [in] src\\_height : The height of source vector.\n*  [in] src\\_width : The width of source vector.\n*  [in] output\\_channel : The number of channel of destination vector. \n^^^^^^^^^^^^^^^\n Return *  void \n^^^^^^^^^^^^^^^\n Remark *  <dst>  and  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  is split by 128 bytes on  input\\_channel  dimension. When the split part is less than 128 bytes, hardware will pad to 128 bytes with zero;\n* Each bit in index corresponds to 4 bits in  <src> . If one bit is 1 in output index, that means its corresponding 4 bits in  <src>  are selected;\n* There is no alignment constraint for parameter  <input\\_channel> , but the size of  input\\_channel  dimension of  <dst>  must align to  (ceil(<input\\_channel> / 128) \\* 96)  byte(s). \n^^^^^^^^^^^^^^^\n Example \n``` \n include \"bang.h\" \n define SRC_CHANNEL_BYTES (2 * 128) \n define KERNEL_HEIGHT 1 \n define KERNEL_WIDTH 1 \n define DST_CHANNEL 1 \n #define INPUT_BYTES \\\n  ((SRC_CHANNEL_BYTES) * (KERNEL_HEIGHT) * (KERNEL_WIDTH) * (DST_CHANNEL)) \n define OUTPUT_BYTES ((INPUT_BYTES) / 128 * 96) \n define TOTAL_INPUT_BYTES (2 * (INPUT_BYTES)) \n define TOTAL_OUTPUT_BYTES (2 * (OUTPUT_BYTES)) \n __mlu_global__ void kernel_ssparse_filter_union(bfloat16_t* dst, bfloat16_t* src) {\n  __nram__ bfloat16_t dst_nram[TOTAL_OUTPUT_BYTES / sizeof(bfloat16_t)];\n  __nram__ bfloat16_t src_nram[TOTAL_INPUT_BYTES / sizeof(bfloat16_t)];\n  __memcpy(src_nram, src, TOTAL_INPUT_BYTES, GDRAM2NRAM);\n  __bang_ssparse_filter_union(static_cast (dst_nram),\n                              static_cast (src_nram), SRC_CHANNEL_BYTES,\n                              KERNEL_HEIGHT, KERNEL_WIDTH, DST_CHANNEL);\n  __bang_ssparse_filter_union(\n      static_cast (&dst_nram[OUTPUT_BYTES / sizeof(bfloat16_t)]),\n      static_cast (&src_nram[INPUT_BYTES / sizeof(bfloat16_t)]), SRC_CHANNEL_BYTES,\n      KERNEL_HEIGHT, KERNEL_WIDTH, DST_CHANNEL);\n  __memcpy(dst, dst_nram, TOTAL_OUTPUT_BYTES, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.30. __bang_ssparse_filter_union_index \n^^^^^^^^^^^^^^^\n void  __bang_ssparse_filter_union_index (half * dst ,  const  half * src ,  const  half * index , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_union_index (float * dst ,  const  float * src ,  const  float * index , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_union_index (int8_t * dst ,  const  int8_t * src ,  const  int8_t * index , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_union_index (int16_t * dst ,  const  int16_t * src ,  const  int16_t * index , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_union_index (int * dst ,  const  int * src ,  const  int * index , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n void  __bang_ssparse_filter_union_index (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * index , unsigned int  input_channel , unsigned int  src_height , unsigned int  src_width , unsigned int  output_channel )   \n Selects 2 elements based on  <index>  from every 4 elements of  <src>  and stores the selected elements and corresponding indexes in  <dst>  in form of 96-byte structure. Each structure consists of 64-byte data and 32-byte index. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] index : The address of index vector.\n*  [in] input\\_channel : The number of input channel of source vector.\n*  [in] src\\_height : The height of source vector.\n*  [in] src\\_width : The width of source vector.\n*  [in] output\\_channel : The number of channel of destination vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst> ,  <src>  and  <index>  must point to  \\_\\_nram\\_\\_  address space;\n* Each bit in  <index>  corresponds to one element in  <src> ;\n* Each bit in output index corresponds to 4 bits in  <src> . If one bit is 1 in output index, its corresponding 4 bits in  <src>  are selected;\n* There is no alignment constraint for parameter  <input\\_channel> , but the size of  input\\_channel  dimension of  <dst>  must align to 96 bytes;\n* The data part of  <dst>  should be 64-byte aligned. Otherwise, hardware will pad to 64 bytes with zero;\n* The index part of  <dst>  should be 32-byte aligned. Otherwise,\n    + If  bit\\_size(<type>) == 4 , hardware will pad to 32 bytes with  4'b0011 .\n    + If  bit\\_size(<type>) == 8 , hardware will pad to 32 bytes with  8'b0000\\_1111 .\n    + If  bit\\_size(<type>) == 16 , hardware will pad to 32 bytes with  16'b0000\\_0000\\_1111\\_1111 .\n    + If  bit\\_size(<type>) == 32 , hardware will pad to 32 bytes with  32'b0000\\_0000\\_0000\\_0000\\_1111\\_1111\\_1111\\_1111 ;\n* Split  <index>  by 4 bits and set illegal parts, which do not belong to  {4'b0011, 4'b0101, 4'b1001, 4'b0110, 4'b1010, 4'b1100} , to  4'b0011 . \n^^^^^^^^^^^^^^^\n Example \n``` \n include \"bang.h\" \n define SRC_CHANNEL_BYTES (2 * 128) \n define KERNEL_HEIGHT 1 \n define KERNEL_WIDTH 1 \n define DST_CHANNEL 1 \n #define INPUT_BYTES \\\n  ((SRC_CHANNEL_BYTES) * (KERNEL_HEIGHT) * (KERNEL_WIDTH) * (DST_CHANNEL)) \n define OUTPUT_BYTES ((INPUT_BYTES) / 128 * 96) \n define TOTAL_INPUT_BYTES (2 * (INPUT_BYTES)) \n define TOTAL_OUTPUT_BYTES (2 * (OUTPUT_BYTES)) \n __mlu_global__ void kernel_ssparse_filter_union_index(bfloat16_t* dst, bfloat16_t* src) {\n  __nram__ bfloat16_t dst_nram[TOTAL_OUTPUT_BYTES / sizeof(bfloat16_t)];\n  __nram__ bfloat16_t src_nram[TOTAL_INPUT_BYTES / sizeof(bfloat16_t)];\n  __nram__ bfloat16_t idx_nram[TOTAL_INPUT_BYTES / sizeof(bfloat16_t) / 4];\n  __memcpy(src_nram, src, TOTAL_INPUT_BYTES, GDRAM2NRAM);\n  __bang_ssparse_filter_index(static_cast (idx_nram),\n                              static_cast (src_nram), SRC_CHANNEL_BYTES,\n                              KERNEL_HEIGHT, KERNEL_WIDTH, DST_CHANNEL);\n  __bang_ssparse_filter_union_index(\n      static_cast (dst_nram), static_cast (src_nram),\n      static_cast (idx_nram), SRC_CHANNEL_BYTES, KERNEL_HEIGHT, KERNEL_WIDTH,\n      DST_CHANNEL);\n  __bang_ssparse_filter_index(\n      (bfloat16_t*)((char*)(idx_nram) + INPUT_BYTES / (sizeof(bfloat16_t) * 8)),\n      (bfloat16_t*)((char*)(src_nram) + INPUT_BYTES), SRC_CHANNEL_BYTES, KERNEL_HEIGHT,\n      KERNEL_WIDTH, DST_CHANNEL);\n  __bang_ssparse_filter_union_index(\n      (bfloat16_t*)((char*)(dst_nram) + OUTPUT_BYTES),\n      (bfloat16_t*)((char*)(src_nram) + INPUT_BYTES),\n      (bfloat16_t*)((char*)(idx_nram) + (INPUT_BYTES / (sizeof(bfloat16_t) * 8))),\n      SRC_CHANNEL_BYTES, KERNEL_HEIGHT, KERNEL_WIDTH, DST_CHANNEL);\n  __memcpy(dst, dst_nram, TOTAL_OUTPUT_BYTES, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.31. __bang_sumpool \n^^^^^^^^^^^^^^^\n void  __bang_sumpool (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width )   \n void  __bang_sumpool (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height )   \n void  __bang_sumpool (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height )   \n void  __bang_sumpool (float * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height )   \n Applies sumpooling forward operation on  <src>  [ <height> ,  <width> ,  <channel> ], a three-dimensional tensor, with sliding window [ <kernel\\_height> ,  <kernel\\_width> ] and stride [ <stride\\_width> ,  <stride\\_height> ], and saves the sum in each window. When window is slid in certain direction (H or W direction), if the left elements number doesn\u2019t match the window size, these elements will be discarded. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor whose data layout is HWC.\n*  [in] src : The address of source tensor whose data layout is HWC.\n*  [in] channel : Input channel.\n*  [in] height : The height of input feature map.\n*  [in] width : The width of input feature map.\n*  [in] kernel\\_height : The height of kernel.\n*  [in] kernel\\_width : The width of kernel.\n*  [in] stride\\_width : Stride of W direction.\n*  [in] stride\\_height : Stride of H direction. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <channel> ,  <height> ,  <width> ,  <kernel\\_height>  and  <kernel\\_width>  must be greater than 0;\n*  <stride\\_height>  and  <stride\\_width>  must be greater than 0 if specified;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16}). \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define CHANNELS 64 \n define IN_HEIGHT 9 \n define IN_WIDTH 9 \n define KERNEL_HEIGHT 3 \n define KERNEL_WIDTH 3 \n define STRIDE_X 1 \n define STRIDE_Y 1 \n define INPUT_COUNT ((CHANNELS) * (IN_WIDTH) * (IN_HEIGHT)) \n #define OUTPUT_COUNT \\\n  ((CHANNELS) * ((IN_HEIGHT - KERNEL_HEIGHT) / STRIDE_Y + 1) * \\\n  ((IN_WIDTH - KERNEL_WIDTH) / STRIDE_X + 1)) \n __mlu_entry__ void PoolSumKernel(half* output, half* input) {\n  __nram__ half a_tmp[INPUT_COUNT];\n  __nram__ half b_tmp[OUTPUT_COUNT];\n  __memcpy(a_tmp, input, INPUT_COUNT * sizeof(half), GDRAM2NRAM);\n  __bang_sumpool(b_tmp, a_tmp, CHANNELS, IN_HEIGHT, IN_WIDTH,\n                 KERNEL_HEIGHT, KERNEL_WIDTH, STRIDE_X, STRIDE_Y);\n  __memcpy(output, b_tmp, OUTPUT_COUNT * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.32. __bang_sumpool_bp \n^^^^^^^^^^^^^^^\n void  __bang_sumpool_bp (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , mluPoolBPOverlap  overlap  = OVERLAP_ACC)   \n void  __bang_sumpool_bp (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , mluPoolBPOverlap  overlap  = OVERLAP_ACC)   \n void  __bang_sumpool_bp (float * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , mluPoolBPOverlap  overlap  = OVERLAP_ACC)   \n Performs sumpooling backward propagation operation on  <src>  [ <height> ,  <width> ,  <channel> ], a three-dimensional tensor, with sliding window [ <kernel\\_height> ,  <kernel\\_width> ] and stride [ <stride\\_width> ,  <stride\\_height> ], and calculates the sum value in each window.  <overlap>  indicates the type of overlap options.  <overlap>  is assigned to an enumerated type called  mluPoolBPOverlap  that contains 2 enumerators listed in the table below. When window is slid in certain direction (H or W direction), if the left elements number doesn\u2019t match the window size, these elements will be discarded. \n ^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor whose data layout is HWC.\n*  [in] src : The address of source tensor whose data layout is HWC.\n*  [in] channel : Input channel.\n*  [in] height : The height of output feature map.\n*  [in] width : The width of output feature map.\n*  [in] kernel\\_height : The height of kernel.\n*  [in] kernel\\_width : The width of kernel.\n*  [in] stride\\_width : Stride of sliding window in W direction.\n*  [in] stride\\_height : Stride of sliding window in H direction.\n*  [in] overlap : The type of overlap options. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  cannot be overlapped with  <src> ;\n* The default  mluPoolBPOverlap  option is  OVERLAP\\_ACC ;\n*  [input\\_height]  and  [input\\_width]  of  <src>  must be greater than 0;\n*  <channel> ,  <height> ,  <width> ,  <kernel\\_height> ,  <kernel\\_width> ,  <stride\\_height>  and  <stride\\_width>  must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16}).\nUse __bang_sumpool_bp and __bang_cycle_mul instead on (m)tp_2xx or use __bang_sumpool_bp and __bang_mul_scalar instead on (m)tp_3xx or higher. \n^^^^^^^^^^^^^^^\n Example \n```\n #include  \n __mlu_entry__ void PoolSumBpKernel(half* output, half* input,\n                                    unsigned int channels, int out_height,\n                                    unsigned int out_width, int kernel_height,\n                                    unsigned int kernel_width, int stride_width,\n                                    unsigned int stride_height) {\n   __nram__ half a_tmp[INPUT_COUNT];\n   __nram__ half b_tmp[OUTPUT_COUNT];\n   __memcpy(b_tmp, output, OUTPUT_COUNT * sizeof(half), GDRAM2NRAM);\n   __memcpy(a_tmp, input, INPUT_COUNT * sizeof(half), GDRAM2NRAM);\n   __bang_sumpool_bp(b_tmp, a_tmp, channels, out_height, out_width,\n                     kernel_height, kernel_width, stride_width,\n                     stride_height);\n   __memcpy(output, b_tmp, OUTPUT_COUNT * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.12.33. __bang_unpool \n^^^^^^^^^^^^^^^\n void  __bang_unpool (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  index )   \n void  __bang_unpool (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  index )   \n void  __bang_unpool (float * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  kernel_height , unsigned int  kernel_width , unsigned int  stride_width , unsigned int  stride_height , unsigned int  index )   \n Applies unpooling backward operation on  <src> , a tensor. Every element of  <src>  tensor corresponds to a kernel window on  <dst>  tensor operand. The elements of  <src>  tensor is written into  <index> \u2019th position in that kernel window on  <dst>  tensor, and other positions in the kernel window are written zero. \n The Figure Process of Unpool Operation shows an example with the following parameters,  height = 5 ,  width = 5 ,  kernel\\_height = 2 ,  kernel\\_width = 2 ,  stride\\_height = 3 ,  stride\\_width = 3 ,  input\\_height = 2 ,  input\\_width = 2 , and  index = 1 . \n Fig. 3.4 Process of Unpool Operation \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination tensor whose data layout is HWC.\n*  [in] src : The address of source tensor whose data layout is HWC.\n*  [in] channel : Input channel.\n*  [in] height : The height of output feature map.\n*  [in] width : The width of output feature map.\n*  [in] kernel\\_height : The height of kernel.\n*  [in] kernel\\_width : The width of kernel.\n*  [in] stride\\_width : W direction of stride.\n*  [in] stride\\_height : H direction of stride.\n*  [in] index : Index within kernel window. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* The shape of  <dst>  tensor [ <height> ,  <width> ,  out\\_channel ] and  <src>  tensor [ input\\_height ,  input\\_width ,  <channel> ] has following restrictions: (  = (input\\_height \u2013 1) *   +  ), (  = (input\\_width \u2013 1) *   +  ), (out\\_channel =  );\n* The  <index> \u2019th position in kernel window means ikh\u2019th row and ikw\u2019th column in kernel window, where (ikh *  <kernel\\_width>  + ikw =  <index> );\n* If  <stride\\_width>  >  <kernel\\_width>  or  <stride\\_height>  >  <kernel\\_height> , the elements in  <dst>  that do not belong to any kernel window remain unchanged;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <channel> ,  <height> ,  <width> ,  <kernel\\_height> ,  <kernel\\_width> ,  <stride\\_height>  and  <stride\\_width>  must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16}). \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define CHANNELS 128 \n define HEIGHT 6 \n define WIDTH 4 \n define KERNEL_HEIGHT 3 \n define KERNEL_WIDTH 2 \n define STRIDE_X 2 \n define STRIDE_Y 3 \n define INDEX_IN_KERNEL 2 \n define H_SMALL ((HEIGHT-KERNEL_HEIGHT)/STRIDE_Y+1) \n define W_SMALL ((WIDTH-KERNEL_WIDTH)/STRIDE_X+1) \n define TOP_DATA_COUNT ((CHANNELS) * (WIDTH) * (HEIGHT)) \n define BOTTOM_DATA_COUNT ((CHANNELS) * H_SMALL * W_SMALL) \n __mlu_entry__ void UnPoolKernel(half* top_data, int16_t* bottom_data,\n                                int channels, int height, int width,\n                                int kh, int kw, int sx, int sy,\n                                int index_in_kernel) {\n  __nram__ half a_tmp[BOTTOM_DATA_COUNT];\n  __nram__ half b_tmp[TOP_DATA_COUNT];\n  __memcpy(a_tmp, bottom_data, BOTTOM_DATA_COUNT * sizeof(half), GDRAM2NRAM);\n  __memcpy(b_tmp, top_data, TOP_DATA_COUNT * sizeof(half), GDRAM2NRAM);\n  __bang_unpool(b_tmp, a_tmp, CHANNELS, HEIGHT, WIDTH, KERNEL_HEIGHT,\n                KERNEL_WIDTH, sx, sy, index_in_kernel);\n  __memcpy(top_data, b_tmp, TOP_DATA_COUNT * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.13.1. __bang_atomic_add \n^^^^^^^^^^^^^^^\n void  __bang_atomic_add (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_add (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_add (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_add (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_add (half * dst , half * src1 , half  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_add (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_add (float * dst , float * src1 , float  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_add (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_add (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_add (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_add (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n void  __bang_atomic_add (half * dst , half * src1 ,  const  half * src2 , unsigned int  size )   \n void  __bang_atomic_add (bfloat16_t * dst , bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_atomic_add (float * dst , float * src1 ,  const  float * src2 , unsigned int  size )   \n Copies  <src1>  to  <dst> , adds  <src2>  to  <src1>  element-wisely. That is:  <dst>  =  <src1> ;  <src1>  =  <src1>  +  <src2> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector;\n*  <size>  must be greater than zero;\n*  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space. \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(short* src1, short src2) {\n  __nram__ short v[64];\n  __bang_atomic_add(v, src1, src2, 64);\n} \n ``` \n"
  },
  {
    "content": "\n 3.13.2. __bang_atomic_add_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_add_async (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_add_async (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_add_async (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_add_async (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_add_async (half * dst , half * src1 , half  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_add_async (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_add_async (float * dst , float * src1 , float  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_add_async (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_add_async (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_add_async (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_add_async (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n void  __bang_atomic_add_async (half * dst , half * src1 ,  const  half * src2 , unsigned int  size )   \n void  __bang_atomic_add_async (bfloat16_t * dst , bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_atomic_add_async (float * dst , float * src1 ,  const  float * src2 , unsigned int  size )   \n Copies  <src1>  to  <dst> , adds  <src2>  to  <src1>  element-wisely. That is:  <dst>  =  <src1> ;  <src1>  =  <src1>  +  <src2> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector;\n*  <size>  must be greater than zero;\n*  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space. \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(short* src1, short src2) {\n  __nram__ short v[64];\n  __bang_atomic_add_async(v, src1, src2, 64);\n} \n ``` \n"
  },
  {
    "content": "\n 3.13.3. __bang_atomic_and \n^^^^^^^^^^^^^^^\n void  __bang_atomic_and (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_and (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_and (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_and (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_and (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_and (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_and (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_and (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n Applies bitwise AND operation to the vector  <src1>  and  <src2> , stores the result in  <src1> , and stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  =  <src1>  &  <src2> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.4. __bang_atomic_and_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_and_async (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_and_async (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_and_async (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_and_async (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_and_async (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_and_async (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_and_async (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_and_async (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n Applies bitwise AND operation to the vector  <src1>  and  <src2> , stores the result in  <src1> , and stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  =  <src1>  &  <src2> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.5. __bang_atomic_cas \n^^^^^^^^^^^^^^^\n void  __bang_atomic_cas (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned short  src3 )   \n void  __bang_atomic_cas (short * dst , short * src1 , short  src2 , short  src3 )   \n void  __bang_atomic_cas (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  src3 )   \n void  __bang_atomic_cas (float * dst , float * src1 , float  src2 , float  src3 )   \n void  __bang_atomic_cas (half * dst , half * src1 , half  src2 , half  src3 )   \n void  __bang_atomic_cas (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , bfloat16_t  src3 )   \n void  __bang_atomic_cas (int * dst , int * src1 , int  src2 , int  src3 )   \n If  <src2>  is equal to  <\\*src1> , stores  <src3>  in  <src1> . Stores the original value of  <\\*src1>  in  <dst> . That is:  <\\*dst>  =  <\\*src1> ;  <\\*src1>  = ( <\\*src1>  ==  <src2> ) ?  <src3>  :  <\\*src1> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1 : The address of first operand.\n*  [in] src2 : The second operand.\n*  [in] src3 : The third operand. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * This function only operates on one element;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(short* src1, short src2, short src3) {\n  __nram__ short v;\n  __bang_atomic_cas(&v, src1, src2, src3);\n} \n ``` \n"
  },
  {
    "content": "\n 3.13.6. __bang_atomic_cas_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_cas_async (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned short  src3 )   \n void  __bang_atomic_cas_async (short * dst , short * src1 , short  src2 , short  src3 )   \n void  __bang_atomic_cas_async (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  src3 )   \n void  __bang_atomic_cas_async (float * dst , float * src1 , float  src2 , float  src3 )   \n void  __bang_atomic_cas_async (half * dst , half * src1 , half  src2 , half  src3 )   \n void  __bang_atomic_cas_async (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , bfloat16_t  src3 )   \n void  __bang_atomic_cas_async (int * dst , int * src1 , int  src2 , int  src3 )   \n If  <src2>  is equal to  <\\*src1> , stores  <src3>  in  <src1> . Stores the original value of  <\\*src1>  in  <dst> . That is:  <\\*dst>  =  <\\*src1> ;  <\\*src1>  = ( <\\*src1>  ==  <src2> ) ?  <src3>  :  <\\*src1> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1 : The address of first operand.\n*  [in] src2 : The second operand.\n*  [in] src3 : The third operand. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * This function only operates on one element;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(short* src1, short src2, short src3) {\n  __nram__ short v;\n  __bang_atomic_cas_async(&v, src1, src2, src3);\n} \n ``` \n"
  },
  {
    "content": "\n 3.13.7. __bang_atomic_dec \n^^^^^^^^^^^^^^^\n void  __bang_atomic_dec (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_dec (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_dec (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_dec (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_dec (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_dec (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_dec (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_dec (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n Compares vector  <src1>  and  <src2>  element-wisely. If  <src1>  is larger than  <src2> , or the value of  <src1>  is 0, stores the int value  <src2>  in  <src1> ; otherwise, subtracts  <src1>  by 1. Stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  = ( <src1>  == 0 ||  <src1>  >  <src2> ) ?  <src2>  : ( <src1>  - 1). All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n*  <size>  must be greater than zero;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.8. __bang_atomic_dec_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_dec_async (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_dec_async (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_dec_async (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_dec_async (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_dec_async (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_dec_async (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_dec_async (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_dec_async (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n Compares vector  <src1>  and  <src2>  element-wisely. If  <src1>  is larger than  <src2> , or the value of  <src1>  is 0, stores the int value  <src2>  in  <src1> ; otherwise, subtracts  <src1>  by 1. Stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  = ( <src1>  == 0 ||  <src1>  >  <src2> ) ?  <src2>  : ( <src1>  - 1). All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n*  <size>  must be greater than zero;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.9. __bang_atomic_exch \n^^^^^^^^^^^^^^^\n void  __bang_atomic_exch (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_exch (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_exch (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_exch (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_exch (half * dst , half * src1 , half  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_exch (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_exch (float * dst , float * src1 , float  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_exch (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_exch (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_exch (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_exch (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n void  __bang_atomic_exch (half * dst , half * src1 ,  const  half * src2 , unsigned int  size )   \n void  __bang_atomic_exch (bfloat16_t * dst , bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_atomic_exch (float * dst , float * src1 ,  const  float * src2 , unsigned int  size )   \n Stores vector  <src1>  in  <dst> . Stores  <src2>  in  <src1> . That is:  <dst>  =  <src1> ;  <src1>  =  <src2> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n*  <size>  must be greater than zero;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.10. __bang_atomic_exch_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_exch_async (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_exch_async (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_exch_async (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_exch_async (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_exch_async (half * dst , half * src1 , half  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_exch_async (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_exch_async (float * dst , float * src1 , float  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_exch_async (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_exch_async (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_exch_async (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_exch_async (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n void  __bang_atomic_exch_async (half * dst , half * src1 ,  const  half * src2 , unsigned int  size )   \n void  __bang_atomic_exch_async (bfloat16_t * dst , bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_atomic_exch_async (float * dst , float * src1 ,  const  float * src2 , unsigned int  size )   \n Stores vector  <src1>  in  <dst> . Stores  <src2>  in  <src1> . That is:  <dst>  =  <src1> ;  <src1>  =  <src2> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n*  <size>  must be greater than zero;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.11. __bang_atomic_inc \n^^^^^^^^^^^^^^^\n void  __bang_atomic_inc (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_inc (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_inc (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_inc (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_inc (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_inc (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_inc (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_inc (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n Compares vector  <src1>  and  <src2>  element-wisely. If  <src1>  is smaller than  <src2> , increases  <src1>  by 1; otherwise, sets  <src1>  to 0. Stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  = ( <src1>  >=  <src2> ) ? 0 : ( <src1>  + 1). All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.12. __bang_atomic_inc_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_inc_async (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_inc_async (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_inc_async (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_inc_async (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_inc_async (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_inc_async (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_inc_async (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_inc_async (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n Compares vector  <src1>  and  <src2>  element-wisely. If  <src1>  is smaller than  <src2> , increases  <src1>  by 1; otherwise, sets  <src1>  to 0. Stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  = ( <src1>  >=  <src2> ) ? 0 : ( <src1>  + 1). All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.13. __bang_atomic_max \n^^^^^^^^^^^^^^^\n void  __bang_atomic_max (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_max (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_max (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_max (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_max (half * dst , half * src1 , half  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_max (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_max (float * dst , float * src1 , float  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_max (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_max (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_max (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_max (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n void  __bang_atomic_max (half * dst , half * src1 ,  const  half * src2 , unsigned int  size )   \n void  __bang_atomic_max (bfloat16_t * dst , bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_atomic_max (float * dst , float * src1 ,  const  float * src2 , unsigned int  size )   \n element-wisely stores the larger value of vector  <src1>  and  <src2>  in  <src1> . Stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  = ( <src1>  >  <src2> ) ?  <src1>  :  <src2> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.14. __bang_atomic_max_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_max_async (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_max_async (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_max_async (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_max_async (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_max_async (half * dst , half * src1 , half  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_max_async (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_max_async (float * dst , float * src1 , float  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_max_async (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_max_async (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_max_async (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_max_async (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n void  __bang_atomic_max_async (half * dst , half * src1 ,  const  half * src2 , unsigned int  size )   \n void  __bang_atomic_max_async (bfloat16_t * dst , bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_atomic_max_async (float * dst , float * src1 ,  const  float * src2 , unsigned int  size )   \n element-wisely stores the larger value of vector  <src1>  and  <src2>  in  <src1> . Stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  = ( <src1>  >  <src2> ) ?  <src1>  :  <src2> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.15. __bang_atomic_min \n^^^^^^^^^^^^^^^\n void  __bang_atomic_min (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_min (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_min (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_min (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_min (half * dst , half * src1 , half  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_min (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_min (float * dst , float * src1 , float  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_min (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_min (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_min (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_min (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n void  __bang_atomic_min (half * dst , half * src1 ,  const  half * src2 , unsigned int  size )   \n void  __bang_atomic_min (bfloat16_t * dst , bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_atomic_min (float * dst , float * src1 ,  const  float * src2 , unsigned int  size )   \n Takes the smaller value from two vector values  <src1>  and  <src2> , and stores it in  <src1> . Stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  = ( <src1>  <  <src2> ) ?  <src1>  :  <src2> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.16. __bang_atomic_min_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_min_async (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_min_async (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_min_async (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_min_async (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_min_async (half * dst , half * src1 , half  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_min_async (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_min_async (float * dst , float * src1 , float  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_min_async (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_min_async (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_min_async (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_min_async (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n void  __bang_atomic_min_async (half * dst , half * src1 ,  const  half * src2 , unsigned int  size )   \n void  __bang_atomic_min_async (bfloat16_t * dst , bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_atomic_min_async (float * dst , float * src1 ,  const  float * src2 , unsigned int  size )   \n Takes the smaller value from two vector values  <src1>  and  <src2> , and stores it in  <src1> . Stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  = ( <src1>  <  <src2> ) ?  <src1>  :  <src2> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.17. __bang_atomic_nan_max \n^^^^^^^^^^^^^^^\n void  __bang_atomic_nan_max (half * dst , half * src1 , half  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_max (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_max (float * dst , float * src1 , float  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_max (half * dst , half * src1 ,  const  half * src2 , unsigned int  size )   \n void  __bang_atomic_nan_max (bfloat16_t * dst , bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_atomic_nan_max (float * dst , float * src1 ,  const  float * src2 , unsigned int  size )   \n element-wisely stores the larger value of vector  <src1>  and  <src2>  in  <src1> . Stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  = ( <src1>  >  <src2> ) ?  <src1>  :  <src2> . If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.18. __bang_atomic_nan_max_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_nan_max_async (half * dst , half * src1 , half  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_max_async (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_max_async (float * dst , float * src1 , float  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_max_async (half * dst , half * src1 ,  const  half * src2 , unsigned int  size )   \n void  __bang_atomic_nan_max_async (bfloat16_t * dst , bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_atomic_nan_max_async (float * dst , float * src1 ,  const  float * src2 , unsigned int  size )   \n element-wisely stores the larger value of vector  <src1>  and  <src2>  in  <src1> . Stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  = ( <src1>  >  <src2> ) ?  <src1>  :  <src2> . If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.19. __bang_atomic_nan_min \n^^^^^^^^^^^^^^^\n void  __bang_atomic_nan_min (half * dst , half * src1 , half  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_min (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_min (float * dst , float * src1 , float  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_min (half * dst , half * src1 ,  const  half * src2 , unsigned int  size )   \n void  __bang_atomic_nan_min (bfloat16_t * dst , bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_atomic_nan_min (float * dst , float * src1 ,  const  float * src2 , unsigned int  size )   \n Takes the smaller value from two vector values  <src1>  and  <src2> , and stores it in  <src1> . Stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  = ( <src1>  <  <src2> ) ?  <src1>  :  <src2> . If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.20. __bang_atomic_nan_min_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_nan_min_async (half * dst , half * src1 , half  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_min_async (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_min_async (float * dst , float * src1 , float  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_min_async (half * dst , half * src1 ,  const  half * src2 , unsigned int  size )   \n void  __bang_atomic_nan_min_async (bfloat16_t * dst , bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_atomic_nan_min_async (float * dst , float * src1 ,  const  float * src2 , unsigned int  size )   \n Takes the smaller value from two vector values  <src1>  and  <src2> , and stores it in  <src1> . Stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  = ( <src1>  <  <src2> ) ?  <src1>  :  <src2> . If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.21. __bang_atomic_number_max \n^^^^^^^^^^^^^^^\n void  __bang_atomic_number_max (half * dst , half * src1 , half  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_number_max (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_number_max (float * dst , float * src1 , float  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_number_max (half * dst , half * src1 ,  const  half * src2 , unsigned int  size )   \n void  __bang_atomic_number_max (bfloat16_t * dst , bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_atomic_number_max (float * dst , float * src1 ,  const  float * src2 , unsigned int  size )   \n element-wisely stores the larger value of vector  <src1>  and  <src2>  in  <src1> . Stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  = ( <src1>  >  <src2> ) ?  <src1>  :  <src2> . If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.22. __bang_atomic_number_max_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_number_max_async (half * dst , half * src1 , half  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_number_max_async (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_number_max_async (float * dst , float * src1 , float  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_number_max_async (half * dst , half * src1 ,  const  half * src2 , unsigned int  size )   \n void  __bang_atomic_number_max_async (bfloat16_t * dst , bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_atomic_number_max_async (float * dst , float * src1 ,  const  float * src2 , unsigned int  size )   \n element-wisely stores the larger value of vector  <src1>  and  <src2>  in  <src1> . Stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  = ( <src1>  >  <src2> ) ?  <src1>  :  <src2> . If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.23. __bang_atomic_number_min \n^^^^^^^^^^^^^^^\n void  __bang_atomic_number_min (half * dst , half * src1 , half  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_number_min (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_number_min (float * dst , float * src1 , float  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_number_min (half * dst , half * src1 ,  const  half * src2 , unsigned int  size )   \n void  __bang_atomic_number_min (bfloat16_t * dst , bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_atomic_number_min (float * dst , float * src1 ,  const  float * src2 , unsigned int  size )   \n Takes the smaller value from two vector values  <src1>  and  <src2> , and stores it in  <src1> . Stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  = ( <src1>  <  <src2> ) ?  <src1>  :  <src2> . If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.24. __bang_atomic_number_min_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_number_min_async (half * dst , half * src1 , half  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_number_min_async (bfloat16_t * dst , bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_number_min_async (float * dst , float * src1 , float  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_number_min_async (half * dst , half * src1 ,  const  half * src2 , unsigned int  size )   \n void  __bang_atomic_number_min_async (bfloat16_t * dst , bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_atomic_number_min_async (float * dst , float * src1 ,  const  float * src2 , unsigned int  size )   \n Takes the smaller value from two vector values  <src1>  and  <src2> , and stores it in  <src1> . Stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  = ( <src1>  <  <src2> ) ?  <src1>  :  <src2> . If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.25. __bang_atomic_or \n^^^^^^^^^^^^^^^\n void  __bang_atomic_or (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_or (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_or (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_or (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_or (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_or (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_or (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_or (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n Applies bitwise OR operation to vector  <src1>  and  <src2> , stores the result in  <src1> , and stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  =  <src1>  |  <src2> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.26. __bang_atomic_or_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_or_async (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_or_async (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_or_async (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_or_async (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_or_async (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_or_async (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_or_async (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_or_async (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n Applies bitwise OR operation to vector  <src1>  and  <src2> , stores the result in  <src1> , and stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  =  <src1>  |  <src2> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.27. __bang_atomic_xor \n^^^^^^^^^^^^^^^\n void  __bang_atomic_xor (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_xor (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_xor (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_xor (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_xor (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_xor (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_xor (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_xor (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n Applies bitwise XOR operation to vector  <src1>  and  <src2> , stores the result in  <src1> , and stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  =  <src1>  ^  <src2> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector;\n*  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.13.28. __bang_atomic_xor_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_xor_async (unsigned short * dst , unsigned short * src1 , unsigned short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_xor_async (short * dst , short * src1 , short  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_xor_async (unsigned int * dst , unsigned int * src1 , unsigned int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_xor_async (int * dst , int * src1 , int  src2 , unsigned int  size  = 1)   \n void  __bang_atomic_xor_async (unsigned short * dst , unsigned short * src1 ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_atomic_xor_async (short * dst , short * src1 ,  const  short * src2 , unsigned int  size )   \n void  __bang_atomic_xor_async (unsigned int * dst , unsigned int * src1 ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_atomic_xor_async (int * dst , int * src1 ,  const  int * src2 , unsigned int  size )   \n Applies bitwise XOR operation to vector  <src1>  and  <src2> , stores the result in  <src1> , and stores the original value of  <src1>  in  <dst> . That is:  <dst>  =  <src1> ;  <src1>  =  <src1>  ^  <src2> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The address of first source vector.\n*  [in] src2 : The second source scalar or the address of second source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src2>  must point to  \\_\\_nram\\_\\_  address space if  <src2>  is a vector;\n*  <src1>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero;\n*  <dst>  can be overlapped with  <src2>  if  <src2>  is a vector;\n* The address of  <src1>  must be  sizeof(type)  aligned. \n Instruction Pipeline * IO. \n"
  },
  {
    "content": "\n 3.14.1. __bang_atomic_nan_reduce_max \n^^^^^^^^^^^^^^^\n void  __bang_atomic_nan_reduce_max (half * dst , half  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_reduce_max (bfloat16_t * dst , bfloat16_t  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_reduce_max (float * dst , float  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_reduce_max (half * dst ,  const  half * src1 , unsigned int  size )   \n void  __bang_atomic_nan_reduce_max (bfloat16_t * dst ,  const  bfloat16_t * src1 , unsigned int  size )   \n void  __bang_atomic_nan_reduce_max (float * dst ,  const  float * src1 , unsigned int  size )   \n Takes the larger value from vector  <dst>  and  <src1> , and stores it in  <dst> . That is:  <dst>  = ( <dst>  >  <src1> ) ?  <dst>  :  <src1> . If one of the elements being compared is a NaN, then NaN is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <dst>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.2. __bang_atomic_nan_reduce_max_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_nan_reduce_max_async (half * dst , half  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_reduce_max_async (bfloat16_t * dst , bfloat16_t  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_reduce_max_async (float * dst , float  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_reduce_max_async (half * dst ,  const  half * src1 , unsigned int  size )   \n void  __bang_atomic_nan_reduce_max_async (bfloat16_t * dst ,  const  bfloat16_t * src1 , unsigned int  size )   \n void  __bang_atomic_nan_reduce_max_async (float * dst ,  const  float * src1 , unsigned int  size )   \n Takes the larger value from vector  <dst>  and  <src1> , and stores it in  <dst> . That is:  <dst>  = ( <dst>  >  <src1> ) ?  <dst>  :  <src1> . If one of the elements being compared is a NaN, then NaN is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <dst>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.3. __bang_atomic_nan_reduce_min \n^^^^^^^^^^^^^^^\n void  __bang_atomic_nan_reduce_min (half * dst , half  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_reduce_min (bfloat16_t * dst , bfloat16_t  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_reduce_min (float * dst , float  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_reduce_min (half * dst ,  const  half * src1 , unsigned int  size )   \n void  __bang_atomic_nan_reduce_min (bfloat16_t * dst ,  const  bfloat16_t * src1 , unsigned int  size )   \n void  __bang_atomic_nan_reduce_min (float * dst ,  const  float * src1 , unsigned int  size )   \n Takes the smaller value from two vector values  <dst>  and  <src1> , and stores it in  <dst> . That is:  <dst>  = ( <dst>  <  <src1> ) ?  <dst>  :  <src1> . If one of the elements being compared is a NaN, then NaN is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.4. __bang_atomic_nan_reduce_min_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_nan_reduce_min_async (half * dst , half  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_reduce_min_async (bfloat16_t * dst , bfloat16_t  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_reduce_min_async (float * dst , float  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_nan_reduce_min_async (half * dst ,  const  half * src1 , unsigned int  size )   \n void  __bang_atomic_nan_reduce_min_async (bfloat16_t * dst ,  const  bfloat16_t * src1 , unsigned int  size )   \n void  __bang_atomic_nan_reduce_min_async (float * dst ,  const  float * src1 , unsigned int  size )   \n Takes the smaller value from two vector values  <dst>  and  <src1> , and stores it in  <dst> . That is:  <dst>  = ( <dst>  <  <src1> ) ?  <dst>  :  <src1> . If one of the elements being compared is a NaN, then NaN is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.5. __bang_atomic_number_reduce_max \n^^^^^^^^^^^^^^^\n void  __bang_atomic_number_reduce_max (half * dst , half  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_number_reduce_max (bfloat16_t * dst , bfloat16_t  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_number_reduce_max (float * dst , float  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_number_reduce_max (half * dst ,  const  half * src1 , unsigned int  size )   \n void  __bang_atomic_number_reduce_max (bfloat16_t * dst ,  const  bfloat16_t * src1 , unsigned int  size )   \n void  __bang_atomic_number_reduce_max (float * dst ,  const  float * src1 , unsigned int  size )   \n Takes the larger value from vector  <dst>  and  <src1> , and stores it in  <dst> . That is:  <dst>  = ( <dst>  >  <src1> ) ?  <dst>  :  <src1> . If one of the elements being compared is a NaN, then the non-NaN element is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <dst>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.6. __bang_atomic_number_reduce_max_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_number_reduce_max_async (half * dst , half  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_number_reduce_max_async (bfloat16_t * dst , bfloat16_t  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_number_reduce_max_async (float * dst , float  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_number_reduce_max_async (half * dst ,  const  half * src1 , unsigned int  size )   \n void  __bang_atomic_number_reduce_max_async (bfloat16_t * dst ,  const  bfloat16_t * src1 , unsigned int  size )   \n void  __bang_atomic_number_reduce_max_async (float * dst ,  const  float * src1 , unsigned int  size )   \n Takes the larger value from vector  <dst>  and  <src1> , and stores it in  <dst> . That is:  <dst>  = ( <dst>  >  <src1> ) ?  <dst>  :  <src1> . If one of the elements being compared is a NaN, then the non-NaN element is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <dst>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.7. __bang_atomic_number_reduce_min \n^^^^^^^^^^^^^^^\n void  __bang_atomic_number_reduce_min (half * dst , half  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_number_reduce_min (bfloat16_t * dst , bfloat16_t  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_number_reduce_min (float * dst , float  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_number_reduce_min (half * dst ,  const  half * src1 , unsigned int  size )   \n void  __bang_atomic_number_reduce_min (bfloat16_t * dst ,  const  bfloat16_t * src1 , unsigned int  size )   \n void  __bang_atomic_number_reduce_min (float * dst ,  const  float * src1 , unsigned int  size )   \n Takes the smaller value from two vector values  <dst>  and  <src1> , and stores it in  <dst> . That is:  <dst>  = ( <dst>  <  <src1> ) ?  <dst>  :  <src1> . If one of the elements being compared is a NaN, then the non-NaN element is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.8. __bang_atomic_number_reduce_min_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_number_reduce_min_async (half * dst , half  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_number_reduce_min_async (bfloat16_t * dst , bfloat16_t  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_number_reduce_min_async (float * dst , float  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_number_reduce_min_async (half * dst ,  const  half * src1 , unsigned int  size )   \n void  __bang_atomic_number_reduce_min_async (bfloat16_t * dst ,  const  bfloat16_t * src1 , unsigned int  size )   \n void  __bang_atomic_number_reduce_min_async (float * dst ,  const  float * src1 , unsigned int  size )   \n Takes the smaller value from two vector values  <dst>  and  <src1> , and stores it in  <dst> . That is:  <dst>  = ( <dst>  <  <src1> ) ?  <dst>  :  <src1> . If one of the elements being compared is a NaN, then the non-NaN element is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.9. __bang_atomic_reduce_add \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_add (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_add (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_add (half * dst , half  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_add (bfloat16_t * dst , bfloat16_t  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_add (float * dst , float  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_add (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_add (int * dst ,  const  int * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_add (half * dst ,  const  half * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_add (bfloat16_t * dst ,  const  bfloat16_t * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_add (float * dst ,  const  float * src1 , unsigned int  size )   \n Increases  <dst>  by  <src1>  element-wisely. That is:  <dst>  =  <dst>  +  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <dst>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^\n \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(short* src1, short src2, int size) {\n  __bang_atomic_reduce_add(src1, src2, size);\n} \n ``` \n"
  },
  {
    "content": "\n 3.14.10. __bang_atomic_reduce_add_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_add_async (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_add_async (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_add_async (half * dst , half  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_add_async (bfloat16_t * dst , bfloat16_t  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_add_async (float * dst , float  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_add_async (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_add_async (int * dst ,  const  int * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_add_async (half * dst ,  const  half * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_add_async (bfloat16_t * dst ,  const  bfloat16_t * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_add_async (float * dst ,  const  float * src1 , unsigned int  size )   \n Increases  <dst>  by  <src1>  element-wisely. That is:  <dst>  =  <dst>  +  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <dst>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^\n \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(short* src1, short src2, int size) {\n  __bang_atomic_reduce_add_async(src1, src2, size);\n} \n ``` \n"
  },
  {
    "content": "\n 3.14.11. __bang_atomic_reduce_and \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_and (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_and (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_and (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_and (int * dst ,  const  int * src1 , unsigned int  size )   \n Applies bitwise AND operation to the vector  <dst>  and  <src1> , and stores the result in  <dst> . That is:  <dst>  =  <dst>  &  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero;\n* The address of  <dst>  must be  sizeof(type)  aligned. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.12. __bang_atomic_reduce_and_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_and_async (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_and_async (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_and_async (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_and_async (int * dst ,  const  int * src1 , unsigned int  size )   \n Applies bitwise AND operation to the vector  <dst>  and  <src1> , and stores the result in  <dst> . That is:  <dst>  =  <dst>  &  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero;\n* The address of  <dst>  must be  sizeof(type)  aligned. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.13. __bang_atomic_reduce_cas \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_cas (short * dst , short  src1 , short  src2 )   \n void  __bang_atomic_reduce_cas (half * dst , half  src1 , half  src2 )   \n void  __bang_atomic_reduce_cas (float * dst , float  src1 , float  src2 )   \n void  __bang_atomic_reduce_cas (bfloat16_t * dst , bfloat16_t  src1 , bfloat16_t  src2 )   \n void  __bang_atomic_reduce_cas (int * dst , int  src1 , int  src2 )   \n If  <src1>  is equal to  <\\*dst> , stores  <src2>  in  <dst> . That is:  <\\*dst>  = ( <\\*dst>  ==  <src1> ) ?  <src2>  :  <\\*dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1 : The first operand.\n*  [in] src2 : The second operand. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * This function only operates on one element;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <dst>  must be  sizeof(type)  aligned. \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^\n \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(int* dst, int src1, int src2) {\n  __bang_atomic_reduce_cas(dst, src1, src2);\n} \n ``` \n"
  },
  {
    "content": "\n 3.14.14. __bang_atomic_reduce_cas_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_cas_async (short * dst , short  src1 , short  src2 )   \n void  __bang_atomic_reduce_cas_async (half * dst , half  src1 , half  src2 )   \n void  __bang_atomic_reduce_cas_async (float * dst , float  src1 , float  src2 )   \n void  __bang_atomic_reduce_cas_async (bfloat16_t * dst , bfloat16_t  src1 , bfloat16_t  src2 )   \n void  __bang_atomic_reduce_cas_async (int * dst , int  src1 , int  src2 )   \n If  <src1>  is equal to  <\\*dst> , stores  <src2>  in  <dst> . That is:  <\\*dst>  = ( <\\*dst>  ==  <src1> ) ?  <src2>  :  <\\*dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1 : The first operand.\n*  [in] src2 : The second operand. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * This function only operates on one element;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <dst>  must be  sizeof(type)  aligned. \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^\n \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(int* dst, int src1, int src2) {\n  __bang_atomic_reduce_cas_async(dst, src1, src2);\n} \n ``` \n"
  },
  {
    "content": "\n 3.14.15. __bang_atomic_reduce_dec \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_dec (unsigned short * dst , unsigned short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_dec (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_dec (unsigned int * dst , unsigned int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_dec (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_dec (unsigned short * dst ,  const  unsigned short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_dec (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_dec (unsigned int * dst ,  const  unsigned int * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_dec (int * dst ,  const  int * src1 , unsigned int  size )   \n Compares vector  <dst>  and  <src1> . If  <dst>  is larger than  <src1> , or the value of  <dst>  is 0, stores the int value  <src1>  in  <dst> ; otherwise, reduces  <dst>  by 1. That is:  <dst>  = ( <dst>  == 0 ||  <dst>  >  <src1> ) ?  <src1>  : ( <dst>  - 1). \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero;\n* The address of  <dst>  must be  sizeof(type)  aligned. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.16. __bang_atomic_reduce_dec_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_dec_async (unsigned short * dst , unsigned short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_dec_async (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_dec_async (unsigned int * dst , unsigned int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_dec_async (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_dec_async (unsigned short * dst ,  const  unsigned short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_dec_async (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_dec_async (unsigned int * dst ,  const  unsigned int * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_dec_async (int * dst ,  const  int * src1 , unsigned int  size )   \n Compares vector  <dst>  and  <src1> . If  <dst>  is larger than  <src1> , or the value of  <dst>  is 0, stores the int value  <src1>  in  <dst> ; otherwise, reduces  <dst>  by 1. That is:  <dst>  = ( <dst>  == 0 ||  <dst>  >  <src1> ) ?  <src1>  : ( <dst>  - 1). \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero;\n* The address of  <dst>  must be  sizeof(type)  aligned. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.17. __bang_atomic_reduce_exch \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_exch (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_exch (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_exch (half * dst , half  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_exch (bfloat16_t * dst , bfloat16_t  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_exch (float * dst , float  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_exch (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_exch (int * dst ,  const  int * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_exch (half * dst ,  const  half * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_exch (bfloat16_t * dst ,  const  bfloat16_t * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_exch (float * dst ,  const  float * src1 , unsigned int  size )   \n Stores  <src1>  in  <dst> . That is:  <dst>  =  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero;\n* The address of  <dst>  must be  sizeof(type)  aligned;\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.18. __bang_atomic_reduce_exch_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_exch_async (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_exch_async (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_exch_async (half * dst , half  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_exch_async (bfloat16_t * dst , bfloat16_t  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_exch_async (float * dst , float  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_exch_async (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_exch_async (int * dst ,  const  int * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_exch_async (half * dst ,  const  half * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_exch_async (bfloat16_t * dst ,  const  bfloat16_t * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_exch_async (float * dst ,  const  float * src1 , unsigned int  size )   \n Stores  <src1>  in  <dst> . That is:  <dst>  =  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero;\n* The address of  <dst>  must be  sizeof(type)  aligned;\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.19. __bang_atomic_reduce_inc \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_inc (unsigned short * dst , unsigned short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_inc (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_inc (unsigned int * dst , unsigned int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_inc (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_inc (unsigned short * dst ,  const  unsigned short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_inc (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_inc (unsigned int * dst ,  const  unsigned int * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_inc (int * dst ,  const  int * src1 , unsigned int  size )   \n Compares vector  <dst>  and  <src1> . If  <dst>  is smaller than  <src1> , increases  <dst>  by 1; otherwise, sets  <dst>  to 0. That is:  <dst>  = ( <dst>  >=  <src1> ) ? 0 : ( <dst>  + 1). \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero;\n* The address of  <dst>  must be  sizeof(type)  aligned. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.20. __bang_atomic_reduce_inc_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_inc_async (unsigned short * dst , unsigned short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_inc_async (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_inc_async (unsigned int * dst , unsigned int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_inc_async (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_inc_async (unsigned short * dst ,  const  unsigned short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_inc_async (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_inc_async (unsigned int * dst ,  const  unsigned int * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_inc_async (int * dst ,  const  int * src1 , unsigned int  size )   \n Compares vector  <dst>  and  <src1> . If  <dst>  is smaller than  <src1> , increases  <dst>  by 1; otherwise, sets  <dst>  to 0. That is:  <dst>  = ( <dst>  >=  <src1> ) ? 0 : ( <dst>  + 1). \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero;\n* The address of  <dst>  must be  sizeof(type)  aligned. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.21. __bang_atomic_reduce_max \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_max (unsigned short * dst , unsigned short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_max (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_max (unsigned int * dst , unsigned int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_max (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_max (half * dst , half  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_max (bfloat16_t * dst , bfloat16_t  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_max (float * dst , float  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_max (unsigned short * dst ,  const  unsigned short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_max (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_max (unsigned int * dst ,  const  unsigned int * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_max (int * dst ,  const  int * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_max (half * dst ,  const  half * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_max (bfloat16_t * dst ,  const  bfloat16_t * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_max (float * dst ,  const  float * src1 , unsigned int  size )   \n Takes the larger value from vector  <dst>  and  <src1> , and stores it in  <dst> . That is:  <dst>  = ( <dst>  >  <src1> ) ?  <dst>  :  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <dst>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.22. __bang_atomic_reduce_max_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_max_async (unsigned short * dst , unsigned short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_max_async (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_max_async (unsigned int * dst , unsigned int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_max_async (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_max_async (half * dst , half  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_max_async (bfloat16_t * dst , bfloat16_t  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_max_async (float * dst , float  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_max_async (unsigned short * dst ,  const  unsigned short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_max_async (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_max_async (unsigned int * dst ,  const  unsigned int * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_max_async (int * dst ,  const  int * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_max_async (half * dst ,  const  half * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_max_async (bfloat16_t * dst ,  const  bfloat16_t * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_max_async (float * dst ,  const  float * src1 , unsigned int  size )   \n Takes the larger value from vector  <dst>  and  <src1> , and stores it in  <dst> . That is:  <dst>  = ( <dst>  >  <src1> ) ?  <dst>  :  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <dst>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.23. __bang_atomic_reduce_min \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_min (unsigned short * dst , unsigned short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_min (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_min (unsigned int * dst , unsigned int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_min (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_min (half * dst , half  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_min (bfloat16_t * dst , bfloat16_t  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_min (float * dst , float  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_min (unsigned short * dst ,  const  unsigned short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_min (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_min (unsigned int * dst ,  const  unsigned int * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_min (int * dst ,  const  int * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_min (half * dst ,  const  half * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_min (bfloat16_t * dst ,  const  bfloat16_t * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_min (float * dst ,  const  float * src1 , unsigned int  size )   \n Takes the smaller value from two vector values  <dst>  and  <src1> , and stores it in  <dst> . That is:  <dst>  = ( <dst>  <  <src1> ) ?  <dst>  :  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.24. __bang_atomic_reduce_min_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_min_async (unsigned short * dst , unsigned short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_min_async (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_min_async (unsigned int * dst , unsigned int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_min_async (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_min_async (half * dst , half  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_min_async (bfloat16_t * dst , bfloat16_t  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_min_async (float * dst , float  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_min_async (unsigned short * dst ,  const  unsigned short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_min_async (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_min_async (unsigned int * dst ,  const  unsigned int * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_min_async (int * dst ,  const  int * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_min_async (half * dst ,  const  half * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_min_async (bfloat16_t * dst ,  const  bfloat16_t * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_min_async (float * dst ,  const  float * src1 , unsigned int  size )   \n Takes the smaller value from two vector values  <dst>  and  <src1> , and stores it in  <dst> . That is:  <dst>  = ( <dst>  <  <src1> ) ?  <dst>  :  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1>  must be  sizeof(type)  aligned;\n*  <size>  must be greater than zero;\n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.25. __bang_atomic_reduce_or \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_or (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_or (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_or (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_or (int * dst ,  const  int * src1 , unsigned int  size )   \n Applies bitwise OR operation to vector  <dst>  and  <src1> , and stores the result in  <dst> . That is:  <dst>  =  <dst>  |  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero;\n* The address of  <dst>  must be  sizeof(type)  aligned. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.26. __bang_atomic_reduce_or_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_or_async (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_or_async (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_or_async (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_or_async (int * dst ,  const  int * src1 , unsigned int  size )   \n Applies bitwise OR operation to vector  <dst>  and  <src1> , and stores the result in  <dst> . That is:  <dst>  =  <dst>  |  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero;\n* The address of  <dst>  must be  sizeof(type)  aligned. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.27. __bang_atomic_reduce_xor \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_xor (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_xor (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_xor (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_xor (int * dst ,  const  int * src1 , unsigned int  size )   \n Applies bitwise XOR operation to vector  <dst>  and  <src1> , and stores the result in  <dst> . That is:  <dst>  =  <dst>  ^  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero;\n* The address of  <dst>  must be  sizeof(type)  aligned. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.14.28. __bang_atomic_reduce_xor_async \n^^^^^^^^^^^^^^^\n void  __bang_atomic_reduce_xor_async (short * dst , short  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_xor_async (int * dst , int  src1 , unsigned int  size  = 1)   \n void  __bang_atomic_reduce_xor_async (short * dst ,  const  short * src1 , unsigned int  size )   \n void  __bang_atomic_reduce_xor_async (int * dst ,  const  int * src1 , unsigned int  size )   \n Applies bitwise XOR operation to vector  <dst>  and  <src1> , and stores the result in  <dst> . That is:  <dst>  =  <dst>  ^  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src1 : The first source scalar or the address of first source vector.\n*  [in] size : The elements number of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src1>  must point to  \\_\\_nram\\_\\_  address space if  <src1>  is a vector;\n*  <dst>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero;\n* The address of  <dst>  must be  sizeof(type)  aligned. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.15.1. __bang_printf \n^^^^^^^^^^^^^^^\n int  __bang_printf ( const  char * fmt , ...)   \n Similar to standard printf function, prints arguments to screen, formatted by the format string. \n^^^^^^^^^^^^^^^\n Parameters *  [in] fmt : The format string, which must be a literal constant string. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <fmt>  must be a literal constant string;\n* This function can at most accept 17 parameters including the format string;\n* The type of parameters can be different. It must be one of: char, unsigned char, short, unsigned short, int, unsigned int, half, float, char, bool, pointer;\n* Since this function involves extremely time-consuming interaction between CPU and MLU, it might cause significant performance degradation. \n Instruction Pipeline * NA. "
  },
  {
    "content": "\n 3.16.1. __bang_discrete_atomic_add \n^^^^^^^^^^^^^^^\n void  __bang_discrete_atomic_add (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_add (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_add (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_add (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_add (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_add (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_add (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_add (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_add (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_add (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_add (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_add (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_add (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_add (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_add (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_add (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_add (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_add (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_add (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_add (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_add (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_add (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_add (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_add (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_add (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_add (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_add (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_add (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_add (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_add (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n Computes the discrete  <src1>  addresses by adding offsets stored in  <src1\\_offset>  to  <src1\\_base> . Adds  <src2>  to the values in discrete  <src1>  addresses. Stores the original values in discrete  <src1>  addresses in  <dst> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1\\_base : The base address of the first operand.\n*  [in] src1\\_offset : The address of the offsets of the first operand.\n*  [in] src2 : The second operand.\n*  [in] mask : The address of mask.\n*  [in] size : The number of elements to be computed. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n* The address of  <src1\\_base>  must be  sizeof(type)  aligned;\n*  <src1\\_base>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <dst> ,  <src1\\_offset> ,  <src2>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* The offsets stored in  <src1\\_offset>  are in bytes, and must be  sizeof(type)  aligned;\n*  <mask>  has  <size>  effective bits, and each bit controls if atomic add is performed on the corresponding element. If no  <mask>  is given, all elements are computed. \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(short* acc, char* offset, short* src2, int* mask) {\n  __nram__ short v[128];\n  __nram__ char offset_nram[128];\n  __nram__ short src2_nram[128];\n  __nram__ int mask_nram[128 / sizeof(int) / 8];\n  __memcpy(offset_nram, offset, 128 * sizeof(char), GDRAM2NRAM);\n  __memcpy(src2_nram, src2, 128 * sizeof(short), GDRAM2NRAM);\n  __memcpy(mask_nram, mask, 128 / 8, GDRAM2NRAM);\n  __bang_discrete_atomic_add(v, acc, offset_nram, src2_nram, mask_nram, 128);\n} \n ``` \n"
  },
  {
    "content": "\n 3.16.2. __bang_discrete_atomic_and \n^^^^^^^^^^^^^^^\n void  __bang_discrete_atomic_and (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_and (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_and (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_and (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_and (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_and (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_and (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_and (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_and (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_and (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_and (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_and (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n Computes the discrete  <src1>  addresses by adding offsets stored in  <src1\\_offset>  to  <src1\\_base> . Performs bitwise AND on the values in discrete  <src1>  addresses with  <src2>  respectively. Stores the original values in discrete  <src1>  addresses in  <dst> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1\\_base : The base address of the first operand.\n*  [in] src1\\_offset : The address of the offsets of the first operand.\n*  [in] src2 : The second operand.\n*  [in] mask : The address of mask.\n*  [in] size : The number of elements to be computed. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n*  <src1\\_base>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1\\_base>  must be  sizeof(type)  aligned;\n*  <dst> ,  <src1\\_offset> ,  <src2>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* The offsets stored in  <src1\\_offset>  are in bytes, and must be  sizeof(type)  aligned;\n*  <mask>  has  <size>  effective bits, and each bit controls if atomic bitwise AND is performed on the corresponding element. If no  <mask>  is given, all elements are computed. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.16.3. __bang_discrete_atomic_cas \n^^^^^^^^^^^^^^^\n void  __bang_discrete_atomic_cas (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 , short  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 , short  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 , short  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 , int  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 , int  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 , int  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 , half  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 , half  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 , half  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 , float  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 , float  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 , float  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 , bfloat16_t  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 , bfloat16_t  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 , bfloat16_t  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 ,  const  void * mask , short  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 ,  const  void * mask , short  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 ,  const  void * mask , short  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 ,  const  void * mask , int  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 ,  const  void * mask , int  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 ,  const  void * mask , int  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 ,  const  void * mask , half  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 ,  const  void * mask , half  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 ,  const  void * mask , half  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 ,  const  void * mask , float  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 ,  const  void * mask , float  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 ,  const  void * mask , float  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , bfloat16_t  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , bfloat16_t  src3 , unsigned int  size )   \n void  __bang_discrete_atomic_cas (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , bfloat16_t  src3 , unsigned int  size )   \n Computes the discrete  <src1>  addresses by adding offsets stored in  <src1\\_offset>  to  <src1\\_base> . Stores the values in  <src2>  in discrete  <src1>  addresses respectively if they are equal to  <src3> . Stores the original values in discrete  <src1>  addresses in  <dst> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1\\_base : The base address of the first operand.\n*  [in] src1\\_offset : The address of the offsets of the first operand.\n*  [in] src2 : The second operand.\n*  [in] mask : The address of mask.\n*  [in] src3 : The third operand.\n*  [in] size : The number of elements to be computed. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n*  <src1\\_base>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1\\_base>  must be  sizeof(type)  aligned;\n*  <dst> ,  <src1\\_offset> ,  <src2>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* The offsets stored in  <src1\\_offset>  are in bytes, and must be  sizeof(type)  aligned;\n*  <mask>  has  <size>  effective bits, and each bit controls if atomic compare-and-swap is performed on the corresponding element. If no  <mask>  is given, all elements are computed. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.16.4. __bang_discrete_atomic_dec \n^^^^^^^^^^^^^^^\n void  __bang_discrete_atomic_dec (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_dec (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_dec (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_dec (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned char * src1_offset ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_dec (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned short * src1_offset ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_dec (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned int * src1_offset ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_dec (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_dec (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_dec (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_dec (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned char * src1_offset ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_dec (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned short * src1_offset ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_dec (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned int * src1_offset ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_dec (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_dec (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_dec (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_dec (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned char * src1_offset ,  const  unsigned short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_dec (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned short * src1_offset ,  const  unsigned short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_dec (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned int * src1_offset ,  const  unsigned short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_dec (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_dec (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_dec (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_dec (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned char * src1_offset ,  const  unsigned int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_dec (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned short * src1_offset ,  const  unsigned int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_dec (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned int * src1_offset ,  const  unsigned int * src2 ,  const  void * mask , unsigned int  size )   \n Computes the discrete  <src1>  addresses by adding offsets stored in  <src1\\_offset>  to  <src1\\_base> . Decrements the values in discrete  <src1>  addresses by 1 if they are not greater than the corresponding values in  <src2>  and not equal to 0; otherwise, sets them to the corresponding values in  <src2> . Stores the original values in discrete  <src1>  addresses in  <dst> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1\\_base : The base address of the first operand.\n*  [in] src1\\_offset : The address of the offsets of the first operand.\n*  [in] src2 : The second operand.\n*  [in] mask : The address of mask.\n*  [in] size : The number of elements to be computed. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n*  <src1\\_base>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1\\_base>  must be  sizeof(type)  aligned;\n*  <dst> ,  <src1\\_offset> ,  <src2>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* The offsets stored in  <src1\\_offset>  are in bytes, and must be  sizeof(type)  aligned;\n*  <mask>  has  <size>  effective bits, and each bit controls if atomic decrement is performed on the corresponding element. If no  <mask>  is given, all elements are computed. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.16.5. __bang_discrete_atomic_exch \n^^^^^^^^^^^^^^^\n void  __bang_discrete_atomic_exch (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_exch (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_exch (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_exch (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_exch (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_exch (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_exch (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_exch (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_exch (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_exch (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_exch (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_exch (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_exch (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_exch (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_exch (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_exch (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_exch (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_exch (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_exch (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_exch (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_exch (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_exch (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_exch (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_exch (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_exch (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_exch (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_exch (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_exch (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_exch (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_exch (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n Computes the discrete  <src1>  addresses by adding offsets stored in  <src1\\_offset>  to  <src1\\_base> . Stores the values in  <src2>  in discrete  <src1>  addresses respectively. Stores the original values in discrete  <src1>  addresses in  <dst> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1\\_base : The base address of the first operand.\n*  [in] src1\\_offset : The address of the offsets of first operand.\n*  [in] src2 : The second operand.\n*  [in] mask : The address of mask.\n*  [in] size : The number of elements to be computed. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n*  <src1\\_base>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1\\_base>  must be  sizeof(type)  aligned;\n*  <dst> ,  <src1\\_offset> ,  <src2>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* The offsets stored in  <src1\\_offset>  are in bytes, and must be  sizeof(type)  aligned;\n*  <mask>  has  <size>  effective bits, and each bit controls if atomic exchange is performed on the corresponding element. If no  <mask>  is given, all elements are computed. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.16.6. __bang_discrete_atomic_inc \n^^^^^^^^^^^^^^^\n void  __bang_discrete_atomic_inc (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_inc (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_inc (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_inc (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned char * src1_offset ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_inc (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned short * src1_offset ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_inc (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned int * src1_offset ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_inc (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_inc (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_inc (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_inc (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned char * src1_offset ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_inc (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned short * src1_offset ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_inc (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned int * src1_offset ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_inc (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_inc (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_inc (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_inc (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned char * src1_offset ,  const  unsigned short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_inc (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned short * src1_offset ,  const  unsigned short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_inc (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned int * src1_offset ,  const  unsigned short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_inc (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_inc (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_inc (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_inc (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned char * src1_offset ,  const  unsigned int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_inc (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned short * src1_offset ,  const  unsigned int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_inc (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned int * src1_offset ,  const  unsigned int * src2 ,  const  void * mask , unsigned int  size )   \n Computes the discrete  <src1>  addresses by adding offsets stored in  <src1\\_offset>  to  <src1\\_base> . Increments the values in discrete  <src1>  addresses by 1 if they are smaller than the corresponding values in  <src2> ; otherwise, sets them to 0. Stores the original values in discrete  <src1>  addresses in  <dst> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1\\_base : The base address of the first operand.\n*  [in] src1\\_offset : The address of the offsets of the first operand.\n*  [in] src2 : The second operand.\n*  [in] mask : The address of mask.\n*  [in] size : The number of elements to be computed. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n*  <src1\\_base>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1\\_base>  must be  sizeof(type)  aligned;\n*  <dst> ,  <src1\\_offset> ,  <src2>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* The offsets stored in  <src1\\_offset>  are in bytes, and must be  sizeof(type)  aligned;\n*  <mask>  has  <size>  effective bits, and each bit controls if atomic increment is performed on the corresponding element. If no  <mask>  is given, all elements are computed. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.16.7. __bang_discrete_atomic_max \n^^^^^^^^^^^^^^^\n void  __bang_discrete_atomic_max (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned char * src1_offset ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned short * src1_offset ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned int * src1_offset ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned char * src1_offset ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned short * src1_offset ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned int * src1_offset ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_max (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned char * src1_offset ,  const  unsigned short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned short * src1_offset ,  const  unsigned short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned int * src1_offset ,  const  unsigned short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned char * src1_offset ,  const  unsigned int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned short * src1_offset ,  const  unsigned int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned int * src1_offset ,  const  unsigned int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n Computes the discrete  <src1>  addresses by adding offsets stored in  <src1\\_offset>  to  <src1\\_base> . Sets the values in discrete  <src1>  addresses to the greater values between the original values and the corresponding values in  <src2> . Stores the original values in discrete  <src1>  addresses in  <dst> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1\\_base : The base address of the first operand.\n*  [in] src1\\_offset : The address of the offsets of the first operand.\n*  [in] src2 : The second operand.\n*  [in] mask : The address of mask.\n*  [in] size : The number of elements to be computed. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n*  <src1\\_base>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1\\_base>  must be  sizeof(type)  aligned;\n*  <dst> ,  <src1\\_offset> ,  <src2>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* The offsets stored in  <src1\\_offset>  are in bytes, and must be  sizeof(type)  aligned;\n*  <mask>  has  <size>  effective bits, and each bit controls if atomic maximum is performed on the corresponding element. If no  <mask>  is given, all elements are computed. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.16.8. __bang_discrete_atomic_min \n^^^^^^^^^^^^^^^\n void  __bang_discrete_atomic_min (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned char * src1_offset ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned short * src1_offset ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned int * src1_offset ,  const  unsigned short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned char * src1_offset ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned short * src1_offset ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned int * src1_offset ,  const  unsigned int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_min (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned char * src1_offset ,  const  unsigned short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned short * src1_offset ,  const  unsigned short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (unsigned short * dst ,  const  unsigned short * src1_base ,  const  unsigned int * src1_offset ,  const  unsigned short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned char * src1_offset ,  const  unsigned int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned short * src1_offset ,  const  unsigned int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (unsigned int * dst ,  const  unsigned int * src1_base ,  const  unsigned int * src1_offset ,  const  unsigned int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n Computes the discrete  <src1>  addresses by adding offsets stored in  <src1\\_offset>  to  <src1\\_base> . Sets the values in discrete  <src1>  addresses to the smaller values between the original values and the corresponding values in  <src2> . Stores the original values in discrete  <src1>  addresses in  <dst> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1\\_base : The base address of the first operand.\n*  [in] src1\\_offset : The address of the offsets of the first operand.\n*  [in] src2 : The second operand.\n*  [in] mask : The address of mask.\n*  [in] size : The number of elements to be computed. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n*  <src1\\_base>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1\\_base>  must be  sizeof(type)  aligned;\n*  <dst> ,  <src1\\_offset> ,  <src2>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* The offsets stored in  <src1\\_offset>  are in bytes, and must be  sizeof(type)  aligned;\n*  <mask>  has  <size>  effective bits, and each bit controls if atomic minimum is performed on the corresponding element. If no  <mask>  is given, all elements are computed. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.16.9. __bang_discrete_atomic_nan_max \n^^^^^^^^^^^^^^^\n void  __bang_discrete_atomic_nan_max (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_nan_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n Computes the discrete  <src1>  addresses by adding offsets stored in  <src1\\_offset>  to  <src1\\_base> . Sets the values in discrete  <src1>  addresses to the greater values between the original values and the corresponding values in  <src2> . Stores the original values in discrete  <src1>  addresses in  <dst> . If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1\\_base : The base address of the first operand.\n*  [in] src1\\_offset : The address of the offsets of the first operand.\n*  [in] src2 : The second operand.\n*  [in] mask : The address of mask.\n*  [in] size : The number of elements to be computed. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n*  <src1\\_base>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1\\_base>  must be  sizeof(type)  aligned;\n*  <dst> ,  <src1\\_offset> ,  <src2>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* The offsets stored in  <src1\\_offset>  are in bytes, and must be  sizeof(type)  aligned;\n*  <mask>  has  <size>  effective bits, and each bit controls if atomic maximum is performed on the corresponding element. If no  <mask>  is given, all elements are computed. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.16.10. __bang_discrete_atomic_nan_min \n^^^^^^^^^^^^^^^\n void  __bang_discrete_atomic_nan_min (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_nan_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n Computes the discrete  <src1>  addresses by adding offsets stored in  <src1\\_offset>  to  <src1\\_base> . Sets the values in discrete  <src1>  addresses to the smaller values between the original values and the corresponding values in  <src2> . Stores the original values in discrete  <src1>  addresses in  <dst> . If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1\\_base : The base address of the first operand.\n*  [in] src1\\_offset : The address of the offsets of the first operand.\n*  [in] src2 : The second operand.\n*  [in] mask : The address of mask.\n*  [in] size : The number of elements to be computed. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n*  <src1\\_base>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1\\_base>  must be  sizeof(type)  aligned;\n*  <dst> ,  <src1\\_offset> ,  <src2>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* The offsets stored in  <src1\\_offset>  are in bytes, and must be  sizeof(type)  aligned;\n*  <mask>  has  <size>  effective bits, and each bit controls if atomic minimum is performed on the corresponding element. If no  <mask>  is given, all elements are computed. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.16.11. __bang_discrete_atomic_number_max \n^^^^^^^^^^^^^^^\n void  __bang_discrete_atomic_number_max (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_number_max (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n Computes the discrete  <src1>  addresses by adding offsets stored in  <src1\\_offset>  to  <src1\\_base> . Sets the values in discrete  <src1>  addresses to the greater values between the original values and the corresponding values in  <src2> . Stores the original values in discrete  <src1>  addresses in  <dst> . If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1\\_base : The base address of the first operand.\n*  [in] src1\\_offset : The address of the offsets of the first operand.\n*  [in] src2 : The second operand.\n*  [in] mask : The address of mask.\n*  [in] size : The number of elements to be computed. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n*  <src1\\_base>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1\\_base>  must be  sizeof(type)  aligned;\n*  <dst> ,  <src1\\_offset> ,  <src2>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* The offsets stored in  <src1\\_offset>  are in bytes, and must be  sizeof(type)  aligned;\n*  <mask>  has  <size>  effective bits, and each bit controls if atomic maximum is performed on the corresponding element. If no  <mask>  is given, all elements are computed. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.16.12. __bang_discrete_atomic_number_min \n^^^^^^^^^^^^^^^\n void  __bang_discrete_atomic_number_min (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (half * dst ,  const  half * src1_base ,  const  unsigned char * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (half * dst ,  const  half * src1_base ,  const  unsigned short * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (half * dst ,  const  half * src1_base ,  const  unsigned int * src1_offset ,  const  half * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (float * dst ,  const  float * src1_base ,  const  unsigned char * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (float * dst ,  const  float * src1_base ,  const  unsigned short * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (float * dst ,  const  float * src1_base ,  const  unsigned int * src1_offset ,  const  float * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned char * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned short * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_number_min (bfloat16_t * dst ,  const  bfloat16_t * src1_base ,  const  unsigned int * src1_offset ,  const  bfloat16_t * src2 ,  const  void * mask , unsigned int  size )   \n Computes the discrete  <src1>  addresses by adding offsets stored in  <src1\\_offset>  to  <src1\\_base> . Sets the values in discrete  <src1>  addresses to the smaller values between the original values and the corresponding values in  <src2> . Stores the original values in discrete  <src1>  addresses in  <dst> . If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1\\_base : The base address of the first operand.\n*  [in] src1\\_offset : The address of the offsets of the first operand.\n*  [in] src2 : The second operand.\n*  [in] mask : The address of mask.\n*  [in] size : The number of elements to be computed. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n*  <src1\\_base>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1\\_base>  must be  sizeof(type)  aligned;\n*  <dst> ,  <src1\\_offset> ,  <src2>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* The offsets stored in  <src1\\_offset>  are in bytes, and must be  sizeof(type)  aligned;\n*  <mask>  has  <size>  effective bits, and each bit controls if atomic minimum is performed on the corresponding element. If no  <mask>  is given, all elements are computed. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.16.13. __bang_discrete_atomic_or \n^^^^^^^^^^^^^^^\n void  __bang_discrete_atomic_or (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_or (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_or (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_or (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_or (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_or (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_or (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_or (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_or (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_or (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_or (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_or (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n Computes the discrete  <src1>  addresses by adding offsets stored in  <src1\\_offset>  to  <src1\\_base> . Performs bitwise OR on the values in discrete  <src1>  addresses with  <src2>  respectively. Stores the original values in discrete  <src1>  addresses in  <dst> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1\\_base : The base address of the first operand.\n*  [in] src1\\_offset : The address of the offsets of the first operand.\n*  [in] src2 : The second operand.\n*  [in] mask : The address of mask.\n*  [in] size : The number of elements to be computed. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n*  <src1\\_base>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1\\_base>  must be  sizeof(type)  aligned;\n*  <dst> ,  <src1\\_offset> ,  <src2>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* The offsets stored in  <src1\\_offset>  are in bytes, and must be  sizeof(type)  aligned;\n*  <mask>  has  <size>  effective bits, and each bit controls if atomic bitwise OR is performed on the corresponding element. If no  <mask>  is given, all elements are computed. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.16.14. __bang_discrete_atomic_xor \n^^^^^^^^^^^^^^^\n void  __bang_discrete_atomic_xor (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_xor (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_xor (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_xor (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_xor (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_xor (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 , unsigned int  size )   \n void  __bang_discrete_atomic_xor (short * dst ,  const  short * src1_base ,  const  unsigned char * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_xor (short * dst ,  const  short * src1_base ,  const  unsigned short * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_xor (short * dst ,  const  short * src1_base ,  const  unsigned int * src1_offset ,  const  short * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_xor (int * dst ,  const  int * src1_base ,  const  unsigned char * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_xor (int * dst ,  const  int * src1_base ,  const  unsigned short * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n void  __bang_discrete_atomic_xor (int * dst ,  const  int * src1_base ,  const  unsigned int * src1_offset ,  const  int * src2 ,  const  void * mask , unsigned int  size )   \n Computes the discrete  <src1>  addresses by adding offsets stored in  <src1\\_offset>  to  <src1\\_base> . Performs bitwise XOR on the values in discrete  <src1>  addresses with  <src2>  respectively. Stores the original values in discrete  <src1>  addresses in  <dst> . All steps are inseparable. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination operand.\n*  [in] src1\\_base : The base address of the first operand.\n*  [in] src1\\_offset : The address of the offsets of the first operand.\n*  [in] src2 : The second operand.\n*  [in] mask : The address of mask.\n*  [in] size : The number of elements to be computed. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n*  <src1\\_base>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n* The address of  <src1\\_base>  must be  sizeof(type)  aligned;\n*  <dst> ,  <src1\\_offset> ,  <src2>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* The offsets stored in  <src1\\_offset>  are in bytes, and must be  sizeof(type)  aligned;\n*  <mask>  has  <size>  effective bits, and each bit controls if atomic bitwise XOR is performed on the corresponding element. If no  <mask>  is given, all elements are computed. \n Instruction Pipeline * IO. "
  },
  {
    "content": "\n 3.17.1. __gather \n^^^^^^^^^^^^^^^\n void  __gather (void * dst ,  const  void * src ,  const  unsigned char * offset , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __gather (void * dst ,  const  void * src ,  const  unsigned short * offset , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __gather (void * dst ,  const  void * src ,  const  unsigned int * offset , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __gather (void * dst ,  const  void * src ,  const  unsigned char * offset ,  const  void * mask , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __gather (void * dst ,  const  void * src ,  const  unsigned short * offset ,  const  void * mask , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __gather (void * dst ,  const  void * src ,  const  unsigned int * offset ,  const  void * mask , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n Move discrete data segments in  <src>  to  <dst>  with stride. \n As shown in Figure Discrete Vector Gather Function , the cells with blue background indicate the data to be copied. \n Fig. 3.5 Discrete Vector Gather Function \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The destination vector.\n*  [in] src : The source vector.\n*  [in] offset : The offsets between the segments in  <src>  and the beginning of  <src>  in bytes.\n*  [in] mask : The source mask vector.\n*  [in] transfer\\_size : The size of single segment of  <src>  in bytes.\n*  [in] dir : Transport direction.\n*  [in] stride : The stride of adjacent segments in  <dst>  in bytes.\n*  [in] transfer\\_num : The number of segments in  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <offset>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* Each data transfer corresponds to a bit in  <mask>  while has  <mask>  in parameters, if the value of bit is 1, a data transfer occurs, otherwise, it does not;\n* The address of  <src>  is recommended to be 64-byte aligned to get better performance;\n* The address of  <mask>  is recommended to be 32-byte aligned to get better performance;\n* If the space of  <dst>  is in  wram ,  <transfer\\_size>  and  <stride>  must be divisible by 8;\n* The value of  <transfer\\_size> ,  <transfer\\_num>  and  <stride>  must be greater than 0;\n*  <stride>  should be grater than or equal to  <transfer\\_size> ;\n*  <src>  and  <dst>  cannot be overlapped;\n* The function does not support transport directions of GDRAM2SRAM, SRAM2GDRAM, LDRAM2SRAM, SRAM2LDRAM, SRAM2SRAM and WRAM2WRAM. \n Instruction Pipeline * Execute in Move instruction pipeline, if  <dst>  and  <src>  are  on-chip address ;\n* Execute in IO instruction pipeline, otherwise. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel() {\n  __nram__ char nram_dst[1024];\n  __nram__ char nram_src[1024];\n  __nram__ char nram_mask[1024];\n  __nram__ unsigned char nram_offset_u8[1024]; \n __gather(nram_dst, nram_src, nram_offset_u8, nram_mask, 1, NRAM2NRAM, 1, 32);\n} \n ``` \n"
  },
  {
    "content": "\n 3.17.2. __gather_async \n^^^^^^^^^^^^^^^\n void  __gather_async (void * dst ,  const  void * src ,  const  unsigned char * offset , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __gather_async (void * dst ,  const  void * src ,  const  unsigned short * offset , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __gather_async (void * dst ,  const  void * src ,  const  unsigned int * offset , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __gather_async (void * dst ,  const  void * src ,  const  unsigned char * offset ,  const  void * mask , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __gather_async (void * dst ,  const  void * src ,  const  unsigned short * offset ,  const  void * mask , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __gather_async (void * dst ,  const  void * src ,  const  unsigned int * offset ,  const  void * mask , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n Move the discrete data segments in  <src>  to  <dst>  with stride asynchronized. \n As shown in Figure Discrete Vector Gather Function , the cells with blue background indicate the data to be copied. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The destination vector.\n*  [in] src : The source vector.\n*  [in] offset : The offsets between the segments in  <src>  and the beginning of  <src>  in bytes.\n*  [in] mask : The source mask vector.\n*  [in] transfer\\_size : The size of single segment of  <src>  in bytes.\n*  [in] dir : Transport direction.\n*  [in] stride : The stride of adjacent segments in  <dst>  in bytes.\n*  [in] transfer\\_num : The number of segments in  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <offset>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* Each data transfer corresponds to a bit in  <mask>  while has  <mask>  in parameters, if the value of bit is 1, a data transfer occurs, otherwise, it does not;\n* The address of  <src>  is recommended to be 64-byte aligned to get better performance;\n* The address of  <mask>  is recommended to be 32-byte aligned to get better performance;\n* If the space of  <dst>  is in  wram ,  <transfer\\_size>  and  <stride>  must be divisible by 8;\n* The value of  <transfer\\_size> ,  <transfer\\_num>  and  <stride>  must be greater than 0;\n*  <stride>  should be grater than or equal to  <transfer\\_size> ;\n*  <src>  and  <dst>  cannot be overlapped;\n* The function does not support transport directions of GDRAM2SRAM, SRAM2GDRAM, LDRAM2SRAM, SRAM2LDRAM, SRAM2SRAM and WRAM2WRAM. \n Instruction Pipeline * Execute in Move instruction pipeline, if  <dst>  and  <src>  are  on-chip address ;\n* Execute in IO instruction pipeline, otherwise. "
  },
  {
    "content": "\n 3.17.3. __prefetch_smmu \n^^^^^^^^^^^^^^^\n void  __prefetch_smmu ( const  void * src , unsigned int  size )   \n Prefetches smmu entries before it is needed.  \n None. \n^^^^^^^^^^^^^^^\n Parameters *  [in] src : The address of source data.\n*  [in] size : The byte size of the source data. \n^^^^^^^^^^^^^^^\n Return void. \n^^^^^^^^^^^^^^^\n Remark *  <src>  must point to  \\_\\_mlu\\_device\\_\\_  address space;\n*  <size>  must be greater than zero. \n Instruction Pipeline * IO. \n^^^^^^^^^^^^^^^\nExample \n``` \n include  \n __mlu_entry__ void kernel(float* src) {\n  __prefetch_smmu(src, 1024);\n} \n ``` \n"
  },
  {
    "content": "\n 3.17.4. __scatter \n^^^^^^^^^^^^^^^\n void  __scatter (void * dst ,  const  void * src ,  const  unsigned char * offset , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __scatter (void * dst ,  const  void * src ,  const  unsigned short * offset , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __scatter (void * dst ,  const  void * src ,  const  unsigned int * offset , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __scatter (void * dst ,  const  void * src ,  const  unsigned char * offset ,  const  void * mask , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __scatter (void * dst ,  const  void * src ,  const  unsigned short * offset ,  const  void * mask , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __scatter (void * dst ,  const  void * src ,  const  unsigned int * offset ,  const  void * mask , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n Move the data segments in  <src>  to the discrete space of  <dst> . \n As shown in Figure Discrete Vector Scatter Function , the cells with blue background indicate the data to be copied. \n Fig. 3.6 Discrete Vector Scatter Function \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The destination vector.\n*  [in] src : The source vector.\n*  [in] offset : The offsets between the segments in  <dst>  and the beginning of  <dst>  in bytes.\n*  [in] mask : The source mask vector.\n*  [in] transfer\\_size : The size of single segment of  <src>  in bytes.\n*  [in] dir : Transport direction.\n*  [in] stride : The stride of adjacent segments in  <src>  in bytes.\n*  [in] transfer\\_num : The number of segments in  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <offset>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* Each data transfer corresponds to a bit in  <mask>  while has  <mask>  in parameters, if the value of bit is 1, a data transfer occurs, otherwise, it does not;\n* The address of  <src>  is recommended to be 64-byte aligned to get better performance;\n* The address of  <mask>  is recommended to be 32-byte aligned to get better performance;\n* If the space of  <dst>  is in  wram ,  <transfer\\_size>  and the values of  <offset>  must be divisible by 8;\n* The value of  <transfer\\_size> ,  <transfer\\_num>  and  <stride>  must be greater than 0;\n*  <stride>  should be grater than or equal to  <transfer\\_size> ;\n*  <src>  and  <dst>  cannot be overlapped;\n* The function does not support transport directions of GDRAM2SRAM, SRAM2GDRAM, LDRAM2SRAM, SRAM2LDRAM, SRAM2SRAM and WRAM2WRAM. \n Instruction Pipeline * Execute in Move instruction pipeline, if  <dst>  and  <src>  are  on-chip address ;\n* Execute in IO instruction pipeline, otherwise. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel() {\n  __nram__ char nram_dst[1024];\n  __nram__ char nram_src[1024];\n  __nram__ char nram_mask[1024];\n  __nram__ unsigned char nram_offset_u8[1024]; \n __scatter(nram_dst, nram_src, nram_offset_u8, nram_mask, 1, NRAM2NRAM, 1, 32);\n} \n ``` \n"
  },
  {
    "content": "\n 3.17.5. __scatter_async \n^^^^^^^^^^^^^^^\n void  __scatter_async (void * dst ,  const  void * src ,  const  unsigned char * offset , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __scatter_async (void * dst ,  const  void * src ,  const  unsigned short * offset , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __scatter_async (void * dst ,  const  void * src ,  const  unsigned int * offset , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __scatter_async (void * dst ,  const  void * src ,  const  unsigned char * offset ,  const  void * mask , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __scatter_async (void * dst ,  const  void * src ,  const  unsigned short * offset ,  const  void * mask , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n void  __scatter_async (void * dst ,  const  void * src ,  const  unsigned int * offset ,  const  void * mask , unsigned int  transfer_size , mluMemcpyDirection_t  dir , unsigned int  stride , unsigned short  transfer_num )   \n Move the data segments in  <src>  to the discrete space of  <dst>  asynchronized. \n As shown in Figure Discrete Vector Scatter Function , the cells with blue background indicate the data to be copied. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The destination vector.\n*  [in] src : The source vector.\n*  [in] offset : The offsets between the segments in  <dst>  and the beginning of  <dst>  in bytes.\n*  [in] mask : The source mask vector.\n*  [in] transfer\\_size : The size of single segment of  <src>  in bytes.\n*  [in] dir : Transport direction.\n*  [in] stride : The stride of adjacent segments in  <src>  in bytes.\n*  [in] transfer\\_num : The number of segments in  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <offset>  and  <mask>  must point to  \\_\\_nram\\_\\_  address space;\n* Each data transfer corresponds to a bit in  <mask>  while has  <mask>  in parameters, if the value of bit is 1, a data transfer occurs, otherwise, it does not;\n* The address of  <src>  is recommended to be 64-byte aligned to get better performance;\n* The address of  <mask>  is recommended to be 32-byte aligned to get better performance;\n* If the space of  <dst>  is in  wram ,  <transfer\\_size>  and the values of  <offset>  must be divisible by 8;\n* The value of  <transfer\\_size> ,  <transfer\\_num>  and  <stride>  must be greater than 0;\n*  <stride>  should be grater than or equal to  <transfer\\_size> ;\n*  <src>  and  <dst>  cannot be overlapped;\n* The function does not support transport directions of GDRAM2SRAM, SRAM2GDRAM, LDRAM2SRAM, SRAM2LDRAM, SRAM2SRAM and WRAM2WRAM. \n Instruction Pipeline * Execute in Move instruction pipeline, if  <dst>  and  <src>  are  on-chip address ;\n* Execute in IO instruction pipeline, otherwise. "
  },
  {
    "content": "\n 3.18.1. __sync_all \n^^^^^^^^^^^^^^^\n void  __sync_all ()   \n Synchronizes all clusters on which the kernel executes. It has the same effect as  \\_\\_sync\\_all\\_ipu  and  \\_\\_sync\\_all\\_mpu  combined. The number of MLU core and MPU core to synchronize is related to task type, UNION1 is 5, UNION2 is 10, UNION4 is 20. \n^^^^^^^^^^^^^^^\n Return void . \n^^^^^^^^^^^^^^^\n Remark * None. \n Instruction Pipeline * Execute on MPU core and MLU core. "
  },
  {
    "content": "\n 3.18.2. __sync_all_arrive \n^^^^^^^^^^^^^^^\n void  __sync_all_arrive (unsigned int  id , unsigned int  count )   \n Sends an unblocking signal of the cores to the barrier with the   across clusters. \n^^^^^^^^^^^^^^^\n Parameters *  [in] id : The barrier id.\n*  [in] count : The barrier count. \n^^^^^^^^^^^^^^^\n Return void . \n^^^^^^^^^^^^^^^\n Remark * The range of  <id>  is [0, 32767];\n*  count  must be greater than 1;\n* This function must be used together with __sync_all_wait;\n* This function does not support crossing. \n Instruction Pipeline * Execute on MPU core and MLU core. "
  },
  {
    "content": "\n 3.18.3. __sync_all_ipu \n^^^^^^^^^^^^^^^\n void  __sync_all_ipu ()   \n Synchronizes all MLU cores of clusters on which the kernel executes. The number of MLU cores to synchronize is related to task type, e.g., UNION1 is 4, UNION2 is 8, and UNION4 is 16. \n^^^^^^^^^^^^^^^\n Return void . \n^^^^^^^^^^^^^^^\n Remark * None. \n Instruction Pipeline * NA. "
  },
  {
    "content": "\n 3.18.4. __sync_all_ipu_within_cluster \n^^^^^^^^^^^^^^^\n void  __sync_all_ipu_within_cluster ()   \n Synchronizes all MLU cores within a cluster on which the kernel executes. \n^^^^^^^^^^^^^^^\n Return void . \n^^^^^^^^^^^^^^^\n Remark * None. \n Instruction Pipeline * NA. "
  },
  {
    "content": "\n 3.18.5. __sync_all_mpu \n^^^^^^^^^^^^^^^\n void  __sync_all_mpu ()   \n Synchronizes all MPU cores of clusters on which the kernel executes. The number of MPU cores to synchronize is related to task type, e.g., UNION1 is 1, UNION2 is 2, and UNION4 is 4. \n^^^^^^^^^^^^^^^\n Return void . \n^^^^^^^^^^^^^^^\n Remark * None. \n Instruction Pipeline * Execute on MPU core. "
  },
  {
    "content": "\n 3.18.6. __sync_all_wait \n^^^^^^^^^^^^^^^\n void  __sync_all_wait (unsigned int  id , unsigned int  count )   \n Blocks execution of a core until   number of unblocking signals from  \\_\\_sync\\_all\\_wait  or  \\_\\_sync\\_all\\_arrive  of the same   are received across clusters. \n @remark\n- The range of  <id>  is [0, 32767];\n-  count  must be greater than 1;\n- If multiple barrier events exist in different cores, barrier crossing is not supported. Crossing means a pair of  \\_\\_sync\\_all\\_arrive  or  \\_\\_sync\\_all\\_wait  instructions are in different order with the corresponding  \\_\\_sync\\_all\\_wait  instructions (with the same  id ). \n^^^^^^^^^^^^^^^\n Parameters *  [in] id : The barrier id.\n*  [in] count : The barrier count. \n^^^^^^^^^^^^^^^\n Return void . \n Instruction Pipeline * Execute on MPU core and MLU core. "
  },
  {
    "content": "\n 3.18.7. __sync_cluster \n^^^^^^^^^^^^^^^\n void  __sync_cluster ()   \n Synchronizes all cores inside the cluster on which the kernel executes. The cores to synchronize consists of 1 MPU core and 4 MLU cores. \n^^^^^^^^^^^^^^^\n Return void . \n^^^^^^^^^^^^^^^\n Remark * None. \n Instruction Pipeline * Execute on MPU core and MLU core. "
  },
  {
    "content": "\n 3.18.8. __sync_cluster_arrive \n^^^^^^^^^^^^^^^\n void  __sync_cluster_arrive (unsigned int  id , unsigned int  count )   \n Sends an unblocking signal of the cores to the barrier with the   within the cluster. \n^^^^^^^^^^^^^^^\n Parameters *  [in] id : The barrier id.\n*  [in] count : The barrier count. \n^^^^^^^^^^^^^^^\n Return void . \n^^^^^^^^^^^^^^^\n Remark * The range of  <id>  is [0, 32767];\n*  count  must be greater than 1;\n* This function must be used together with __sync_cluster_wait;\n* This function does not support crossing. \n Instruction Pipeline * Execute on MPU core and MLU core. "
  },
  {
    "content": "\n 3.18.9. __sync_cluster_wait \n^^^^^^^^^^^^^^^\n void  __sync_cluster_wait (unsigned int  id , unsigned int  count )   \n Blocks execution of a core until   number of unblocking signals from  \\_\\_sync\\_cluster\\_wait  or  \\_\\_sync\\_cluster\\_arrive  of the same   are received within the cluster. \n @remark\n- The range of  <id>  is [0, 32767];\n-  count  must be greater than 1;\n- If multiple barrier events exist in different cores, barrier crossing is not supported. Crossing means a pair of  \\_\\_sync\\_cluster\\_arrive  or  \\_\\_sync\\_cluster\\_wait  instructions are in different order with the corresponding  \\_\\_sync\\_cluster\\_wait  instructions (with the same  id ).\n^^^^^^^^^^^^^^^\n Parameters *  [in] id : The barrier id.\n*  [in] count : The barrier count. \n^^^^^^^^^^^^^^^\n Return void . \n Instruction Pipeline * Execute on MPU core and MLU core. "
  },
  {
    "content": "\n 3.19.1. __sync \n^^^^^^^^^^^^^^^\n void  __sync ()   \n Synchronizes all instructions within a core. All IO/Move/Compute/Scalar instructions after this function must wait until all instructions before this function have finished. \n^^^^^^^^^^^^^^^\n Return void . \n^^^^^^^^^^^^^^^\n Remark * None. \n Instruction Pipeline * Execute on MPU core and MLU core. \n^^^^^^^^^^^^^^^\n Requirements * BANG Version:  \\_\\_BANG\\_ARCH\\_\\_ >= 200 ;\n"
  },
  {
    "content": "\n 3.19.2. __sync_compute \n^^^^^^^^^^^^^^^\n void  __sync_compute ()   \n Synchronizes all instructions in compute pipeline within a core. All IO/Move/Compute instructions after this function must wait until all instructions in Compute pipeline have finished. \n^^^^^^^^^^^^^^^\n Return void . \n^^^^^^^^^^^^^^^\n Remark * None. \n Instruction Pipeline * NA. "
  },
  {
    "content": "\n 3.19.3. __sync_io \n^^^^^^^^^^^^^^^\n void  __sync_io ()   \n Synchronizes all instructions in IO pipeline within a core. All IO/Move/Compute instructions after this function must wait until all instructions in IO pipeline have finished. \n^^^^^^^^^^^^^^^\n Return void . \n^^^^^^^^^^^^^^^\n Remark * None. \n Instruction Pipeline * NA. "
  },
  {
    "content": "\n 3.19.4. __sync_io_move_compute \n^^^^^^^^^^^^^^^\n void  __sync_io_move_compute (bool  ioproducer  = true, bool  moveproducer  = true, bool  computeproducer  = true, bool  ioconsumer  = true, bool  moveconsumer  = true, bool  computeconsumer  = true)   \n Synchronizes all instructions in specified IO/Move/Compute pipelines within a core. All instructions in queues specified by consumer flags(flags with consumer suffix) after the  \\_\\_sync\\_io\\_move\\_compute  instruction must wait until all instructions in queues specified by producer flags(flags with producer suffix) before the  \\_\\_sync\\_io\\_move\\_compute  instruction have finished. If no flag is given, all IO/Move/Compute instructions after this function must wait until all instructions in IO/Move/Compute pipelines have finished. \n^^^^^^^^^^^^^^^\n Parameters *  [in] ioproducer : Specify whether io is producer.\n*  [in] moveproducer : Specify whether move is producer.\n*  [in] computeproducer : Specify whether compute is producer.\n*  [in] ioconsumer : Specify whether io is consumer.\n*  [in] moveconsumer : Specify whether move is consumer.\n*  [in] computeconsumer : Specify whether compute is consumer. \n^^^^^^^^^^^^^^^\n Return void . \n^^^^^^^^^^^^^^^\n Remark * Producers cannot all be false, consumers cannot all be false. \n Instruction Pipeline * NA. "
  },
  {
    "content": "\n 3.19.5. __sync_move \n^^^^^^^^^^^^^^^\n void  __sync_move ()   \n Synchronizes all instructions in move pipeline within a MLU core. All IO/Move/Compute instructions after this function must wait until all instructions in Move pipeline have finished. \n^^^^^^^^^^^^^^^\n Return void . \n^^^^^^^^^^^^^^^\n Remark * None. \n Instruction Pipeline * NA. "
  },
  {
    "content": "\n 3.20.1. __bang_matmul \n^^^^^^^^^^^^^^^\n void  __bang_matmul (half * dst ,  const  int4x2_t * src0 ,  const  int4x2_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int4x2_t * src0 ,  const  int8_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int4x2_t * src0 ,  const  int16_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int8_t * src0 ,  const  int4x2_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int8_t * src0 ,  const  int8_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int8_t * src0 ,  const  int16_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int16_t * src0 ,  const  int4x2_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int16_t * src0 ,  const  int8_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int16_t * src0 ,  const  int16_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int4x2_t * src0 ,  const  int4x2_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int4x2_t * src0 ,  const  int8_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int4x2_t * src0 ,  const  int16_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int8_t * src0 ,  const  int4x2_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int8_t * src0 ,  const  int8_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int8_t * src0 ,  const  int16_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int16_t * src0 ,  const  int4x2_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int16_t * src0 ,  const  int8_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int16_t * src0 ,  const  int16_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  M , unsigned int  K , unsigned int  N )   \n void  __bang_matmul (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  M , unsigned int  K , unsigned int  N )   \n void  __bang_matmul (float * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N )   \n void  __bang_matmul (int16_t * dst ,  const  int8_t * src0 ,  const  int8_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (int16_t * dst ,  const  int16_t * src0 ,  const  int8_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (int16_t * dst ,  const  int16_t * src0 ,  const  int16_t * src1 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int4x2_t * src0 ,  const  int4x2_t * src1 ,  const  half * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int4x2_t * src0 ,  const  int8_t * src1 ,  const  half * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int4x2_t * src0 ,  const  int16_t * src1 ,  const  half * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int8_t * src0 ,  const  int4x2_t * src1 ,  const  half * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int8_t * src0 ,  const  int8_t * src1 ,  const  half * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int8_t * src0 ,  const  int16_t * src1 ,  const  half * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int16_t * src0 ,  const  int4x2_t * src1 ,  const  half * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int16_t * src0 ,  const  int8_t * src1 ,  const  half * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (half * dst ,  const  int16_t * src0 ,  const  int16_t * src1 ,  const  half * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int4x2_t * src0 ,  const  int4x2_t * src1 ,  const  float * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int4x2_t * src0 ,  const  int8_t * src1 ,  const  float * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int4x2_t * src0 ,  const  int16_t * src1 ,  const  float * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int8_t * src0 ,  const  int4x2_t * src1 ,  const  float * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int8_t * src0 ,  const  int8_t * src1 ,  const  float * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int8_t * src0 ,  const  int16_t * src1 ,  const  float * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int16_t * src0 ,  const  int4x2_t * src1 ,  const  float * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int16_t * src0 ,  const  int8_t * src1 ,  const  float * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n void  __bang_matmul (float * dst ,  const  int16_t * src0 ,  const  int16_t * src1 ,  const  float * src2 , unsigned int  M , unsigned int  K , unsigned int  N , int  fix_position )   \n For version without  <src2> , use the two-dimensional tensor  <src0>[<M>, <K>]  to perform a product operation on the two-dimensional tensor  <src1>[<K>, <N>]  and stores the result in the two-dimensional tensor  <dst>[<M>, <N>]  , i.e., (  =   \\times  ). For version with  <src2> , use the two-dimensional tensor  <src0>[<M>, <K>]  to perform a product operation on the two-dimensional tensor  <src1>[<K>, <N>]  and add the two-dimensional tensor  <src2>[<M>, <N>]  and stores the result in the two-dimensional tensor  <dst>[<M>, <N>]  , i.e., (  =   \\times   +  ). \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination matrix which has row-major data layout.\n*  [in] src0 : The address of source0 matrix which has row-major data layout.\n*  [in] src1 : The address of source1 matrix which has column-major data layout.\n*  [in] src2 : The address of source2 matrix which has row-major data layout.\n*  [in] M : The height of source0 matrix.\n*  [in] K : The width of source0 matrix.\n*  [in] N : The width of source1 matrix.\n*  [in] fix\\_position : Sum of the scale factor of  <src0>  and  <src1> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0>  ,  <src2>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src1>  must point to  \\_\\_wram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127, 127] ;\n* The address of  <src1>  must be 32-byte aligned;\n* The matrix  <src1>  must be reshaped either on host or on device with  \\_\\_bang\\_reshape() ;\n* The address of  <dst>  ,  <src0>  and  <src2>  must be 64-byte aligned on  (m)tp\\_2xx ;\n*  <K> \\* sizeof(typeof<src0>)  must be 64-byte aligned on  (m)tp\\_2xx ;\n*  <N>  must be divisible by 64 on  (m)tp\\_2xx ;\n*  <N> \\* sizeof(typeof<dst>)  must be 64-byte aligned on  (m)tp\\_2xx ;\n* The byte size of  <src1>  must be 64-byte aligned;\n* On  (m)tp\\_3xx  and higher,  M  dimension of  <src1>  must satisfy the following alignment constraints:\n    + If  sizeof(typeof<src0>) / sizeof(typeof<src1>) == 4 ,  K \\* sizeof(typeof<src1>)  must be 16-byte aligned;\n    + If  sizeof(typeof<src0>) / sizeof(typeof<src1>) == 2 ,  K \\* sizeof(typeof<src1>)  must be 32-byte aligned;\n    + Otherwise,  K \\* sizeof(typeof<src1>)  must be 64-byte aligned;\n* On  (m)tp\\_3xx  and higher, there is no alignment constraint for parameter  <N> , but when allocating memory, the  N  dimension of memory space of  <src1>  must be 64 aligned;\n*  <M> ,  <K>  and  <N>  must be greater than 0;\n*  <dst>  cannot be overlapped with  <src0> ;\n*  <dst>  can be overlapped with  <src2> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define N 64 \n define K 256 \n define M 128 \n define SRC0_DATA_NUM (M * K) \n define SRC1_DATA_NUM (K * N) \n define DST_DATA_NUM (M * N) \n __mlu_entry__ void MatmulKernel(half *dst,\n                                int16_t *src0,\n                                int8_t *src1,\n                                int M,\n                                int K,\n                                int N,\n                                int pos) {\n __nram__ half nram_dst[DST_DATA_NUM];\n __nram__ int16_t nram_src0[SRC0_DATA_NUM];\n __wram__ int8_t wram_src1[SRC1_DATA_NUM];\n __memcpy(nram_src0, src0, SRC0_DATA_NUM * sizeof(int16_t), GDRAM2NRAM);\n __memcpy(wram_src1, src1, SRC1_DATA_NUM * sizeof(int8_t), GDRAM2WRAM);\n __bang_matmul(nram_dst, nram_src0, wram_src1, M, K, N, pos);\n __memcpy(dst, nram_dst, DST_DATA_NUM * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.1. __bfloat162char \n^^^^^^^^^^^^^^^\n char  __bfloat162char (bfloat16_t  a )   \n This function converts type of  a  from  bfloat16\\_t  to  char  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(bfloat16_t a) {\n  char result;\n  result = __bfloat162char(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.9. __bfloat162float \n^^^^^^^^^^^^^^^\n float  __bfloat162float (bfloat16_t  a )   \n This function converts type of  a  from  bfloat16\\_t  to  float  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(bfloat16_t a) {\n  float result;\n  result = __bfloat162float(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.17. __bfloat162half \n^^^^^^^^^^^^^^^\n half  __bfloat162half (bfloat16_t  a )   \n This function converts type of  a  from  bfloat16\\_t  to  half  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(bfloat16_t a) {\n  half result;\n  result = __bfloat162half(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.25. __bfloat162int \n^^^^^^^^^^^^^^^\n int  __bfloat162int (bfloat16_t  a )   \n This function converts type of  a  from  bfloat16\\_t  to  int  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(bfloat16_t a) {\n  int result;\n  result = __bfloat162int(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.33. __bfloat162short \n^^^^^^^^^^^^^^^\n short  __bfloat162short (bfloat16_t  a )   \n This function converts type of  a  from  bfloat16\\_t  to  short  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(bfloat16_t a) {\n  short result;\n  result = __bfloat162short(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.41. __bfloat162tf32 \n^^^^^^^^^^^^^^^\n float  __bfloat162tf32 (bfloat16_t  a )   \n This function converts type of  a  from  bfloat16\\_t  to  tf32  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(bfloat16_t a) {\n  float result;\n  result = __bfloat162tf32(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.49. __char2bfloat16 \n^^^^^^^^^^^^^^^\n bfloat16_t  __char2bfloat16 (char  a )   \n This function converts type of  a  from  char  to  bfloat16\\_t .\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(char a) {\n  bfloat16_t result;\n  result = __char2bfloat16(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.52. __char2tf32 \n^^^^^^^^^^^^^^^\n float  __char2tf32 (char  a )   \n This function converts type of  a  from  char  to  tf32 .\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(char a) {\n  float result;\n  result = __char2tf32(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.53. __float2bfloat16 \n^^^^^^^^^^^^^^^\n bfloat16_t  __float2bfloat16 (float  a )   \n This function converts type of  a  from  float  to  bfloat16\\_t  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(float a) {\n  bfloat16_t result;\n  result = __float2bfloat16(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.61. __float2char \n^^^^^^^^^^^^^^^\n char  __float2char (float  a )   \n This function converts type of  a  from  float  to  char  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(float a) {\n  char result;\n  result = __float2char(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.75. __float2half_tz \n^^^^^^^^^^^^^^^\n half  __float2half_tz (float  a )   \n This function converts type of  a  from  float  to  half  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(float a) {\n  half result;\n  result = __float2half_tz(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.83. __float2int_tz \n^^^^^^^^^^^^^^^\n int  __float2int_tz (float  a )   \n This function converts type of  a  from  float  to  int  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(float a) {\n  int result;\n  result = __float2int_tz(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.91. __float2short_tz \n^^^^^^^^^^^^^^^\n short  __float2short_tz (float  a )   \n This function converts type of  a  from  float  to  short  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(float a) {\n  short result;\n  result = __float2short_tz(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.93. __float2tf32 \n^^^^^^^^^^^^^^^\n float  __float2tf32 (float  a )   \n This function converts type of  a  from  float  to  tf32  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(float a) {\n  float result;\n  result = __float2tf32(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.101. __float2uchar \n^^^^^^^^^^^^^^^\n unsigned char  __float2uchar (float  a )   \n This function converts type of  a  from  float  to  unsigned char  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(float a) {\n  unsigned char result;\n  result = __float2uchar(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.109. __float2uint \n^^^^^^^^^^^^^^^\n unsigned int  __float2uint (float  a )   \n This function converts type of  a  from  float  to  unsigned int  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(float a) {\n  unsigned int result;\n  result = __float2uint(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.117. __float2ushort \n^^^^^^^^^^^^^^^\n unsigned short  __float2ushort (float  a )   \n This function converts type of  a  from  float  to  unsigned short  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(float a) {\n  unsigned short result;\n  result = __float2ushort(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.125. __half2bfloat16 \n^^^^^^^^^^^^^^^\n bfloat16_t  __half2bfloat16 (half  a )   \n This function converts type of  a  from  half  to  bfloat16\\_t  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(half a) {\n  bfloat16_t result;\n  result = __half2bfloat16(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.133. __half2char \n^^^^^^^^^^^^^^^\n char  __half2char (half  a )   \n This function converts type of  a  from  half  to  char  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(half a) {\n  char result;\n  result = __half2char(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.141. __half2float \n^^^^^^^^^^^^^^^\n float  __half2float (half  a )   \n This function converts type of  a  from  half  to  float  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(half a) {\n  float result;\n  result = __half2float(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.155. __half2int_tz \n^^^^^^^^^^^^^^^\n int  __half2int_tz (half  a )   \n This function converts type of  a  from  half  to  int  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(float a) {\n   int result;\n   result = __half2int_tz(a);\n } \n ``` \n"
  },
  {
    "content": "\n 3.21.163. __half2short_tz \n^^^^^^^^^^^^^^^\n short  __half2short_tz (half  a )   \n This function converts type of  a  from  half  to  short  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(half a) {\n  short result;\n  result = __half2short_tz(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.165. __half2tf32 \n^^^^^^^^^^^^^^^\n float  __half2tf32 (half  a )   \n This function converts type of  a  from  half  to  tf32  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(half a) {\n  float result;\n  result = __half2tf32(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.173. __half2uchar \n^^^^^^^^^^^^^^^\n unsigned char  __half2uchar (half  a )   \n This function converts type of  a  from  half  to  unsigned char  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(half a) {\n  unsigned char result;\n  result = __half2uchar(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.181. __half2uint \n^^^^^^^^^^^^^^^\n unsigned int  __half2uint (half  a )   \n This function converts type of  a  from  half  to  unsigned int  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(half a) {\n  unsigned int result;\n  result = __half2uint(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.189. __half2ushort \n^^^^^^^^^^^^^^^\n unsigned short  __half2ushort (half  a )   \n This function converts type of  a  from  half  to  unsigned short  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(half a) {\n  unsigned short result;\n  result = __half2ushort(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.197. __int2bfloat16 \n^^^^^^^^^^^^^^^\n bfloat16_t  __int2bfloat16 (int  a )   \n This function converts type of  a  from  int  to  bfloat16\\_t  in round-to-zero mode.\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(int a) {\n  bfloat16_t result;\n  result = __int2bfloat16(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.205. __int2float \n^^^^^^^^^^^^^^^\n float  __int2float (int  a )   \n This function converts type of  a  from  int  to  float  in round-to-zero mode.\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(int a) {\n  float result;\n  result = __int2float(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.219. __int2half_tz \n^^^^^^^^^^^^^^^\n half  __int2half_tz (int  a )   \n This function converts type of  a  from  int  to  half  in round-to-zero mode.\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(int a) {\n   half result;\n   result = __int2half_tz(a);\n } \n ``` \n"
  },
  {
    "content": "\n 3.21.221. __int2tf32 \n^^^^^^^^^^^^^^^\n float  __int2tf32 (int  a )   \n This function converts type of  a  from  int  to  tf32  in round-to-zero mode.\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(int a) {\n  float result;\n  result = __int2tf32(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.230. __short2bfloat16 \n^^^^^^^^^^^^^^^\n bfloat16_t  __short2bfloat16 (short  a )   \n This function converts type of  a  from  short  to  bfloat16\\_t  in round-to-zero mode.\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(short a) {\n  bfloat16_t result;\n  result = __short2bfloat16(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.245. __short2half_tz \n^^^^^^^^^^^^^^^\n half  __short2half_tz (short  a )   \n This function converts type of  a  from  short  to  half  in round-to-zero mode.\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(short a) {\n  half result;\n  result = __short2half_tz(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.247. __short2tf32 \n^^^^^^^^^^^^^^^\n float  __short2tf32 (short  a )   \n This function converts type of  a  from  short  to  tf32  in round-to-zero mode.\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(short a) {\n  float result;\n  result = __short2tf32(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.255. __tf322bfloat16 \n^^^^^^^^^^^^^^^\n bfloat16_t  __tf322bfloat16 (float  a )   \n This function converts type of  a  from  tf32  to  bfloat16\\_t  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(float a) {\n  bfloat16_t result;\n  result = __tf322bfloat16(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.263. __tf322char \n^^^^^^^^^^^^^^^\n char  __tf322char (float  a )   \n This function converts type of  a  from  tf32  to  char  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(float a) {\n  char result;\n  result = __tf322char(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.271. __tf322float \n^^^^^^^^^^^^^^^\n float  __tf322float (float  a )   \n This function converts type of  a  from  tf32  to  float  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(float a) {\n  float result;\n  result = __tf322float(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.279. __tf322half \n^^^^^^^^^^^^^^^\n half  __tf322half (float  a )   \n This function converts type of  a  from  tf32  to  half  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(float a) {\n  half result;\n  result = __tf322half(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.287. __tf322int \n^^^^^^^^^^^^^^^\n int  __tf322int (float  a )   \n This function converts type of  a  from  tf32  to  int  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(float a) {\n  int result;\n  result = __tf322int(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.295. __tf322short \n^^^^^^^^^^^^^^^\n short  __tf322short (float  a )   \n This function converts type of  a  from  tf32  to  short  in round-to-zero mode. \n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(float a) {\n  short result;\n  result = __tf322short(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.303. __uchar2bfloat16 \n^^^^^^^^^^^^^^^\n bfloat16_t  __uchar2bfloat16 (unsigned char  a )   \n This function converts type of  a  from  unsigned char  to  bfloat16\\_t .\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(unsigned char a) {\n  bfloat16_t result;\n  result = __uchar2bfloat16(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.306. __uchar2tf32 \n^^^^^^^^^^^^^^^\n float  __uchar2tf32 (unsigned char  a )   \n This function converts type of  a  from  unsigned char  to  tf32 .\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(unsigned char a) {\n  float result;\n  result = __uchar2tf32(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.307. __uint2bfloat16 \n^^^^^^^^^^^^^^^\n bfloat16_t  __uint2bfloat16 (unsigned int  a )   \n This function converts type of  a  from  unsigned int  to  bfloat16\\_t  in round-to-zero mode.\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(unsigned int a) {\n  bfloat16_t result;\n  result = __uint2bfloat16(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.321. __uint2float_tz \n^^^^^^^^^^^^^^^\n float  __uint2float_tz (unsigned int  a )   \n This function converts type of  a  from  unsigned int  to  float  in round-to-zero mode.\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(unsigned int a) {\n  float result;\n  result = __uint2float_tz(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.329. __uint2half_tz \n^^^^^^^^^^^^^^^\n half  __uint2half_tz (unsigned int  a )   \n This function converts type of  a  from  unsigned int  to  half  in round-to-zero mode.\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(int a) {\n  half result;\n  result = __uint2half_tz(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.331. __uint2tf32 \n^^^^^^^^^^^^^^^\n float  __uint2tf32 (unsigned int  a )   \n This function converts type of  a  from  unsigned int  to  tf32  in round-to-zero mode.\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(unsigned int a) {\n  float result;\n  result = __uint2tf32(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.339. __ushort2bfloat16 \n^^^^^^^^^^^^^^^\n bfloat16_t  __ushort2bfloat16 (unsigned short  a )   \n This function converts type of  a  from  unsigned short  to  bfloat16\\_t  in round-to-zero mode.\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(unsigned short a) {\n  bfloat16_t result;\n  result = __ushort2bfloat16(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.354. __ushort2half_tz \n^^^^^^^^^^^^^^^\n half  __ushort2half_tz (unsigned short  a )   \n This function converts type of  a  from  unsigned short  to  half  in round-to-zero mode.\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(unsigned short a) {\n  half result;\n  result = __ushort2half_tz(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.21.356. __ushort2tf32 \n^^^^^^^^^^^^^^^\n float  __ushort2tf32 (unsigned short  a )   \n This function converts type of  a  from  unsigned short  to  tf32  in round-to-zero mode.\n^^^^^^^^^^^^^^^\n Parameters *  [in] a : The source data. \n^^^^^^^^^^^^^^^\n Instruction Pipeline * Scalar. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n __mlu_entry__ void kernel(unsigned short a) {\n  float result;\n  result = __ushort2tf32(a);\n} \n ``` \n"
  },
  {
    "content": "\n 3.22.1. __bang_active_abs \n^^^^^^^^^^^^^^^\n void  __bang_active_abs (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_abs (float * dst ,  const  float * src , unsigned int  elem_count )   \n This function computes the absolute value of each element in vector  <src>  and saves the result to vector  <dst> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * Average relative error: 0;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  space;\n*  <elem\\_count>  must be greater than zero;\n*  <dst>  can be overlapped with  <src> ;"
  },
  {
    "content": "\n 3.22.2. __bang_active_cos \n^^^^^^^^^^^^^^^\n void  __bang_active_cos (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_cos (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies active (cosine) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * Average relative error: within 0.01;\n*  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n* The element value of  <src>  is in the range [-2\u03c0, 2\u03c0] radian;"
  },
  {
    "content": "\n 3.22.3. __bang_active_exp \n^^^^^^^^^^^^^^^\n void  __bang_active_exp (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_exp (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies active (exponent) operation on source operand  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n "
  },
  {
    "content": "\n 3.22.4. __bang_active_exp_less_0 \n^^^^^^^^^^^^^^^\n void  __bang_active_exp_less_0 (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_exp_less_0 (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies active (exponent) operation on source operand  <src>  when the value of  <src>  is less than 0. \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;"
  },
  {
    "content": "\n 3.22.5. __bang_active_exphp \n^^^^^^^^^^^^^^^\n void  __bang_active_exphp (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_exphp (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies high precision active (exponent) operation on source operand  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. The formula for exp is as follows:\n exp(x) = e^x\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n"
  },
  {
     "content": "\n 3.22.6. __bang_active_gelu \n^^^^^^^^^^^^^^^\n void  __bang_active_gelu (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_gelu (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies active (gelu) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally.  The formula for GELU is as follows:\n gelu(x) = 0.5 * x * (1 + tanh(sqrt(2/M_PI) * (x + 0.044715 * x^3)))\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * Average relative error: within 0.003;\n*  <elem\\_count>  must be greater than zero;\n*  <dst>  can be overlapped with  <src> ;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n"
  },
  {
     "content": "\n 3.22.7. __bang_active_gelup \n^^^^^^^^^^^^^^^\n void  __bang_active_gelup (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_gelup (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies active (gelup) operation on  <src> , which has higher precision than active(gelu) does. \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. The formula for GELU is as follows:\n gelu(x) = 0.5 * x * (1 + tanh(sqrt(2/M_PI) * (x + 0.044715 * x^3)))\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ; "
  },
  {
    "content": "\n 3.22.8. __bang_active_log \n^^^^^^^^^^^^^^^\n void  __bang_active_log (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_log (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies active (log base e) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * Average relative error: within 0.01;\n*  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n* The element value of  <src>  is in the range [6.1e-5, 63484];"
  },
  {
    "content": "\n 3.22.9. __bang_active_loghp \n^^^^^^^^^^^^^^^\n void  __bang_active_loghp (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_loghp (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies high precision active (log base e) operation on source operand  <src> . The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;"
  },
  {
    "content": "\n 3.22.10. __bang_active_pow2 \n^^^^^^^^^^^^^^^\n void  __bang_active_pow2 (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_pow2 (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies active (pow2) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. The formula for pow2 is as follows:\n pow2(src) = powf(2, src)\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * Average relative error: 0;\n*  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n* When the data type of the element of  <src>  is  half  , the element values are integers in the range  [-24.0, 15.0]  , such as  -24.0, -23.0, ... 0.0, 1.0, 2.0, ... 15.0  ; when the data type of the element of  <src>  is  float , the element values are integers in the range  [-31.0, 31.0] , such as  -31.0, -30.0, ... 0.0, 1.0, 2.0, ... 31.0 . "
  },
  {
    "content": "\n 3.22.11. __bang_active_recip \n^^^^^^^^^^^^^^^\n void  __bang_active_recip (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_recip (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies active (reciprocal) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n Fig. 3.9 Reciprocal Process \n Hint \n Recip means reciprocal. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  can be overlapped with  <src> ;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* The element values of  <src>  are in the range [0.0078125, 65472];\n* When the data type of the elements of  <src>  is  float , the average relative error is within 0.003; when the data type of the elements of  <src>  is  half , the average relative error is within 0.01. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 64 \n __mlu_entry__ void kernel(half* y, half* x) {\n  __nram__ half ny[LEN];\n  __nram__ half nx[LEN];\n  __memcpy(ny, y, LEN * sizeof(half), GDRAM2NRAM);\n  __memcpy(nx, x, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_active_recip(ny, nx, LEN);\n  __memcpy(y, ny, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.22.12. __bang_active_recip_greater_1 \n^^^^^^^^^^^^^^^\n void  __bang_active_recip_greater_1 (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_recip_greater_1 (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies active (reciprocal) operation on  <src>  when the value of  <src>  is greater than 1. \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n Hint \n Recip means reciprocal. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n* The element values of  <src>  are in the range [1, 63487];\n* When the data type of the elements of  <src>  is  float , the average relative error is within 0.003; when the data type of the elements of  <src>  is  half , the average relative error is within 0.01. "
  },
  {
    "content": "\n 3.22.13. __bang_active_reciphp \n^^^^^^^^^^^^^^^\n void  __bang_active_reciphp (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_reciphp (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies high precision active (reciprocal) operation on source operand  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n "
  },
  {
    "content": "\n 3.22.14. __bang_active_relu \n^^^^^^^^^^^^^^^\n void  __bang_active_relu (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_relu (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies active (relu) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * Average relative error: 0;\n*  <elem\\_count>  must be greater than zero;\n*  <dst>  can be overlapped with  <src> ;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;"
  },
  {
    "content": "\n 3.22.15. __bang_active_rsqrt \n^^^^^^^^^^^^^^^\n void  __bang_active_rsqrt (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_rsqrt (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies active (rsqrt) operation on  <src> , (  = 1 \\div sqrt{ }). \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * Average relative error: within 0.01;\n*  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n* The element value of  <src>  is in the range [0.005, 63487];"
  },
  {
    "content": "\n 3.22.16. __bang_active_rsqrthp \n^^^^^^^^^^^^^^^\n void  __bang_active_rsqrthp (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_rsqrthp (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies high precision active (rsqrt) operation on source operand  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  can be overlapped with  <src> ;\n"
  },
  {
    "content": "\n 3.22.17. __bang_active_sigmoid \n^^^^^^^^^^^^^^^\n void  __bang_active_sigmoid (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_sigmoid (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies active (sigmoid) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. The formula for Sigmoid is as follows: 1 / (1 + exp(-x))\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * Average relative error: within 0.01;\n*  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;"
  },
  {
    "content": "\n 3.22.18. __bang_active_sign \n^^^^^^^^^^^^^^^\n void  __bang_active_sign (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_sign (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies active (sign) operation on  <src> . If (  \\ge 0.0), then, stores 1.0 in  <dst> ; otherwise, stores -1.0 in  <dst> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * Average relative error: 0;\n*  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n* When the element value of  <src>  is -0 or +0, the corresponding result is 1;"
  },
  {
    "content": "\n 3.22.19. __bang_active_sin \n^^^^^^^^^^^^^^^\n void  __bang_active_sin (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_sin (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies active (sine) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* The element value of  <src>  is in the range [-2\u03c0, 2\u03c0] radian;\n* Average relative error: within 0.01;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.22.20. __bang_active_sqrt \n^^^^^^^^^^^^^^^\n void  __bang_active_sqrt (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_sqrt (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies active (sqrt) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * Average relative error: within 0.01;\n*  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n* The element value of  <src>  is in the range [0, 63487];"
  },
  {
    "content": "\n 3.22.21. __bang_active_sqrthp \n^^^^^^^^^^^^^^^\n void  __bang_active_sqrthp (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_sqrthp (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies high precision active (exponent) operation on source operand  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;"
  },
  {
    "content": "\n 3.22.22. __bang_active_tanh \n^^^^^^^^^^^^^^^\n void  __bang_active_tanh (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_active_tanh (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies active (tanh) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. The formula is as follows: tanh(x)\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark * Average relative error: within 0.01;\n*  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;"
  },
  {
    "content": "\n 3.22.23. __bang_taylor3_cos \n^^^^^^^^^^^^^^^\n void  __bang_taylor3_cos (half * dst ,  const  half * src ,  const  half * aux1 ,  const  half * aux2 , unsigned int  elem_count )   \n void  __bang_taylor3_cos (float * dst ,  const  float * src ,  const  float * aux1 ,  const  float * aux2 , unsigned int  elem_count )   \n Applies active with taylor3 (cos) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] aux1 : The auxiliary  \\_\\_nram\\_\\_  space 1.\n*  [in] aux2 : The auxiliary  \\_\\_nram\\_\\_  space 2.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  ,  <aux1>  and  <aux2>  must have the same size as  <src> ;\n*  <src>  ,  <aux1>  ,  <aux2>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  ,  <aux1>  ,  <aux2>  and  <src>  cannot be overlapped;"
  },
  {
    "content": "\n 3.22.24. __bang_taylor3_sigmoid \n^^^^^^^^^^^^^^^\n void  __bang_taylor3_sigmoid (half * dst ,  const  half * src ,  const  half * aux1 ,  const  half * aux2 , unsigned int  elem_count )   \n void  __bang_taylor3_sigmoid (float * dst ,  const  float * src ,  const  float * aux1 ,  const  float * aux2 , unsigned int  elem_count )   \n Applies active with taylor3 (sigmoid) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] aux1 : The auxiliary  \\_\\_nram\\_\\_  space 1.\n*  [in] aux2 : The auxiliary  \\_\\_nram\\_\\_  space 2.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  ,  <aux1>  and  <aux2>  must have the same size as  <src> ;\n*  <src>  ,  <aux1>  ,  <aux2>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  ,  <aux1>  ,  <aux2>  and  <src>  cannot be overlapped;\n* The address of  <src> ,  <aux1> ,  <aux2>  and  <dst>  must be 64-byte aligned on  (m)tp\\_2xx ;\n* The value of elements in  <src>  is in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.000001 for  half  and  float  type respectively;"
  },
  {
    "content": "\n 3.22.25. __bang_taylor3_sin \n^^^^^^^^^^^^^^^\n void  __bang_taylor3_sin (half * dst ,  const  half * src ,  const  half * aux1 ,  const  half * aux2 , unsigned int  elem_count )   \n void  __bang_taylor3_sin (float * dst ,  const  float * src ,  const  float * aux1 ,  const  float * aux2 , unsigned int  elem_count )   \n Applies active with taylor3 (sine) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] aux1 : The auxiliary  \\_\\_nram\\_\\_  space 1.\n*  [in] aux2 : The auxiliary  \\_\\_nram\\_\\_  space 2.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  ,  <aux1>  and  <aux2>  must have the same size as  <src> ;\n*  <src>  ,  <aux1>  ,  <aux2>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  ,  <aux1>  ,  <aux2>  and  <src>  cannot be overlapped;\n* The address of  <src> ,  <aux1> ,  <aux2>  and  <dst>  must be 64-byte aligned on  (m)tp\\_2xx ;"
  },
  {
    "content": "\n 3.22.26. __bang_taylor3_softplus \n^^^^^^^^^^^^^^^\n void  __bang_taylor3_softplus (half * dst ,  const  half * src ,  const  half * aux1 ,  const  half * aux2 , unsigned int  elem_count )   \n void  __bang_taylor3_softplus (float * dst ,  const  float * src ,  const  float * aux1 ,  const  float * aux2 , unsigned int  elem_count )   \n Applies active with taylor3 (softplus) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] aux1 : The auxiliary  \\_\\_nram\\_\\_  space 1.\n*  [in] aux2 : The auxiliary  \\_\\_nram\\_\\_  space 2.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  ,  <aux1>  and  <aux2>  must have the same size as  <src> ;\n*  <src>  ,  <aux1>  ,  <aux2>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  ,  <aux1>  ,  <aux2>  and  <src>  cannot be overlapped;\n* The address of  <src> ,  <aux1> ,  <aux2>  and  <dst>  must be 64-byte aligned on  (m)tp\\_2xx ;\n* The value of elements in  <src>  is in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.000001 for  half  and  float  type respectively;\n* Refer to the following tables for special value of  \\_\\_bang\\_taylor3\\_softplus ; "
  },
  {
    "content": "\n 3.22.27. __bang_taylor3_tanh \n^^^^^^^^^^^^^^^\n void  __bang_taylor3_tanh (half * dst ,  const  half * src ,  const  half * aux1 ,  const  half * aux2 , unsigned int  elem_count )   \n void  __bang_taylor3_tanh (float * dst ,  const  float * src ,  const  float * aux1 ,  const  float * aux2 , unsigned int  elem_count )   \n Applies active with taylor3 (tanh) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. The formula is as follows: tanh(x)\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] aux1 : The auxiliary  \\_\\_nram\\_\\_  space 1.\n*  [in] aux2 : The auxiliary  \\_\\_nram\\_\\_  space 2.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  ,  <aux1>  and  <aux2>  must have the same size as  <src> ;\n*  <src>  ,  <aux1>  ,  <aux2>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  ,  <aux1>  ,  <aux2>  and  <src>  cannot be overlapped;\n* The address of  <src> ,  <aux1> ,  <aux2>  and  <dst>  must be 64-byte aligned on  (m)tp\\_2xx ;\n* The value of elements in  <src>  must be in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.00001 for  half  and  float  type respectively. "
  },
  {
    "content": "\n 3.22.28. __bang_taylor4_cos \n^^^^^^^^^^^^^^^\n void  __bang_taylor4_cos (half * dst ,  const  half * src ,  const  half * aux1 ,  const  half * aux2 , unsigned int  elem_count )   \n void  __bang_taylor4_cos (float * dst ,  const  float * src ,  const  float * aux1 ,  const  float * aux2 , unsigned int  elem_count )   \n Applies active with taylor4 (cos) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] aux1 : The auxiliary  \\_\\_nram\\_\\_  space 1.\n*  [in] aux2 : The auxiliary  \\_\\_nram\\_\\_  space 2.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  ,  <aux1>  and  <aux2>  must have the same size as  <src> ;\n*  <src>  ,  <aux1>  ,  <aux2>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  ,  <aux1>  ,  <aux2>  and  <src>  cannot be overlapped;\n* The address of  <src> ,  <aux1> ,  <aux2>  and  <dst>  must be 64-byte aligned on  (m)tp\\_2xx ;\n* The value of elements in  <src>  is in the range (-7.75, 7.75) radian; the average relative error is within 0.0005 and 0.000001 for  half  and  float  type respectively;\n* Refer to the following tables for special value of  \\_\\_bang\\_taylor4\\_cos ; "
  },
  {
    "content": "\n 3.22.29. __bang_taylor4_sigmoid \n^^^^^^^^^^^^^^^\n void  __bang_taylor4_sigmoid (half * dst ,  const  half * src ,  const  half * aux1 ,  const  half * aux2 , unsigned int  elem_count )   \n void  __bang_taylor4_sigmoid (float * dst ,  const  float * src ,  const  float * aux1 ,  const  float * aux2 , unsigned int  elem_count )   \n Applies active with taylor4 (sigmoid) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] aux1 : The auxiliary  \\_\\_nram\\_\\_  space 1.\n*  [in] aux2 : The auxiliary  \\_\\_nram\\_\\_  space 2.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n* The address of  <src> ,  <aux1> ,  <aux2>  and  <dst>  must be 64-byte aligned on  (m)tp\\_2xx ;\n*  <src>  ,  <aux1>  ,  <aux2>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  ,  <aux1>  and  <aux2>  must have the same size as  <src> ;\n*  <dst>  ,  <aux1>  ,  <aux2>  and  <src>  cannot be overlapped;\n* The value of elements in  <src>  is in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.0000001 for  half  and  float  type respectively;\n* Refer to the following tables for special value of  \\_\\_bang\\_taylor4\\_sigmoid ; "
  },
  {
    "content": "\n 3.22.30. __bang_taylor4_sin \n^^^^^^^^^^^^^^^\n void  __bang_taylor4_sin (half * dst ,  const  half * src ,  const  half * aux1 ,  const  half * aux2 , unsigned int  elem_count )   \n void  __bang_taylor4_sin (float * dst ,  const  float * src ,  const  float * aux1 ,  const  float * aux2 , unsigned int  elem_count )   \n Applies active with taylor4 (sine) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] aux1 : The auxiliary  \\_\\_nram\\_\\_  space 1.\n*  [in] aux2 : The auxiliary  \\_\\_nram\\_\\_  space 2.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  ,  <aux1>  and  <aux2>  must have the same size as  <src> ;\n*  <src>  ,  <aux1>  ,  <aux2>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  ,  <aux1>  ,  <aux2>  and  <src>  cannot be overlapped;\n* The address of  <src> ,  <aux1> ,  <aux2>  and  <dst>  must be 64-byte aligned on  (m)tp\\_2xx ;\n* The value of elements in  <src>  is in the range (-7.75, 7.75) radian; the average relative error is within 0.0005 and 0.000001 for  half  and  float  type respectively;\n* Refer to the following tables for special value of  \\_\\_bang\\_taylor4\\_sin ; "
  },
  {
    "content": "\n 3.22.31. __bang_taylor4_softplus \n^^^^^^^^^^^^^^^\n void  __bang_taylor4_softplus (half * dst ,  const  half * src ,  const  half * aux1 ,  const  half * aux2 , unsigned int  elem_count )   \n void  __bang_taylor4_softplus (float * dst , float * src , float * aux1 , float * aux2 , unsigned int  elem_count )   \n Applies active with taylor4 (softplus) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] aux1 : The auxiliary  \\_\\_nram\\_\\_  space 1.\n*  [in] aux2 : The auxiliary  \\_\\_nram\\_\\_  space 2.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  ,  <aux1>  and  <aux2>  must have the same size as  <src> ;\n*  <src>  ,  <aux1>  ,  <aux2>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  ,  <aux1>  ,  <aux2>  and  <src>  cannot be overlapped;\n* The address of  <src> ,  <aux1> ,  <aux2>  and  <dst>  must be 64-byte aligned on  (m)tp\\_2xx ;\n* The value of elements in  <src>  is in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.0000001 for  half  and  float  type respectively;\n* Refer to the following tables for special value of  \\_\\_bang\\_taylor4\\_softplus ; "
  },
  {
    "content": "\n 3.22.32. __bang_taylor4_tanh \n^^^^^^^^^^^^^^^\n void  __bang_taylor4_tanh (half * dst ,  const  half * src ,  const  half * aux1 ,  const  half * aux2 , unsigned int  elem_count )   \n void  __bang_taylor4_tanh (float * dst ,  const  float * src ,  const  float * aux1 ,  const  float * aux2 , unsigned int  elem_count )   \n Applies active with taylor4 (tanh) operation on  <src> . \n The function requires auxiliary  \\_\\_nram\\_\\_  space internally. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] aux1 : The auxiliary  \\_\\_nram\\_\\_  space 1.\n*  [in] aux2 : The auxiliary  \\_\\_nram\\_\\_  space 2.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  ,  <aux1>  and  <aux2>  must have the same size as  <src> ;\n*  <src>  ,  <aux1>  ,  <aux2>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  ,  <aux1>  ,  <aux2>  and  <src>  cannot be overlapped;\n* The address of  <src> ,  <aux1> ,  <aux2>  and  <dst>  must be 64-byte aligned on  (m)tp\\_2xx ;\n* The value of elements in  <src>  must be in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.000001 for  half  and  float  type respectively. "
  },
  {
    "content": "\n 3.23.1. __bang_band \n^^^^^^^^^^^^^^^\n void  __bang_band (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n Applies bit-wise AND operation on two vectors. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  can be overlapped with  <src0> ;\n*  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_SIZE 128 \n __mlu_entry__ void kernel(char* c, char* a, char* b) {\n  __nram__ char a_tmp[DATA_SIZE];\n  __nram__ char c_tmp[DATA_SIZE];\n  __nram__ char b_tmp[DATA_SIZE];\n  __memcpy(a_tmp, a, DATA_SIZE, GDRAM2NRAM);\n  __memcpy(b_tmp, b, DATA_SIZE, GDRAM2NRAM);\n  __bang_band(c_tmp, a_tmp, b_tmp, DATA_SIZE);\n  __memcpy(c, c_tmp, DATA_SIZE, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.23.2. __bang_band_scalar \n^^^^^^^^^^^^^^^\n void  __bang_band_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_band_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n void  __bang_band_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_band_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n void  __bang_band_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_band_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n This function performs bit-wise AND operation between  <elem\\_count>  elements of  <src>  and  <value>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  int ,  short  and  char  are not supported on  tp\\_520 ;\n*  <dst>  can be overlapped with  <src> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_SIZE 128 \n __mlu_entry__ void kernel(int* c, int* a, intt b) {\n  __nram__ int a_tmp[DATA_SIZE];\n  __nram__ int c_tmp[DATA_SIZE];\n  __memcpy(a_tmp, a, DATA_SIZE * sizeof(int), GDRAM2NRAM);\n  __bang_band_scalar(c_tmp, a_tmp, b, DATA_SIZE);\n  __memcpy(c, c_tmp, DATA_SIZE * sizeof(int), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.23.3. __bang_bnot \n^^^^^^^^^^^^^^^\n void  __bang_bnot (char * dst ,  const  char * src , unsigned int  elem_count )   \n Applies bit-wise NOT operation on a vector. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;"
  },
  {
    "content": "\n 3.23.4. __bang_bor \n^^^^^^^^^^^^^^^\n void  __bang_bor (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n Applies bit-wise OR operation on two vectors. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  can be overlapped with  <src0> ;\n*  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;"
  },
  {
    "content": "\n 3.23.5. __bang_bor_scalar \n^^^^^^^^^^^^^^^\n void  __bang_bor_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_bor_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n void  __bang_bor_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_bor_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n void  __bang_bor_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_bor_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n This function performs bit-wise OR operation between  <elem\\_count>  elements of  <src>  and  <value>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  int ,  short  and  char  are not supported on  tp\\_520 ;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.23.6. __bang_bxor \n^^^^^^^^^^^^^^^\n void  __bang_bxor (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n Applies bit-wise XOR operation on two vectors. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  can be overlapped with  <src0> ;\n*  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;"
  },
  {
    "content": "\n 3.23.7. __bang_bxor_scalar \n^^^^^^^^^^^^^^^\n void  __bang_bxor_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_bxor_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n void  __bang_bxor_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_bxor_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_bxor_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n void  __bang_bxor_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n This function performs bit-wise XOR operation between  <elem\\_count>  elements of  <src>  and  <value>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  int ,  short  and  char  are not supported on  tp\\_520 ;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.23.8. __bang_cycle_band \n^^^^^^^^^^^^^^^\n void  __bang_cycle_band (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts. Each element in each part applies bit-wise AND operation with the corresponding element in  <seg> . The result is assigned to  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src> ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;"
  },
  {
    "content": "\n 3.23.9. __bang_cycle_bor \n^^^^^^^^^^^^^^^\n void  __bang_cycle_bor (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts. Each element in each part applies bit-wise OR operation with the corresponding element in  <seg> . The result is assigned to  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src> ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;"
  },
  {
    "content": "\n 3.23.10. __bang_cycle_bxor \n^^^^^^^^^^^^^^^\n void  __bang_cycle_bxor (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts. Each element in each part applies bit-wise XOR operation with the corresponding element in  <seg> . The result is assigned to  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src> ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;"
  },
  {
    "content": "\n 3.24.1. __bang_argmax \n^^^^^^^^^^^^^^^\n void  __bang_argmax (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_argmax (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count )   \n void  __bang_argmax (float * dst ,  const  float * src , unsigned int  elem_count )   \n Finds the maximum value and its corresponding index in  <src>  vector except NaN. The result is composed of two parts. The first part is the maximum value of corresponding type, and the second part is the index of the first maximum value position in  <src>  vector, whose data type is  unsigned int . The maximum value and index are stored continuously in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_NUM 90 \n __mlu_entry__ void kernel_max(float* dst, float* src) {\n  __nram__ float dst_nram[DATA_NUM];\n  __nram__ float src_nram[DATA_NUM];\n  __memcpy(src_nram, src, DATA_NUM * sizeof(float), GDRAM2NRAM);\n  __bang_argmax(dst_nram, src_nram, DATA_NUM);\n  __memcpy(dst, dst_nram, DATA_NUM * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.24.2. __bang_argmin \n^^^^^^^^^^^^^^^\n void  __bang_argmin (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_argmin (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count )   \n void  __bang_argmin (float * dst ,  const  float * src , unsigned int  elem_count )   \n Finds the minimum value and its corresponding index in  <src>  vector except NaN. The result is composed of two parts. The first part is the minimum value of corresponding data type, and the second part is the index of the first minimum value position in  <src>  vector, whose data type is  unsigned int . The minimum value and index are stored continuously.\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_NUM 90 \n __mlu_entry__ void kernel_min(float* dst, float* src) {\n  __nram__ float dst_nram[DATA_NUM];\n  __nram__ float src_nram[DATA_NUM];\n  __memcpy(src_nram, src, DATA_NUM * sizeof(float), GDRAM2NRAM);\n  __bang_argmin(dst_nram, src_nram, DATA_NUM);\n  __memcpy(dst, dst_nram, DATA_NUM * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.24.3. __bang_cycle_eq \n^^^^^^^^^^^^^^^\n void  __bang_cycle_eq (int * dst ,  const  int * src ,  const  int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_eq (short * dst ,  const  short * src ,  const  short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_eq (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_eq (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_eq (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_eq (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts, then judges whether each element in each part and the corresponding element in  <seg>  are equal. The result is assigned to  <dst> . If the element of  <src>  is equal to  <value> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src> ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src\\_elem\\_count> \\* sizeof(type)  and  <seg\\_elem\\_count> \\* sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;\n*  <seg\\_elem\\_count> \\* sizeof(type)  cannot be greater than 65536 on  tp\\_322  when vector type is  int ,  short  and  char . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define N1 128 \n define N2 32640 \n __mlu_entry__ void kernel(float* c, float* a, float* b) {\n  __nram__ float a_tmp[N1];\n  __nram__ float b_tmp[N2];\n  __nram__ float c_tmp[N2];\n  __memcpy(a_tmp, a, N1 * sizeof(float), GDRAM2NRAM);\n  __memcpy(b_tmp, b, N2 * sizeof(float), GDRAM2NRAM);\n  __bang_cycle_eq(c_tmp, b_tmp, a_tmp, N2, N1);\n  __memcpy(c, c_tmp, N2 * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.24.4. __bang_cycle_equ \n^^^^^^^^^^^^^^^\n void  __bang_cycle_equ (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_equ (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_equ (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts, then judges whether each element in each part and the corresponding element in  <seg>  are unordered or equal. The result is assigned to  <dst> . If the element of  <src>  is unordered or equal to  <value> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src> ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero. \nExample \n``` \n include  \n define N1 128 \n define N2 32640 \n __mlu_entry__ void kernel(float* c, float* a, float* b) {\n  __nram__ float a_tmp[N1];\n  __nram__ float b_tmp[N2];\n  __nram__ float c_tmp[N2];\n  __memcpy(a_tmp, a, N1 * sizeof(float), GDRAM2NRAM);\n  __memcpy(b_tmp, b, N2 * sizeof(float), GDRAM2NRAM);\n  __bang_cycle_equ(c_tmp, b_tmp, a_tmp, N2, N1);\n  __memcpy(c, c_tmp, N2 * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.24.5. __bang_cycle_ge \n^^^^^^^^^^^^^^^\n void  __bang_cycle_ge (int * dst ,  const  int * src ,  const  int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_ge (short * dst ,  const  short * src ,  const  short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_ge (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_ge (unsigned int * dst ,  const  unsigned int * src ,  const  unsigned int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_ge (unsigned short * dst ,  const  unsigned short * src ,  const  unsigned short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_ge (unsigned char * dst ,  const  unsigned char * src ,  const  unsigned char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_ge (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_ge (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_ge (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts, then judges whether each element in each part is greater than or equal to the corresponding element in  <seg> . The result is assigned to  <dst> . If the element of  <src>  is greater than or equal to  <value> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src> ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  bfloat16\\_t  is supported on  (m)tp\\_5xx  or higher;*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src\\_elem\\_count> \\* sizeof(type)  and  <seg\\_elem\\_count> \\* sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;\n*  <seg\\_elem\\_count> \\* sizeof(type)  cannot be greater than 65536 on  tp\\_322  when vector type is  int ,  short ,  char ,  unsigned int ,  unsigned short  and  unsigned char . "
  },
  {
    "content": "\n 3.24.6. __bang_cycle_geu \n^^^^^^^^^^^^^^^\n void  __bang_cycle_geu (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_geu (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_geu (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts, then judges whether each element in each part is unordered or greater than or equal to the corresponding element in  <seg> . The result is assigned to  <dst> . If the element of  <src>  is unordered or greater than or equal to  <value> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src> ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.24.7. __bang_cycle_gt \n^^^^^^^^^^^^^^^\n void  __bang_cycle_gt (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_gt (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_gt (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts, then judges whether each element in each part is greater than the corresponding element in  <seg> . The result is assigned to  <dst> . If the element of  <src>  is greater than  <value> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src> ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src\\_elem\\_count> \\* sizeof(type)  and  <seg\\_elem\\_count> \\* sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx . "
  },
  {
    "content": "\n 3.24.8. __bang_cycle_gtu \n^^^^^^^^^^^^^^^\n void  __bang_cycle_gtu (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_gtu (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_gtu (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts, then judges whether each element in each part is unordered or greater than the corresponding element in  <seg> . The result is assigned to  <dst> . If the element of  <src>  is unordered or greater than  <value> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src> ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.24.9. __bang_cycle_le \n^^^^^^^^^^^^^^^\n void  __bang_cycle_le (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_le (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_le (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts, then judges whether each element in each part is less than or equal to the corresponding element in  <seg> . The result is assigned to  <dst> . If the element of  <src>  is less than or equal to  <value> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src\\_elem\\_count> \\* sizeof(type)  and  <seg\\_elem\\_count> \\* sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.24.10. __bang_cycle_leu \n^^^^^^^^^^^^^^^\n void  __bang_cycle_leu (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_leu (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_leu (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts, then judges whether each element in each part is unordered or less than or equal to the corresponding element in  <seg> . The result is assigned to  <dst> . If the element of  <src>  is unordered or less than or equal to  <value> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src> ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.24.11. __bang_cycle_lt \n^^^^^^^^^^^^^^^\n void  __bang_cycle_lt (int * dst ,  const  int * src ,  const  int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_lt (short * dst ,  const  short * src ,  const  short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_lt (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_lt (unsigned int * dst ,  const  unsigned int * src ,  const  unsigned int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_lt (unsigned short * dst ,  const  unsigned short * src ,  const  unsigned short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_lt (unsigned char * dst ,  const  unsigned char * src ,  const  unsigned char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_lt (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_lt (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_lt (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts, then judges whether each element in each part is less than the corresponding element in  <seg> . The result is assigned to  <dst> . If the element of  <src>  is less than  <value> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src\\_elem\\_count> \\* sizeof(type)  and  <seg\\_elem\\_count> \\* sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;\n*  <seg\\_elem\\_count> \\* sizeof(type)  cannot be greater than 65536 on  tp\\_322  when vector type is  int ,  short ,  char ,  unsigned int ,  unsigned short  and  unsigned char ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.24.12. __bang_cycle_ltu \n^^^^^^^^^^^^^^^\n void  __bang_cycle_ltu (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_ltu (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_ltu (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts, then judges whether each element in each part is unordered or less than the corresponding element in  <seg> . The result is assigned to  <dst> . If the element of  <src>  is unordered or less than  <value> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src> ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.24.13. __bang_cycle_maxequal \n^^^^^^^^^^^^^^^\n void  __bang_cycle_maxequal (int * dst ,  const  int * src ,  const  int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_maxequal (short * dst ,  const  short * src ,  const  short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_maxequal (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_maxequal (unsigned int * dst ,  const  unsigned int * src ,  const  unsigned int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_maxequal (unsigned short * dst ,  const  unsigned short * src ,  const  unsigned short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_maxequal (unsigned char * dst ,  const  unsigned char * src ,  const  unsigned char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_maxequal (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_maxequal (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_maxequal (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts. Each element in each part applies maxequal operation (select the maximum value) with the corresponding element in  <seg> . The result is assigned to  <dst> . If one of the elements being compared is a NaN, then the element in  <src>  is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src\\_elem\\_count> \\* sizeof(type)  and  <seg\\_elem\\_count> \\* sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;\n*  <seg\\_elem\\_count> \\* sizeof(type)  cannot be greater than 65536 on  tp\\_322  when vector type is  int ,  short ,  char ,  unsigned int ,  unsigned short  and  unsigned char ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define N1 128 \n define N2 32640 \n __mlu_entry__ void kernel(float *c, float *a, float *b) {\n  __nram__ float a_tmp[N1];\n  __nram__ float b_tmp[N2];\n  __nram__ float c_tmp[N2];\n  __memcpy(a_tmp, a, N1 * sizeof(float), GDRAM2NRAM);\n  __memcpy(b_tmp, b, N2 * sizeof(float), GDRAM2NRAM);\n  __bang_cycle_maxequal(c_tmp, b_tmp, a_tmp, N2, N1);\n  __memcpy(c, c_tmp, N2 * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.24.14. __bang_cycle_maximum \n^^^^^^^^^^^^^^^\n void  __bang_cycle_maximum (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_maximum (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_maximum (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts. Each element in each part applies max operation (select the maximum value) with the corresponding element in  <seg> . The result is assigned to  <dst> . If both of the elements being compared are NaN, then NaN is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . \n"
  },
  {
    "content": "\n 3.24.15. __bang_cycle_minequal \n^^^^^^^^^^^^^^^\n void  __bang_cycle_minequal (int * dst ,  const  int * src ,  const  int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_minequal (short * dst ,  const  short * src ,  const  short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_minequal (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_minequal (unsigned int * dst ,  const  unsigned int * src ,  const  unsigned int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_minequal (unsigned short * dst ,  const  unsigned short * src ,  const  unsigned short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_minequal (unsigned char * dst ,  const  unsigned char * src ,  const  unsigned char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_minequal (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_minequal (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_minequal (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts. Each element in each part applies minequal operation (select the minimum value) with the corresponding element in  <seg> . The result is assigned to  <dst> . If one of the elements being compared is a NaN, then the element in  <src>  is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src\\_elem\\_count> \\* sizeof(type)  and  <seg\\_elem\\_count> \\* sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;\n*  <seg\\_elem\\_count> \\* sizeof(type)  cannot be greater than 65536 on  tp\\_322  when vector type is  int ,  short ,  char ,  unsigned int ,  unsigned short  and  unsigned char ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.24.16. __bang_cycle_minimum \n^^^^^^^^^^^^^^^\n void  __bang_cycle_minimum (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_minimum (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_minimum (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts. Each element in each part applies min operation (select the minimum value) with the corresponding element in  <seg> . The result is assigned to  <dst> . If both of the elements being compared are NaN, then NaN is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . \n"
  },
  {
    "content": "\n 3.24.17. __bang_cycle_nan_maximum \n^^^^^^^^^^^^^^^\n void  __bang_cycle_nan_maximum (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_nan_maximum (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_nan_maximum (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts. Each element in each part applies max operation (select the maximum value) with the corresponding element in  <seg> . The result is assigned to  <dst> . If one of the elements being compared is a NaN, then that element is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . \n"
  },
  {
    "content": "\n 3.24.18. __bang_cycle_nan_minimum \n^^^^^^^^^^^^^^^\n void  __bang_cycle_nan_minimum (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_nan_minimum (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_nan_minimum (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts. Each element in each part applies min operation (select the minimum value) with the corresponding element in  <seg> . The result is assigned to  <dst> . If one of the elements being compared is a NaN, then that element is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . \n"
  },
  {
    "content": "\n 3.24.19. __bang_cycle_ne \n^^^^^^^^^^^^^^^\n void  __bang_cycle_ne (int * dst ,  const  int * src ,  const  int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_ne (short * dst ,  const  short * src ,  const  short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_ne (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_ne (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_ne (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_ne (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts, then judges whether each element in each part and the corresponding element in  <seg>  are NOT equal. The result is assigned to  <dst> . If the element of  <src>  is not equal to  <value> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n ;\n*  <src\\_elem\\_count> \\* sizeof(type)  and  <seg\\_elem\\_count> \\* sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;\n*  <seg\\_elem\\_count> \\* sizeof(type)  cannot be greater than 65536 on  tp\\_322  when vector type is  int ,  short  and  char ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.24.20. __bang_cycle_neu \n^^^^^^^^^^^^^^^\n void  __bang_cycle_neu (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_neu (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_neu (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts, then judges whether each element in each part and the corresponding element in  <seg>  are unordered or not equal. The result is assigned to  <dst> . If the element of  <src>  is unordered or not equal to  <value> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src> ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.24.21. __bang_eq \n^^^^^^^^^^^^^^^\n void  __bang_eq (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n void  __bang_eq (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_eq (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n void  __bang_eq (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_eq (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_eq (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function performs equality comparison with  <src0>  and  <src1>  and saves the result in  <dst> . If the element of  <src0>  and the element of  <src1>  are equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src0>  and  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n ;\n*  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  *  sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n #define DATA_SIZE 128 \n __mlu_entry__ void kernel(float* c, float* a, float* b) {\n   __nram__ float a_tmp[DATA_SIZE];\n   __nram__ float c_tmp[DATA_SIZE];\n   __nram__ float b_tmp[DATA_SIZE];\n   __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n   __memcpy(b_tmp, b, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n   __bang_eq(c_tmp, a_tmp, b_tmp, DATA_SIZE);\n   __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);\n } \n ``` \n"
  },
  {
    "content": "\n 3.24.22. __bang_eq_bitindex \n^^^^^^^^^^^^^^^\n void  __bang_eq_bitindex (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_eq_bitindex (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_eq_bitindex (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function performs equality comparison with  <src0>  and  <src1>  element-wisely. If the two elements are equal, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in  <dst> . \nThe comparison process is illustrated in the figure below, the comparison result between the first element  <element0>  of  <src0>  and the first element  <element0>  of  <src1>  will be saved in  <bit0>  of  <dst>  . The other elements do the same comparison in turn. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n #define DATA_SIZE 128 \n __mlu_entry__ void kernel(float* c, float* a, float* b) {\n   __nram__ float a_tmp[DATA_SIZE];\n   __nram__ float c_tmp[DATA_SIZE];\n   __nram__ float b_tmp[DATA_SIZE];\n   __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n   __memcpy(b_tmp, b, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n   __bang_eq_bitindex(c_tmp, a_tmp, b_tmp, DATA_SIZE);\n   __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);\n } \n ``` \n"
  },
  {
    "content": "\n 3.24.23. __bang_eq_scalar \n^^^^^^^^^^^^^^^\n void  __bang_eq_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n void  __bang_eq_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_eq_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n void  __bang_eq_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_eq_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_eq_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function performs equality comparison with  <elem\\_count>  elements of  <src>  and  <value>  and saves the result in  <dst> . If the element of  <src>  and  <value>  are equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_SIZE 128 \n __mlu_entry__ void kernel(float* c, float* a, float b) {\n  __nram__ float a_tmp[DATA_SIZE];\n  __nram__ float c_tmp[DATA_SIZE];\n  __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_eq_scalar(c_tmp, a_tmp, b, DATA_SIZE);\n  __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.24.24. __bang_equ \n^^^^^^^^^^^^^^^\n void  __bang_equ (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_equ (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_equ (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function performs unordered or equality comparison with  <src0>  and  <src1>  and saves the result in  <dst> . If the element of  <src0>  and the element of  <src1>  are unordered or equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src0>  and  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. \nExample \n``` \n include  \n #define DATA_SIZE 128 \n __mlu_entry__ void kernel(float* c, float* a, float* b) {\n   __nram__ float a_tmp[DATA_SIZE];\n   __nram__ float c_tmp[DATA_SIZE];\n   __nram__ float b_tmp[DATA_SIZE];\n   __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n   __memcpy(b_tmp, b, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n   __bang_equ(c_tmp, a_tmp, b_tmp, DATA_SIZE);\n   __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);\n } \n ``` \n"
  },
  {
    "content": "\n 3.24.25. __bang_equ_bitindex \n^^^^^^^^^^^^^^^\n void  __bang_equ_bitindex (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_equ_bitindex (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_equ_bitindex (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function performs unordered or equality comparison with  <src0>  and  <src1>  element-wisely. If the two elements are unordered or equal, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero and divisible by 8. \nExample \n``` \n include  \n #define DATA_SIZE 128 \n __mlu_entry__ void kernel(float* c, float* a, float* b) {\n   __nram__ float a_tmp[DATA_SIZE];\n   __nram__ float c_tmp[DATA_SIZE];\n   __nram__ float b_tmp[DATA_SIZE];\n   __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n   __memcpy(b_tmp, b, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n   __bang_equ_bitindex(c_tmp, a_tmp, b_tmp, DATA_SIZE);\n   __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);\n } \n ``` \n"
  },
  {
    "content": "\n 3.24.26. __bang_equ_scalar \n^^^^^^^^^^^^^^^\n void  __bang_equ_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_equ_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_equ_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function performs unordered or equality comparison with  <elem\\_count>  elements of  <src>  and  <value>  and saves the result in  <dst> . If the element of  <src>  and  <value>  are unordered or equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero. \nExample \n``` \n include  \n define DATA_SIZE 128 \n __mlu_entry__ void kernel(float* c, float* a, float b) {\n  __nram__ float a_tmp[DATA_SIZE];\n  __nram__ float c_tmp[DATA_SIZE];\n  __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_equ_scalar(c_tmp, a_tmp, b, DATA_SIZE);\n  __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.24.27. __bang_ge \n^^^^^^^^^^^^^^^\n void  __bang_ge (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n void  __bang_ge (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_ge (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n void  __bang_ge (unsigned int * dst ,  const  unsigned int * src0 ,  const  unsigned int * src1 , unsigned int  elem_count )   \n void  __bang_ge (unsigned short * dst ,  const  unsigned short * src0 ,  const  unsigned short * src1 , unsigned int  elem_count )   \n void  __bang_ge (unsigned char * dst ,  const  unsigned char * src0 ,  const  unsigned char * src1 , unsigned int  elem_count )   \n void  __bang_ge (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_ge (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_ge (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function compares with  <elem\\_count>  elements in  <src0>  and  <src1>  element-wisely to determine whether the element in  <src0>  is greater than or equal to that in  <src1>  and saves the result in  <dst> . If the element of  <src0>  is greater than or equal to the element of  <src1> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src0>  and  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first vector.\n*  [in] src1 : The address of the second vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  *  sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.24.28. __bang_ge_bitindex \n^^^^^^^^^^^^^^^\n void  __bang_ge_bitindex (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_ge_bitindex (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_ge_bitindex (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function compares with  <elem\\_count>  elements in  <src0>  and  <src1>  element-wisely, if the element of  <src0>  is greater than or equal to that of  <src1> , the result is 1. Otherwise, the result is 0. The result will be sequentially saved in  <dst> . \nThe comparison process is illustrated in the figure below, the comparison result between the first element  <element0>  of  <src0>  and the first element  <element0>  of  <src1>  will be saved in  <bit0>  of  <dst>  . The other elements do the same comparison in turn. \n Fig. 3.11 The Calculation Process of Half Type  \\_\\_bang\\_ge\\_bitindex \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.24.29. __bang_ge_scalar \n^^^^^^^^^^^^^^^\n void  __bang_ge_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n void  __bang_ge_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_ge_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n void  __bang_ge_scalar (unsigned int * dst ,  const  unsigned int * src , unsigned int  value , unsigned int  elem_count )   \n void  __bang_ge_scalar (unsigned short * dst ,  const  unsigned short * src , unsigned short  value , unsigned int  elem_count )   \n void  __bang_ge_scalar (unsigned char * dst ,  const  unsigned char * src , unsigned char  value , unsigned int  elem_count )   \n void  __bang_ge_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_ge_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_ge_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function compares  <elem\\_count>  elements in  <src>  with  <value>  to determine whether the elements are greater than or equal to  <value>  and saves the result in  <dst> . If the element of  <src>  is greater than or equal to  <value> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  int ,  short  and  char  are supported on  (m)tp\\_3xx  or higher;\n*  <elem\\_count>  must be greater than zero;\n*  int ,  short ,  char ,  unsigned int ,  unsigned short  and  unsigned char  are not supported on  tp\\_520 . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_SIZE 128 \n __mlu_entry__ void kernel(float* c, float* a, float b) {\n  __nram__ float a_tmp[DATA_SIZE];\n  __nram__ float c_tmp[DATA_SIZE];\n  __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_ge_scalar(c_tmp, a_tmp, b, DATA_SIZE);\n  __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.24.30. __bang_geu \n^^^^^^^^^^^^^^^\n void  __bang_geu (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_geu (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_geu (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function compares with  <elem\\_count>  elements in  <src0>  and  <src1>  element-wisely to determine whether the element in  <src0>  is unordered or greater than or equal to that in  <src1>  and saves the result in  <dst> . If the element of  <src0>  is unordered or greater than or equal to the element of  <src1> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src0>  and  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first vector.\n*  [in] src1 : The address of the second vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. \n"
  },
  {
    "content": "\n 3.24.31. __bang_geu_bitindex \n^^^^^^^^^^^^^^^\n void  __bang_geu_bitindex (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_geu_bitindex (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_geu_bitindex (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function compares with  <elem\\_count>  elements in  <src0>  and  <src1>  element-wisely, if the element of  <src0>  is unoredred or greater than or equal to that of  <src1> , the result is 1. Otherwise, the result is 0. The result will be sequentially saved in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero and divisible by 8. \n"
  },
  {
    "content": "\n 3.24.32. __bang_geu_scalar \n^^^^^^^^^^^^^^^\n void  __bang_geu_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_geu_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_geu_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function compares  <elem\\_count>  elements in  <src>  with  <value>  to determine whether the elements are unordered or greater than or equal to  <value>  and saves the result in  <dst> . If the element of  <src>  is unordered or greater than or equal to  <value> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero. \n"
  },
  {
    "content": "\n 3.24.33. __bang_gt \n^^^^^^^^^^^^^^^\n void  __bang_gt (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_gt (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_gt (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function compares with  <elem\\_count>  elements in  <src0>  and  <src1>  element-wisely to determine whether the element in  <src0>  is greater than that in  <src1>  and saves the result in  <dst> . If the element of  <src0>  is greater than the element of  <src1> , the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of  <src0>  and  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first vector.\n*  [in] src1 : The address of the second vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  *  sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.24.34. __bang_gt_bitindex \n^^^^^^^^^^^^^^^\n void  __bang_gt_bitindex (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_gt_bitindex (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_gt_bitindex (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function compares with  <elem\\_count>  elements in  <src0>  and  <src1>  element-wisely, if the element of  <src0>  is greater than that of  <src1> , the result is 1. Otherwise, the result is 0. The result will be sequentially saved in  <dst> . \nThe comparison process is illustrated in the figure below, the comparison result between the first element  <element0>  of  <src0>  and the first element  <element0>  of  <src1>  will be saved in  <bit0>  of  <dst>  . The other elements do the same comparison in turn. \n Fig. 3.12 The Calculation Process of Half Type  \\_\\_bang\\_gt\\_bitindex \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.24.35. __bang_gt_scalar \n^^^^^^^^^^^^^^^\n void  __bang_gt_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_gt_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_gt_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function compares  <elem\\_count>  elements in  <src>  with  <value>  to determine whether the elements are greater than  <value>  and saves the result in  <dst> . If the element of  <src>  is greater than  <value> , the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero\n "
  },
  {
    "content": "\n 3.24.36. __bang_gtu \n^^^^^^^^^^^^^^^\n void  __bang_gtu (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_gtu (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_gtu (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function compares with  <elem\\_count>  elements in  <src0>  and  <src1>  element-wisely to determine whether the element in  <src0>  is unordered or greater than that in  <src1>  and saves the result in  <dst> . If the element of  <src0>  is unordered or greater than the element of  <src1> , the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of  <src0>  and  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first vector.\n*  [in] src1 : The address of the second vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. \n"
  },
  {
    "content": "\n 3.24.37. __bang_gtu_bitindex \n^^^^^^^^^^^^^^^\n void  __bang_gtu_bitindex (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_gtu_bitindex (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_gtu_bitindex (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function compares with  <elem\\_count>  elements in  <src0>  and  <src1>  element-wisely, if the element of  <src0>  is unordered or greater than that of  <src1> , the result is 1. Otherwise, the result is 0. The result will be sequentially saved in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero and divisible by 8. \n"
  },
  {
    "content": "\n 3.24.38. __bang_gtu_scalar \n^^^^^^^^^^^^^^^\n void  __bang_gtu_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_gtu_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_gtu_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function compares  <elem\\_count>  elements in  <src>  with  <value>  to determine whether the elements are unordered or greater than  <value>  and saves the result in  <dst> . If the element of  <src>  is unordered or greater than  <value> , the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero. \n"
  },
  {
    "content": "\n 3.24.39. __bang_le \n^^^^^^^^^^^^^^^\n void  __bang_le (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_le (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_le (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function compares with  <elem\\_count>  elements in  <src0>  and  <src1>  element-wisely to determine whether the element in  <src0>  is less than or equal to that in  <src1>  and saves the result in  <dst> . If the element of  <src0>  is less than or equal to the element of  <src1> , the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of  <src0>  and  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first vector.\n*  [in] src1 : The address of the second vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  *  sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.24.40. __bang_le_bitindex \n^^^^^^^^^^^^^^^\n void  __bang_le_bitindex (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_le_bitindex (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_le_bitindex (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function compares with  <elem\\_count>  elements in  <src0>  and  <src1>  element-wisely, if the element of  <src0>  is less than or equal to that of  <src1> , the result is 1. Otherwise, the result is 0. The result will be sequentially saved in  <dst> . \nThe comparison process is illustrated in the figure below, the comparison result between the first element  <element0>  of  <src0>  and the first element  <element0>  of  <src1>  will be saved in  <bit0>  of  <dst>  . The other elements do the same comparison in turn. \n Fig. 3.13 The Calculation Process of Half Type  \\_\\_bang\\_le\\_bitindex \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.24.41. __bang_le_scalar \n^^^^^^^^^^^^^^^\n void  __bang_le_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_le_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_le_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function compares  <elem\\_count>  elements in  <src>  with  <value>  to determine whether the elements are less than or equal to  <value>  and saves the result in  <dst> . If the element of  <src>  is less than or equal to  <value> , the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero. \n "
  },
  {
    "content": "\n 3.24.42. __bang_leu \n^^^^^^^^^^^^^^^\n void  __bang_leu (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_leu (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_leu (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function compares with  <elem\\_count>  elements in  <src0>  and  <src1>  element-wisely to determine whether the element in  <src0>  is unordered or less than or equal to that in  <src1>  and saves the result in  <dst> . If the element of  <src0>  is unordered or less than or equal to the element of  <src1> , the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of  <src0>  and  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first vector.\n*  [in] src1 : The address of the second vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. \n"
  },
  {
    "content": "\n 3.24.43. __bang_leu_bitindex \n^^^^^^^^^^^^^^^\n void  __bang_leu_bitindex (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_leu_bitindex (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_leu_bitindex (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function compares with  <elem\\_count>  elements in  <src0>  and  <src1>  element-wisely, if the element of  <src0>  is unordered or less than or equal to that of  <src1> , the result is 1. Otherwise, the result is 0. The result will be sequentially saved in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero and divisible by 8. \n"
  },
  {
    "content": "\n 3.24.44. __bang_leu_scalar \n^^^^^^^^^^^^^^^\n void  __bang_leu_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_leu_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_leu_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function compares  <elem\\_count>  elements in  <src>  with  <value>  to determine whether the elements are unordered or less than or equal to  <value>  and saves the result in  <dst> . If the element of  <src>  is unordered or less than or equal to  <value> , the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero. \n"
  },
  {
    "content": "\n 3.24.45. __bang_lt \n^^^^^^^^^^^^^^^\n void  __bang_lt (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n void  __bang_lt (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_lt (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n void  __bang_lt (unsigned int * dst ,  const  unsigned int * src0 ,  const  unsigned int * src1 , unsigned int  elem_count )   \n void  __bang_lt (unsigned short * dst ,  const  unsigned short * src0 ,  const  unsigned short * src1 , unsigned int  elem_count )   \n void  __bang_lt (unsigned char * dst ,  const  unsigned char * src0 ,  const  unsigned char * src1 , unsigned int  elem_count )   \n void  __bang_lt (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_lt (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_lt (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function compares with  <elem\\_count>  elements in  <src0>  and  <src1>  element-wisely to determine whether the element in  <src0>  is less than that in  <src1>  and saves the result in  <dst> . If the element of  <src0>  is less than the element of  <src1> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src0>  and  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first vector.\n*  [in] src1 : The address of the second vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  *  sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.24.46. __bang_lt_bitindex \n^^^^^^^^^^^^^^^\n void  __bang_lt_bitindex (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_lt_bitindex (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_lt_bitindex (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function compares with  <elem\\_count>  elements in  <src0>  and  <src1>  element-wisely, if the element of  <src0>  is less than that of  <src1> , the result is 1. Otherwise, the result is 0. The result will be sequentially saved in  <dst> . \nThe comparison process is illustrated in the figure below, the comparison result between the first element  <element0>  of  <src0>  and the first element  <element0>  of  <src1>  will be saved in  <bit0>  of  <dst>  . The other elements do the same comparison in turn. \n Fig. 3.14 The Calculation Process of Half Type  \\_\\_bang\\_lt\\_bitindex \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.24.47. __bang_lt_scalar \n^^^^^^^^^^^^^^^\n void  __bang_lt_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n void  __bang_lt_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_lt_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n void  __bang_lt_scalar (unsigned int * dst ,  const  unsigned int * src , unsigned int  value , unsigned int  elem_count )   \n void  __bang_lt_scalar (unsigned short * dst ,  const  unsigned short * src , unsigned short  value , unsigned int  elem_count )   \n void  __bang_lt_scalar (unsigned char * dst ,  const  unsigned char * src , unsigned char  value , unsigned int  elem_count )   \n void  __bang_lt_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_lt_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_lt_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function compares  <elem\\_count>  elements in  <src>  with  <value>  to determine whether the elements are less than  <value>  and saves the result in  <dst> . If the element of  <src>  is less than  <value> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero;\n*  int ,  short ,  char ,  unsigned int ,  unsigned short  and  unsigned char  are not supported on  tp\\_520 . \n "
  },
  {
    "content": "\n 3.24.48. __bang_ltu \n^^^^^^^^^^^^^^^\n void  __bang_ltu (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_ltu (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_ltu (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function compares with  <elem\\_count>  elements in  <src0>  and  <src1>  element-wisely to determine whether the element in  <src0>  is unordered or less than that in  <src1>  and saves the result in  <dst> . If the element of  <src0>  is unordered or less than the element of  <src1> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src0>  and  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first vector.\n*  [in] src1 : The address of the second vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. \n"
  },
  {
    "content": "\n 3.24.49. __bang_ltu_bitindex \n^^^^^^^^^^^^^^^\n void  __bang_ltu_bitindex (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_ltu_bitindex (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_ltu_bitindex (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function compares with  <elem\\_count>  elements in  <src0>  and  <src1>  element-wisely, if the element of  <src0>  is unordered or less than that of  <src1> , the result is 1. Otherwise, the result is 0. The result will be sequentially saved in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero and divisible by 8. \n"
  },
  {
    "content": "\n 3.24.50. __bang_ltu_scalar \n^^^^^^^^^^^^^^^\n void  __bang_ltu_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_ltu_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_ltu_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function compares  <elem\\_count>  elements in  <src>  with  <value>  to determine whether the elements are unordered or less than  <value>  and saves the result in  <dst> . If the element of  <src>  is unordered or less than  <value> , the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero. \n"
  },
  {
    "content": "\n 3.24.51. __bang_maxeq_scalar \n^^^^^^^^^^^^^^^\n void  __bang_maxeq_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n void  __bang_maxeq_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_maxeq_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n void  __bang_maxeq_scalar (unsigned int * dst ,  const  unsigned int * src , unsigned int  value , unsigned int  elem_count )   \n void  __bang_maxeq_scalar (unsigned short * dst ,  const  unsigned short * src , unsigned short  value , unsigned int  elem_count )   \n void  __bang_maxeq_scalar (unsigned char * dst ,  const  unsigned char * src , unsigned char  value , unsigned int  elem_count )   \n void  __bang_maxeq_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_maxeq_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_maxeq_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function finds the maximum between  <elem\\_count>  elements of  <src>  and  <value>  and saves the result in  <dst> . If one of the elements being compared is a NaN, then the element in  <src>  is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero;\n*  int ,  short ,  char ,  unsigned int ,  unsigned short  and  unsigned char  are not supported on  tp\\_520 \n "
  },
  {
    "content": "\n 3.24.52. __bang_maxequal \n^^^^^^^^^^^^^^^\n void  __bang_maxequal (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n void  __bang_maxequal (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_maxequal (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n void  __bang_maxequal (unsigned int * dst ,  const  unsigned int * src0 ,  const  unsigned int * src1 , unsigned int  elem_count )   \n void  __bang_maxequal (unsigned short * dst ,  const  unsigned short * src0 ,  const  unsigned short * src1 , unsigned int  elem_count )   \n void  __bang_maxequal (unsigned char * dst ,  const  unsigned char * src0 ,  const  unsigned char * src1 , unsigned int  elem_count )   \n void  __bang_maxequal (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_maxequal (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_maxequal (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n Finds maximum value of each two corresponding elements in the two vectors. If one of the elements being compared are NaN, then the element in  <src0>  is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector\n*  [in] src0 : The address of first source vector\n*  [in] src1 : The address of second source vector\n*  [in] elem\\_count : The number of elements in source vector \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  int ,  short ,  char ,  unsigned int ,  unsigned short  and  unsigned char  are supported on  (m)tp\\_3xx  or higher except  tp\\_520 ;\n*  <elem\\_count>  must be greater than zero;\n*  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;*  <dst>  can be overlapped with  <src0> . "
  },
  {
    "content": "\n 3.24.53. __bang_maximum \n^^^^^^^^^^^^^^^\n void  __bang_maximum (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n void  __bang_maximum (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_maximum (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n Compares two vectors and returns a new vector containing the element-wise maxima. If both of the elements being compared are NaN, then NaN is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector\n*  [in] src0 : The address of first source vector\n*  [in] src1 : The address of second source vector\n*  [in] elem\\_count : The number of elements in source vector \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src0>  or  <src1> . \n"
  },
  {
    "content": "\n 3.24.54. __bang_maximum_scalar \n^^^^^^^^^^^^^^^\n void  __bang_maximum_scalar (float * dst , float * src , float  value , unsigned int  elem_count )   \n void  __bang_maximum_scalar (half * dst , half * src , half  value , unsigned int  elem_count )   \n void  __bang_maximum_scalar (bfloat16_t * dst , bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n This function finds the maximum between  <elem\\_count>  elements of  <src>  and  <value>  and saves the result in  <dst> . If only one of the element in  <src>  and  <value>  is NaN, the result is the other. If both of the elements in  <src>  and  <value>  are NaN, the result is NaN. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.24.55. __bang_mineq_scalar \n^^^^^^^^^^^^^^^\n void  __bang_mineq_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n void  __bang_mineq_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_mineq_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n void  __bang_mineq_scalar (unsigned int * dst ,  const  unsigned int * src , unsigned int  value , unsigned int  elem_count )   \n void  __bang_mineq_scalar (unsigned short * dst ,  const  unsigned short * src , unsigned short  value , unsigned int  elem_count )   \n void  __bang_mineq_scalar (unsigned char * dst ,  const  unsigned char * src , unsigned char  value , unsigned int  elem_count )   \n void  __bang_mineq_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_mineq_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_mineq_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function finds the minimum between  <elem\\_count>  elements of  <src>  and  <value>  and saves the result in  <dst> . If one of the elements being compared is a NaN, then the element in  <src>  is returned. See the table :ref: floating\\_point\\_calculation\\_of\\_stream\\_and\\_scalar\\_binary\\_operation\\_functions  for accuracy information. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero;\n*  int ,  short ,  char ,  unsigned int ,  unsigned short  and  unsigned char  are not supported on  tp\\_520 \n "
  },
  {
    "content": "\n 3.24.56. __bang_minequal \n^^^^^^^^^^^^^^^\n void  __bang_minequal (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n void  __bang_minequal (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_minequal (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n void  __bang_minequal (unsigned int * dst ,  const  unsigned int * src0 ,  const  unsigned int * src1 , unsigned int  elem_count )   \n void  __bang_minequal (unsigned short * dst ,  const  unsigned short * src0 ,  const  unsigned short * src1 , unsigned int  elem_count )   \n void  __bang_minequal (unsigned char * dst ,  const  unsigned char * src0 ,  const  unsigned char * src1 , unsigned int  elem_count )   \n void  __bang_minequal (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_minequal (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_minequal (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n Finds minimum value of each two corresponding elements in the two vectors. If one of the elements being compared are NaN, then the element in  <src0>  is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector\n*  [in] src0 : The address of first source vector\n*  [in] src1 : The address of second source vector\n*  [in] elem\\_count : The number of elements in source vector \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  int ,  short ,  char ,  unsigned int ,  unsigned short  and  unsigned char  are supported on  (m)tp\\_3xx  or higher except  tp\\_520 ;\n*  <elem\\_count>  must be greater than zero;\n*  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;*  <dst>  can be overlapped with  <src0> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_SIZE 64 \n __mlu_entry__ void kernel(half* c, half* a, half* b) {\n  __nram__ half a_tmp[DATA_SIZE];\n  __nram__ half c_tmp[DATA_SIZE];\n  __nram__ half b_tmp[DATA_SIZE];\n  __memcpy(a_tmp, a, DATA_SIZE * sizeof(half), GDRAM2NRAM);\n  __memcpy(b_tmp, b, DATA_SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_minequal(c_tmp, a_tmp, b_tmp, DATA_SIZE);\n  __memcpy(c, c_tmp, DATA_SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.24.57. __bang_minimum \n^^^^^^^^^^^^^^^\n void  __bang_minimum (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n void  __bang_minimum (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_minimum (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n Compares two vectors and returns a new vector containing the element-wise minima. If both of the elements being compared are NaN, then NaN is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector\n*  [in] src0 : The address of first source vector\n*  [in] src1 : The address of second source vector\n*  [in] elem\\_count : The number of elements in source vector \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src0>  or  <src1> . \n"
  },
  {
    "content": "\n 3.24.58. __bang_minimum_scalar \n^^^^^^^^^^^^^^^\n void  __bang_minimum_scalar (float * dst , float * src , float  value , unsigned int  elem_count )   \n void  __bang_minimum_scalar (half * dst , half * src , half  value , unsigned int  elem_count )   \n void  __bang_minimum_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n This function finds the minimum between  <elem\\_count>  elements of  <src>  and  <value>  and saves the result in  <dst> . If only one of the element in  <src>  and  <value>  is NaN, the result is the other. If both of the elements in  <src>  and  <value>  are NaN, the result is NaN. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.24.59. __bang_nan_argmax \n^^^^^^^^^^^^^^^\n void  __bang_nan_argmax (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_nan_argmax (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count )   \n void  __bang_nan_argmax (float * dst ,  const  float * src , unsigned int  elem_count )   \n Finds the maximum value and its corresponding index in  <src>  vector. The result is composed of two parts. The first part is the maximum value of corresponding type, and the second part is the index of the first maximum value position in  <src>  vector, whose data type is  unsigned int . The maximum value and index are stored continuously in  <dst> . If one of the elements being compared is a NaN, then that element and its corresponding index are returned.\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_NUM 90 \n __mlu_entry__ void kernel_max(float* dst, float* src) {\n  __nram__ float dst_nram[DATA_NUM];\n  __nram__ float src_nram[DATA_NUM];\n  __memcpy(src_nram, src, DATA_NUM * sizeof(float), GDRAM2NRAM);\n  __bang_nan_argmax(dst_nram, src_nram, DATA_NUM);\n  __memcpy(dst, dst_nram, DATA_NUM * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.24.60. __bang_nan_argmin \n^^^^^^^^^^^^^^^\n void  __bang_nan_argmin (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_nan_argmin (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count )   \n void  __bang_nan_argmin (float * dst ,  const  float * src , unsigned int  elem_count )   \n Finds the minimum value and its corresponding index in  <src>  vector. The result is composed of two parts. The first part is the minimum value of corresponding type, and the second part is the index of the first minimum value position in  <src>  vector, whose data type is  unsigned int . The minimum value and index are stored continuously in  <dst> . If one of the elements being compared is a NaN, then that element and its corresponding index are returned.\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_NUM 90 \n __mlu_entry__ void kernel_min(float* dst, float* src) {\n  __nram__ float dst_nram[DATA_NUM];\n  __nram__ float src_nram[DATA_NUM];\n  __memcpy(src_nram, src, DATA_NUM * sizeof(float), GDRAM2NRAM);\n  __bang_nan_argmin(dst_nram, src_nram, DATA_NUM);\n  __memcpy(dst, dst_nram, DATA_NUM * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.24.61. __bang_nan_maximum \n^^^^^^^^^^^^^^^\n void  __bang_nan_maximum (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_nan_maximum (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_nan_maximum (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n Compares two vectors and returns a new vector containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector\n*  [in] src0 : The address of first source vector\n*  [in] src1 : The address of second source vector\n*  [in] elem\\_count : The number of elements in source vector \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src0>  or  <src1> . \n"
  },
  {
    "content": "\n 3.24.62. __bang_nan_maximum_scalar \n^^^^^^^^^^^^^^^\n void  __bang_nan_maximum_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n void  __bang_nan_maximum_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_nan_maximum_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n This function finds the maximum between  <elem\\_count>  elements of  <src>  and  <value>  and saves the result in  <dst> . If only one of the element in  <src>  and  <value>  is NaN, the result is NaN. If both of the elements in  <src>  and  <value>  are NaN, the result is NaN. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero; "
  },
  {
    "content": "\n 3.24.63. __bang_nan_minimum \n^^^^^^^^^^^^^^^\n void  __bang_nan_minimum (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_nan_minimum (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_nan_minimum (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n Compares two vectors and returns a new vector containing the element-wise minima. If one of the elements being compared is a NaN, then that element is returned. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector\n*  [in] src0 : The address of first source vector\n*  [in] src1 : The address of second source vector\n*  [in] elem\\_count : The number of elements in source vector \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src0>  or  <src1> . \n"
  },
  {
    "content": "\n 3.24.64. __bang_nan_minimum_scalar \n^^^^^^^^^^^^^^^\n void  __bang_nan_minimum_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n void  __bang_nan_minimum_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_nan_minimum_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n This function finds the minimum between  <elem\\_count>  elements of  <src>  and  <value>  and saves the result in  <dst> . If only one of the element in  <src>  and  <value>  is NaN, the result is NaN. If both of the elements in  <src>  and  <value>  are NaN, the result is NaN. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.24.65. __bang_ne \n^^^^^^^^^^^^^^^\n void  __bang_ne (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n void  __bang_ne (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_ne (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n void  __bang_ne (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_ne (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_ne (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function performs inequality comparison with  <src0>  and  <src1>  element-wisely and saves the result in  <dst> . If the element of  <src0>  and the element of  <src1>  are not equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src0>  and  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n ;\n*  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  *  sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.24.66. __bang_ne_bitindex \n^^^^^^^^^^^^^^^\n void  __bang_ne_bitindex (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_ne_bitindex (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_ne_bitindex (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function performs inequality comparison with  <src0>  and  <src1>  element-wisely. If the two elements are not equal, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in  <dst> . \nThe comparison process is illustrated in the figure below, the comparison result between the first element  <element0>  of  <src0>  and the first element  <element0>  of  <src1>  will be saved in  <bit0>  of  <dst>  . The other elements do the same comparison in turn. \n Fig. 3.15 The Calculation Process of Half Type  \\_\\_bang\\_ne\\_bitindex \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  must be divisible by 512 on  (m)tp\\_2xx ;*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.24.67. __bang_ne_scalar \n^^^^^^^^^^^^^^^\n void  __bang_ne_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n void  __bang_ne_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_ne_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n void  __bang_ne_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_ne_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_ne_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function performs inequality comparison with  <elem\\_count>  elements of  <src>  and  <value>  and saves the result in  <dst> . The type of result is same as the type of  <src> . If the element of  <src>  and  <value>  are not equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero;\n*  int ,  short  and  char  are not supported on  tp\\_520 . \n "
  },
  {
    "content": "\n 3.24.68. __bang_neu \n^^^^^^^^^^^^^^^\n void  __bang_neu (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_neu (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_neu (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function performs unoredred or inequality comparison with  <src0>  and  <src1>  element-wisely and saves the result in  <dst> . If the element of  <src0>  and the element of  <src1>  are unordered or not equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src0>  and  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. \n"
  },
  {
    "content": "\n 3.24.69. __bang_neu_bitindex \n^^^^^^^^^^^^^^^\n void  __bang_neu_bitindex (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_neu_bitindex (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_neu_bitindex (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function performs unordered or inequality comparison with  <src0>  and  <src1>  element-wisely. If the two elements are unordered or not equal, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0>  ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero and divisible by 8. \n"
  },
  {
    "content": "\n 3.24.70. __bang_neu_scalar \n^^^^^^^^^^^^^^^\n void  __bang_neu_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_neu_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_neu_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function performs unordered or inequality comparison with  <elem\\_count>  elements of  <src>  and  <value>  and saves the result in  <dst> . The type of result is same as the type of  <src> . If the element of  <src>  and  <value>  are unordered or not equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero. \n"
  },
  {
    "content": "\n 3.25.1. __bang_fcmpfilter \n^^^^^^^^^^^^^^^\n void  __bang_fcmpfilter (CompareMode  mode , half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_fcmpfilter (CompareMode  mode , half * dst ,  const  half * src0 , half  src1 , unsigned int  elem_count )   \n void  __bang_fcmpfilter (CompareMode  mode , float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n void  __bang_fcmpfilter (CompareMode  mode , bfloat16_t * dst ,  const  bfloat16_t * src0 , bfloat16_t  src1 , unsigned int  elem_count )   \n void  __bang_fcmpfilter (CompareMode  mode , bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_fcmpfilter (CompareMode  mode , float * dst ,  const  float * src0 , float  src1 , unsigned int  elem_count )   \n This function performs element-wise comparison with  <src0>  and  <src1>  according to  <mode> .  <mode>  indicates the type of comparison.  <mode>  is assigned to an enumerated type called  CompareMode  that contains six enumerators listed in the table below. The elements in  <src0>  that meet the given comparison criteria  <mode>  will be selected and written to  <dst>  continuously. The result is composed of two parts. The first part is the number of selected elements in  <src0> , whose data type is  unsigned int , and the second part is the selected elements. \n Table 3.58 Semantics of  CompareMode \n |  CompareMode  Type | Semantic |\n| --- | --- |\n|  CMP\\_EQ  | (=) |\n|  CMP\\_NE  | (\\neq) |\n|  CMP\\_LT  | (<) |\n|  CMP\\_LE  | (\\leq) |\n|  CMP\\_GT  | (>) |\n|  CMP\\_GE  | (\\geq) | \n^^^^^^^^^^^^^^^\n Parameters *  [in] mode : The comparison mode.\n*  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector or the second source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space.  <src1>  must also point to  \\_\\_nram\\_\\_  address space if it is a vector;\n*  <src1>  can be either vectors or scalars. When  <src1>  is a vector, the length of  <src1>  must be the same as that of  <src0> ;\n*  <dst>  can be overlapped with  <src0> ;\n*  <elem\\_count>  must be greater than zero. \n ^^^^^^^^^^^^^^^\n Example \n```\n #include  \n #define ELEM_NUM 128\n #define RES_ELEM_NUM (ELEM_NUM + 1) \n __mlu_entry__ void kernel_fabs(CompareMode mode, float* dst,\n                                float *src0, float *src1) {\n   __nram__ float dst_nram[RES_ELEM_NUM];\n   __nram__ float src0_nram[ELEM_NUM];\n   __nram__ float src1_nram[ELEM_NUM];\n   __memcpy(src0_nram, src0, ELEM_NUM * sizeof(float), GDRAM2NRAM);\n   __memcpy(src1_nram, src1, ELEM_NUM * sizeof(float), GDRAM2NRAM);\n   __bang_fcmpfilter(mode, dst_nram, src0_nram, src1_nram, ELEM_NUM);\n   __memcpy(dst, dst_nram, RES_ELEM_NUM * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.25.2. __bang_fusion \n^^^^^^^^^^^^^^^\n void  __bang_fusion (mluFusionOpCode  op_code , half * dst ,  const  half * src0 , half  src1 , half  src2 , unsigned int  src_elem_count )   \n void  __bang_fusion (mluFusionOpCode  op_code , float * dst ,  const  float * src0 ,  const  float * src1 , float  src2 , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_fusion (mluFusionOpCode  op_code , float * dst ,  const  float * src0 , float  src1 ,  const  float * src2 , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_fusion (mluFusionOpCode  op_code , float * dst ,  const  float * src0 , float  src1 , float  src2 , unsigned int  src_elem_count )   \n void  __bang_fusion (mluFusionOpCode  op_code , half * dst ,  const  half * src0 ,  const  half * src1 ,  const  half * src2 , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_fusion (mluFusionOpCode  op_code , half * dst ,  const  half * src0 ,  const  half * src1 , half  src2 , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_fusion (mluFusionOpCode  op_code , half * dst ,  const  half * src0 , half  src1 ,  const  half * src2 , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_fusion (mluFusionOpCode  op_code , bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 ,  const  bfloat16_t * src2 , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_fusion (mluFusionOpCode  op_code , bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , bfloat16_t  src2 , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_fusion (mluFusionOpCode  op_code , bfloat16_t * dst ,  const  bfloat16_t * src0 , bfloat16_t  src1 ,  const  bfloat16_t * src2 , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_fusion (mluFusionOpCode  op_code , bfloat16_t * dst ,  const  bfloat16_t * src0 , bfloat16_t  src1 , bfloat16_t  src2 , unsigned int  src_elem_count )   \n void  __bang_fusion (mluFusionOpCode  op_code , float * dst ,  const  float * src0 ,  const  float * src1 ,  const  float * src2 , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n This function performs fused arithmetic calculation on vectors  <src0>  ,  <src1>  and  <src2>  element-wisely according to  <op\\_code>  and saves the result in  <dst> .  <op\\_code>  indicates the type of operator.  <op\\_code>  is assigned to an enumerated type called  mluFusionOpCode  that contains eight enumerators listed in the table below.  \n Table 3.59 Semantics of  mluFusionOpCode \n |  mluFusionOpCode  Type | Semantic |\n| --- | --- |\n|  FUSION\\_FMA  | (  =   \\times   +  ) |\n|  FUSION\\_FMS  | (  =   \\times   -  ) |\n|  FUSION\\_FAM  | (  = (  +  ) \\times  ) |\n|  FUSION\\_FSM  | (  = (  -  ) \\times  ) |\n|  FUSION\\_FAA  | (  =   +   +  ) |\n|  FUSION\\_FAS  | (  =   +   -  ) |\n|  FUSION\\_FSS  | (  =   -   -  ) |\n|  FUSION\\_FSA  | (  =   -   +  ) | \n^^^^^^^^^^^^^^^\n Note \n For the last two characters of enumerators, \u2018M\u2019 means multiplication, \u2018A\u2019 means addition and \u2018S\u2019 means subtraction. \n^^^^^^^^^^^^^^^\n Parameters *  [in] op\\_code : The type of operator.\n*  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The second source scalar or the address of the second source vector.\n*  [in] src2 : The third source scalar or the address of the third source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <dst>  and  <src0> .\n*  [in] seg\\_elem\\_count : The number of elements in  <src1>  and  <src2> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  can be overlapped with  <src0> ;\n*  <src0>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src1>  or  <src2>  must also point to  \\_\\_nram\\_\\_  address space if it is a vector;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero. \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define BUF_SIZE 128 \n __mlu_entry__ void kernel(float *mlu_dst,\n                          float *mlu_src0,\n                          float *mlu_src1,\n                          float *mlu_src2) {\n    __nram__ float nram_output[BUF_SIZE];\n    __nram__ float nram_input0[BUF_SIZE];\n    __nram__ float nram_input1[BUF_SIZE];\n    __nram__ float nram_input2[BUF_SIZE];\n    __memcpy(nram_input0, mlu_src0, BUF_SIZE * sizeof(float), GDRAM2NRAM);\n    __memcpy(nram_input1, mlu_src1, BUF_SIZE * sizeof(float), GDRAM2NRAM);\n    __memcpy(nram_input2, mlu_src2, BUF_SIZE * sizeof(float), GDRAM2NRAM);\n    __bang_fusion(FUSION_FMA, nram_output, nram_input0,\n                  nram_input1, nram_input2, BUF_SIZE, BUF_SIZE);\n    __memcpy(mlu_dst, nram_output, BUF_SIZE, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.26.1. __bang_and \n^^^^^^^^^^^^^^^\n void  __bang_and (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_and (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n void  __bang_and (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_and (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n void  __bang_and (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_and (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n Performs logical AND operation between elements in two vectors. If both the elements of  <src0>  and  <src1>  are non-zero, the result is 1. Otherwise, the result is 0. The type of result is the same as that of  <src0>  and  <src1> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark ;\n*  <elem\\_count>  must be greater than zero;\n*  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;*  <dst>  can be overlapped with  <src0> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_SIZE 128 \n __mlu_entry__ void kernel(half* c, half* a, half* b) {\n  __nram__ half a_tmp[DATA_SIZE];\n  __nram__ half c_tmp[DATA_SIZE];\n  __nram__ half b_tmp[DATA_SIZE];\n  __memcpy(a_tmp, a, DATA_SIZE * sizeof(half), GDRAM2NRAM);\n  __memcpy(b_tmp, b, DATA_SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_and(c_tmp, a_tmp, b_tmp, DATA_SIZE);\n  __memcpy(c, c_tmp, DATA_SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.26.2. __bang_and_scalar \n^^^^^^^^^^^^^^^\n void  __bang_and_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_and_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n void  __bang_and_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_and_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n void  __bang_and_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_and_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function performs logical AND operation between  <elem\\_count>  elements of  <src>  and  <value>  and saves the result in  <dst> . If both the elements of  <src>  and  <value>  are non-zero, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero;\n*  int ,  short  and  char  are not supported on  tp\\_520 . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_SIZE 128 \n __mlu_entry__ void kernel(float* c, float* a, float b) {\n  __nram__ float a_tmp[DATA_SIZE];\n  __nram__ float c_tmp[DATA_SIZE];\n  __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_and_scalar(c_tmp, a_tmp, b, DATA_SIZE);\n  __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.26.3. __bang_cycle_and \n^^^^^^^^^^^^^^^\n void  __bang_cycle_and (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_and (int * dst ,  const  int * src ,  const  int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_and (short * dst ,  const  short * src ,  const  short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_and (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_and (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_and (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts. Each element in each part AND the corresponding element in  <seg> . The result is assigned to  <dst> . If both the elements of  <src0>  and  <src1>  are non-zero, the result is 1. Otherwise, the result is 0. The type of result is the same as that of  <src0>  and  <src1> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark ;\n*  <src\\_elem\\_count> \\* sizeof(type)  and  <seg\\_elem\\_count> \\* sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;\n*  <seg\\_elem\\_count> \\* sizeof(type)  cannot be greater than 65536 on  tp\\_322  when vector type is  int ,  short  and  char ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define N1 128 \n define N2 32640 \n __mlu_entry__ void kernel(float *c, float *a, float *b) {\n  __nram__ float a_tmp[N1];\n  __nram__ float b_tmp[N2];\n  __nram__ float c_tmp[N2];\n  __memcpy(a_tmp, a, N1 * sizeof(float), GDRAM2NRAM);\n  __memcpy(b_tmp, b, N2 * sizeof(float), GDRAM2NRAM);\n  __bang_cycle_and(c_tmp, b_tmp, a_tmp, N2, N1);\n  __memcpy(c, c_tmp, N2 * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.26.4. __bang_cycle_or \n^^^^^^^^^^^^^^^\n void  __bang_cycle_or (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_or (int * dst ,  const  int * src ,  const  int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_or (short * dst ,  const  short * src ,  const  short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_or (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_or (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_or (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts. Each element in each part OR the corresponding element in  <seg> . The result is assigned to  <dst> . If both the elements of  <src0>  and  <src1>  are zero, the result is 0. Otherwise, the result is 1. The type of result is the same as that of  <src0>  and  <src1> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark ;\n*  <src\\_elem\\_count> \\* sizeof(type)  and  <seg\\_elem\\_count> \\* sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;\n*  <seg\\_elem\\_count> \\* sizeof(type)  cannot be greater than 65536 on  tp\\_322  when vector type is  int ,  short  and  char ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.26.5. __bang_cycle_xor \n^^^^^^^^^^^^^^^\n void  __bang_cycle_xor (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_xor (int * dst ,  const  int * src ,  const  int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_xor (short * dst ,  const  short * src ,  const  short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_xor (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_xor (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_xor (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Divides  <src>  into  <src\\_elem\\_count>  /  <seg\\_elem\\_count>  parts. Each element in each part XOR the corresponding element in  <seg> . The result is assigned to  <dst> . If both the elements of  <src0>  and  <src1>  are zero or non-zero, the result is 0. Otherwise, the result is 1. The type of result is the same as that of  <src0>  and  <src1> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  int ,  short  and  char  are supported on  (m)tp\\_3xx  or higher, except  tp\\_520 ;\n*  <src\\_elem\\_count> \\* sizeof(type)  and  <seg\\_elem\\_count> \\* sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;\n*  <seg\\_elem\\_count> \\* sizeof(type)  cannot be greater than 65536 on  tp\\_322  when vector type is  int ,  short  and  char ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.26.6. __bang_not \n^^^^^^^^^^^^^^^\n void  __bang_not (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_not (int * dst ,  const  int * src , unsigned int  elem_count )   \n void  __bang_not (short * dst ,  const  short * src , unsigned int  elem_count )   \n void  __bang_not (char * dst ,  const  char * src , unsigned int  elem_count )   \n void  __bang_not (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count )   \n void  __bang_not (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies element-wisely NOT operation on a vector. For each element in  <src> , if it equals to zero, then stores 1 at the corresponding position in  <dst> ; otherwise, stores 0 at the position in  <dst> . The type of result is the same as that of  <src> . See the table Floating Point Calculation of Stream and Scalar Unary Logic and Bit Operation Functions for accuracy information. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark ;\n*  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.26.7. __bang_or \n^^^^^^^^^^^^^^^\n void  __bang_or (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_or (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n void  __bang_or (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_or (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n void  __bang_or (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_or (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n Performs logical OR operation between elements in two vectors. If both the elements of  <src0>  and  <src1>  are zero, the result is 0. Otherwise, the result is 1. The type of result is the same as that of  <src0>  and  <src1> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark ;\n*  <elem\\_count>  must be greater than zero;\n*  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.26.8. __bang_or_scalar \n^^^^^^^^^^^^^^^\n void  __bang_or_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_or_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n void  __bang_or_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_or_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n void  __bang_or_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_or_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function performs logical OR operation between  <elem\\_count>  elements of  <src>  and  <value>  and saves the result in  <dst> . If either the element of  <src>  or  <value>  is non-zero, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  int ,  short  and  char  are supported on  (m)tp\\_3xx  or higher;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero;\n*  int ,  short  and  char  are not supported on  tp\\_520 . "
  },
  {
    "content": "\n 3.26.9. __bang_xor \n^^^^^^^^^^^^^^^\n void  __bang_xor (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_xor (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n void  __bang_xor (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_xor (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n void  __bang_xor (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_xor (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n Performs logical XOR operation between elements in two vectors. If both the elements of  <src0>  and  <src1>  are zero or non-zero, the result is 0. Otherwise, the result is 1. The type of result is the same as that of  <src0>  and  <src1> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark ;\n*  <elem\\_count>  must be greater than zero;\n*  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;*  <dst>  can be overlapped with  <src0> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_SIZE 128 \n __mlu_entry__ void kernel(half* c, half* a, half* b) {\n  __nram__ half a_tmp[DATA_SIZE];\n  __nram__ half c_tmp[DATA_SIZE];\n  __nram__ half b_tmp[DATA_SIZE];\n  __memcpy(a_tmp, a, DATA_SIZE * sizeof(half), GDRAM2NRAM);\n  __memcpy(b_tmp, b, DATA_SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_xor(c_tmp, a_tmp, b_tmp, DATA_SIZE);\n  __memcpy(c, c_tmp, DATA_SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.26.10. __bang_xor_scalar \n^^^^^^^^^^^^^^^\n void  __bang_xor_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_xor_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n void  __bang_xor_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_xor_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n void  __bang_xor_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_xor_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function performs logical OR operation between  <elem\\_count>  elements of  <src>  and  <value>  and saves the result in  <dst> . If the element of  <src>  is zero and  <value>  is non-zero, or the element of  <src>  is non-zero and  <value>  is zero, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of  <src> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  int ,  short  and  char  are supported on  (m)tp\\_3xx  or higher;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero;\n*  int ,  short  and  char  are not supported on  tp\\_520 . "
  },
  {
    "content": "\n 3.27.2. __bang_filter_bitindex \n^^^^^^^^^^^^^^^\n unsigned int  __bang_filter_bitindex (half * dst ,  const  half * src ,  const  void * bitmask , unsigned int  elem_count )   \n unsigned int  __bang_filter_bitindex (float * dst ,  const  float * src ,  const  void * bitmask , unsigned int  elem_count )   \n unsigned int  __bang_filter_bitindex (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  void * bitmask , unsigned int  elem_count )   \n Copies elements from  <src>  to  <dst>  if the corresponding bit values in  <bitmask>  is not equal to zero, and returns the number of selected elements. The selected elements are stored continuously in  <dst> . The behavior is illustrated in the figure below, in this example,  <bitmask>  is 0x41100000. \n Fig. 3.16 The Calculation Process of Floating-point Type  \\_\\_bang\\_filter\\_bitindex \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] bitmask : The address of second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  unsigned int . \n^^^^^^^^^^^^^^^\n *  <elem\\_count>  must be greater than zero;\n*  <dst>  can be overlapped with  <src> ;\n* The  <src> ,  <bitmask>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* The address of  <src> ,  <bitmask>  and  <dst>  must be 64-byte aligned on  (m)tp\\_2xx ;\n* On  (m)tp\\_2xx , if the total number of bytes of the selected elements is not a multiple of 128, it will be aligned to 128 bytes, and the padding bytes will be set to zero;\n* On  (m)tp\\_2xx , the reserved space for selected data in  <dst>  cannot be smaller than the size of  <src>  and if the selected elements(including pad) does not fill the entire  <dst>  space, the remaining data in  <dst>  may also be changed. \n "
  },
  {
    "content": "\n 3.27.3. __bang_maskmove \n^^^^^^^^^^^^^^^\n void  __bang_maskmove (void * dst ,  const  void * src ,  const  void * mask , unsigned int  size )   \n Selects bytes in  <src> , whose length is  <size> , according to the bit value of the vector  <mask> , and stores the result in  <dst> . The bytes in  <src>  will be selected if corresponding bit in  <mask>  is 1, otherwise, keeps the corresponding byte in  <dst>  unchanged. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] mask : The address of mask vector.\n*  [in] size : The length of source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <size>  must be greater than zero;\n*  <size>  must be divisible by 1024 on  (m)tp\\_2xx ;\n*  <size>  must be divisible by 8 on  (m)tp\\_3xx ;\n*  <src> ,  <mask>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* The address of  <src> ,  <mask>  and  <dst>  must be 64-byte aligned on  (m)tp\\_2xx ;\n*  <dst>  can be overlapped with  <src> . \n"
  },
  {
    "content": "\n 3.27.4. __bang_mirror \n^^^^^^^^^^^^^^^\n void  __bang_mirror (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  height , unsigned int  width )   \n void  __bang_mirror (int8_t * dst ,  const  int8_t * src , unsigned int  height , unsigned int  width )   \n void  __bang_mirror (char * dst ,  const  char * src , unsigned int  height , unsigned int  width )   \n void  __bang_mirror (unsigned char * dst ,  const  unsigned char * src , unsigned int  height , unsigned int  width )   \n void  __bang_mirror (unsigned short * dst ,  const  unsigned short * src , unsigned int  height , unsigned int  width )   \n void  __bang_mirror (short * dst ,  const  short * src , unsigned int  height , unsigned int  width )   \n void  __bang_mirror (half * dst ,  const  half * src , unsigned int  height , unsigned int  width )   \n void  __bang_mirror (unsigned int * dst ,  const  unsigned int * src , unsigned int  height , unsigned int  width )   \n Flips  <src> , a matrix whose size is  <height>  *  <width> , in the left/right direction, and stores the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination matrix.\n*  [in] src : The address of source matrix.\n*  [in] height : The width of  <src> .\n*  [in] width : The height of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <height>  * sizeof(type) must be divisible by 64 on  (m)tp\\_2xx ;\n*  <width>  * sizeof(type) must be divisible by 128 on  (m)tp\\_2xx ;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <height>  and  <width>  must be greater than zero. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define WIDTH 64 \n define HEIGHT 32 \n define LEN (WIDTH * HEIGHT) \n __mlu_entry__ void kernel(short* dst, short* src) {\n  __nram__ short ny[LEN];\n  __nram__ short nx[LEN];\n  __memcpy(nx, src, LEN * sizeof(short), GDRAM2NRAM);\n  __bang_mirror(ny, nx, HEIGHT, WIDTH);\n  __memcpy(dst, ny, sizeof(short) * LEN, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.27.5. __bang_pad \n^^^^^^^^^^^^^^^\n void  __bang_pad (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  pad_top , unsigned int  pad_bottom , unsigned int  pad_left , unsigned int  pad_right )   \n void  __bang_pad (short * dst ,  const  short * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  pad_top , unsigned int  pad_bottom , unsigned int  pad_left , unsigned int  pad_right )   \n void  __bang_pad (unsigned short * dst ,  const  unsigned short * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  pad_top , unsigned int  pad_bottom , unsigned int  pad_left , unsigned int  pad_right )   \n void  __bang_pad (int8_t * dst ,  const  int8_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  pad_top , unsigned int  pad_bottom , unsigned int  pad_left , unsigned int  pad_right )   \n void  __bang_pad (char * dst ,  const  char * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  pad_top , unsigned int  pad_bottom , unsigned int  pad_left , unsigned int  pad_right )   \n void  __bang_pad (unsigned char * dst ,  const  unsigned char * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  pad_top , unsigned int  pad_bottom , unsigned int  pad_left , unsigned int  pad_right )   \n void  __bang_pad (float * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  pad_top , unsigned int  pad_bottom , unsigned int  pad_left , unsigned int  pad_right )   \n void  __bang_pad (unsigned int * dst ,  const  unsigned int * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  pad_top , unsigned int  pad_bottom , unsigned int  pad_left , unsigned int  pad_right )   \n void  __bang_pad (half * dst ,  const  half * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  pad_top , unsigned int  pad_bottom , unsigned int  pad_left , unsigned int  pad_right , half  pad_value )   \n void  __bang_pad (short * dst ,  const  short * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  pad_top , unsigned int  pad_bottom , unsigned int  pad_left , unsigned int  pad_right , short  pad_value )   \n void  __bang_pad (char * dst ,  const  char * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  pad_top , unsigned int  pad_bottom , unsigned int  pad_left , unsigned int  pad_right , char  pad_value )   \n void  __bang_pad (float * dst ,  const  float * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  pad_top , unsigned int  pad_bottom , unsigned int  pad_left , unsigned int  pad_right , float  pad_value )   \n void  __bang_pad (int * dst ,  const  int * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  pad_top , unsigned int  pad_bottom , unsigned int  pad_left , unsigned int  pad_right , unsigned int  pad_value )   \n void  __bang_pad (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  pad_top , unsigned int  pad_bottom , unsigned int  pad_left , unsigned int  pad_right , bfloat16_t  pad_value )   \n void  __bang_pad (int * dst ,  const  int * src , unsigned int  channel , unsigned int  height , unsigned int  width , unsigned int  pad_top , unsigned int  pad_bottom , unsigned int  pad_left , unsigned int  pad_right )   \n Applies padding operation on  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The destination vector, whose data layout is HWC.\n*  [in] src : The source vector, whose data layout is HWC.\n*  [in] channel : Number of channels.\n*  [in] height : The height of  <src> .\n*  [in] width : The width of  <src> .\n*  [in] pad\\_top : Number of rows whose elements is all zero or  <pad\\_value>  on the top of pad.\n*  [in] pad\\_bottom : Number of rows whose elements is all zero or  <pad\\_value>  on the bottom of pad.\n*  [in] pad\\_left : Number of columns whose elements is all zero or  <pad\\_value>  on the left of pad.\n*  [in] pad\\_right : Number of columns whose elements is all zero or  <pad\\_value>  on the right of pad.\n*  [in] pad\\_value : The value of padding. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <height>  and  <width>  must be greater than 0;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* If  <height> == 1 ,  <pad\\_left>  and  <pad\\_right>  must be equal to 0;\n*  <channel> \\* <width> \\* sizeof(type)  must be 128-byte aligned on  (m)tp\\_2xx ;\n*  <pad\\_left> \\* <channel> \\* sizeof(type)  must be 128-byte aligned on  (m)tp\\_2xx ;\n*  <pad\\_right> \\* <channel> \\* sizeof(type)  must be 128-byte aligned on  (m)tp\\_2xx ;\n*  <pad\\_value>  are only supported on  (m)tp\\_5xx  or higher. \n^^^^^^^^^^^^^^^\n Example \n``` \n include \n define PAD_H 1 \n define PAD_W 2 \n define INPUT_H 4 \n define INPUT_W 4 \n define CHANNEL 64 \n __mlu_entry__ void kernel(half *out, half *in) {\n  __nram__ half nx[CHANNEL * INPUT_H * INPUT_W];\n  __nram__ half ny[CHANNEL * (INPUT_H + 2 * PAD_H) * (INPUT_W + 2 * PAD_W)];\n  __memcpy(nx, in, CHANNEL * INPUT_H * INPUT_W * sizeof(half), GDRAM2NRAM);\n  __bang_pad(ny, nx, CHANNEL, INPUT_H, INPUT_W, PAD_H, PAD_H, PAD_W, PAD_W);\n  __memcpy(out, ny, CHANNEL * (INPUT_H + 2 * PAD_H) * (INPUT_W + 2 * PAD_W) * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.27.6. __bang_rotate180 \n^^^^^^^^^^^^^^^\n void  __bang_rotate180 (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate180 (int8_t * dst ,  const  int8_t * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate180 (char * dst ,  const  char * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate180 (unsigned char * dst ,  const  unsigned char * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate180 (half * dst ,  const  half * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate180 (short * dst ,  const  short * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate180 (unsigned short * dst ,  const  unsigned short * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate180 (float * dst ,  const  float * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate180 (int * dst ,  const  int * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate180 (unsigned int * dst ,  const  unsigned int * src , unsigned int  height , unsigned int  width )   \n Rotates  <src>  , a matrix, whose size is  <height>  *  <width>  , by 180 degrees in clockwise direction, and stores the result in  <dst>  . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination matrix.\n*  [in] src : The address of source matrix.\n*  [in] height : The height of  <src> .\n*  [in] width : The width of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <height>  * sizeof(type) and  <width>  * sizeof(type) must be divisible by 128 bytes on  (m)tp\\_2xx ;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <height>  and  <width>  must be greater than zero. "
  },
  {
    "content": "\n 3.27.7. __bang_rotate270 \n^^^^^^^^^^^^^^^\n void  __bang_rotate270 (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate270 (int8_t * dst ,  const  int8_t * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate270 (char * dst ,  const  char * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate270 (unsigned char * dst ,  const  unsigned char * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate270 (half * dst ,  const  half * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate270 (short * dst ,  const  short * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate270 (unsigned short * dst ,  const  unsigned short * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate270 (float * dst ,  const  float * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate270 (int * dst ,  const  int * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate270 (unsigned int * dst ,  const  unsigned int * src , unsigned int  height , unsigned int  width )   \n Rotates  <src>  , a matrix, whose size is  <height>  *  <width>  , by 270 degrees in clockwise direction, and stores the result in  <dst>  . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination matrix.\n*  [in] src : The address of source matrix.\n*  [in] height : The height of  <src> .\n*  [in] width : The width of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <height>  * sizeof(type) and  <width>  * sizeof(type) must be divisible by 128 bytes on  (m)tp\\_2xx ;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <height>  and  <width>  must be greater than zero. "
  },
  {
    "content": "\n 3.27.8. __bang_rotate90 \n^^^^^^^^^^^^^^^\n void  __bang_rotate90 (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate90 (int8_t * dst ,  const  int8_t * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate90 (char * dst ,  const  char * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate90 (unsigned char * dst ,  const  unsigned char * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate90 (half * dst ,  const  half * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate90 (short * dst ,  const  short * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate90 (unsigned short * dst ,  const  unsigned short * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate90 (float * dst ,  const  float * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate90 (int * dst ,  const  int * src , unsigned int  height , unsigned int  width )   \n void  __bang_rotate90 (unsigned int * dst ,  const  unsigned int * src , unsigned int  height , unsigned int  width )   \n Rotates  <src>  , a matrix, whose size is  <height>  *  <width>  , by 90 degrees in clockwise direction, and stores the result in  <dst>  . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination matrix.\n*  [in] src : The address of source matrix.\n*  [in] height : The height of  <src> .\n*  [in] width : The width of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <height> \\* sizeof(type)  and  <width>  * sizeof(type) must be divisible by 128 bytes on  (m)tp\\_2xx ;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <height>  and  <width>  must be greater than zero. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define WIDTH 128 \n define HEIGHT 64 \n define LEN (HEIGHT * WIDTH) \n __mlu_entry__ void kernel(unsigned char* dst, unsigned char* src) {\n  __nram__ unsigned char ny[LEN];\n  __nram__ unsigned char nx[LEN];\n  __memcpy(nx, src, LEN * sizeof(unsigned char), GDRAM2NRAM);\n  __bang_rotate90(ny, nx, HEIGHT, WIDTH);\n  __memcpy(dst, ny, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.27.9. __bang_tiling_2d_b128 \n^^^^^^^^^^^^^^^\n void  __bang_tiling_2d_b128 (void * dst ,  const  void * src , unsigned int  n2 , unsigned int  s2 , unsigned int  n1 , unsigned int  s1 , unsigned int  n7 , unsigned int  s7 , unsigned int  n6 , unsigned int  s6 )   \n Applies 2D tiling operation on  <src>  for matrix transpose and store the matrix to the  <dst> . \n As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension.  <s1>  of data in each segment are copied to destination area  <n1>  times. There are 4 segments in the second dimension.  <s2>  of data in each segment are copied to destination area  <n2>  times. Then, calculate matrix transpose based on 128-bit as one element and store the matrix into corresponding segments and dimensions of  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of output matrix.\n*  [in] src : The address of input matrix.\n*  [in] n2 : Tiling input iteration 2.\n*  [in] s2 : Tiling input stride 2.\n*  [in] n1 : Tiling input iteration 1.\n*  [in] s1 : Tiling input stride 1.\n*  [in] n7 : Tiling output iteration 7.\n*  [in] s7 : Tiling output stride 7.\n*  [in] n6 : Tiling output iteration 6.\n*  [in] s6 : Tiling output stride 6. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* (  \\times   =   \\times   = 4);\n*  <n1> ,  <n2> ,  <n6>  and  <n7>  must be an immediate integer on  (m)tp\\_2xx ;\n*  <s1> ,  <s2> ,  <s6>  and  <s7>  must be greater than or equal to zero;\n* Unit of  <s1> ,  <s2> ,  <s6> ,  <s7>  is 64 bytes;\n*  <dst>  cannot be overlapped with  <src> . "
  },
  {
    "content": "\n 3.27.10. __bang_tiling_2d_b16 \n^^^^^^^^^^^^^^^\n void  __bang_tiling_2d_b16 (void * dst ,  const  void * src , unsigned int  n2 , unsigned int  s2 , unsigned int  n1 , unsigned int  s1 , unsigned int  n7 , unsigned int  s7 , unsigned int  n6 , unsigned int  s6 )   \n Applies 2D tiling operation on  <src>  for matrix transpose and store the matrix to the  <dst> . \n As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension.  <s1>  of data in each segment are copied to destination area  <n1>  times. There are 4 segments in the second dimension.  <s2>  of data in each segment are copied to destination area  <n2>  times. Then, calculate matrix transpose based on 16-bit as one element and store the matrix into corresponding segments and dimensions of  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of output matrix.\n*  [in] src : The address of input matrix.\n*  [in] n2 : Tiling input iteration 2.\n*  [in] s2 : Tiling input stride 2.\n*  [in] n1 : Tiling input iteration 1.\n*  [in] s1 : Tiling input stride 1.\n*  [in] n7 : Tiling output iteration 7.\n*  [in] s7 : Tiling output stride 7.\n*  [in] n6 : Tiling output iteration 6.\n*  [in] s6 : Tiling output stride 6. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* (  \\times   =   \\times   = 32);\n*  <n1> ,  <n2> ,  <n6>  and  <n7>  must be an immediate integer on  (m)tp\\_2xx ;\n*  <s1> ,  <s2> ,  <s6>  and  <s7>  must be greater than or equal to zero;\n* Unit of  <s1> ,  <s2> ,  <s6> ,  <s7>  is 64 bytes;\n*  <dst>  cannot be overlapped with  <src> . "
  },
  {
    "content": "\n 3.27.11. __bang_tiling_2d_b256 \n^^^^^^^^^^^^^^^\n void  __bang_tiling_2d_b256 (void * dst ,  const  void * src , unsigned int  n2 , unsigned int  s2 , unsigned int  n1 , unsigned int  s1 , unsigned int  n7 , unsigned int  s7 , unsigned int  n6 , unsigned int  s6 )   \n Applies 2D tiling operation on  <src>  for matrix transpose and store the matrix to the  <dst> . \n As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension.  <s1>  of data in each segment are copied to destination area  <n1>  times. There are 4 segments in the second dimension.  <s2>  of data in each segment are copied to destination area  <n2>  times. Then, calculate matrix transpose based on 256-bit as one element and store the matrix into corresponding segments and dimensions of  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of output matrix.\n*  [in] src : The address of input matrix.\n*  [in] n2 : Tiling input iteration 2.\n*  [in] s2 : Tiling input stride 2.\n*  [in] n1 : Tiling input iteration 1.\n*  [in] s1 : Tiling input stride 1.\n*  [in] n7 : Tiling output iteration 7.\n*  [in] s7 : Tiling output stride 7.\n*  [in] n6 : Tiling output iteration 6.\n*  [in] s6 : Tiling output stride 6. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* (  \\times   =   \\times   = 2);\n*  <n1> ,  <n2> ,  <n6>  and  <n7>  must be an immediate integer on  (m)tp\\_2xx ;\n*  <s1> ,  <s2> ,  <s6>  and  <s7>  must be greater than or equal to zero;\n* Unit of  <s1> ,  <s2> ,  <s6> ,  <s7>  is 64 bytes;\n*  <dst>  cannot be overlapped with  <src> . "
  },
  {
    "content": "\n 3.27.12. __bang_tiling_2d_b32 \n^^^^^^^^^^^^^^^\n void  __bang_tiling_2d_b32 (void * dst ,  const  void * src , unsigned int  n2 , unsigned int  s2 , unsigned int  n1 , unsigned int  s1 , unsigned int  n7 , unsigned int  s7 , unsigned int  n6 , unsigned int  s6 )   \n Applies 2D tiling operation on  <src>  for matrix transpose and store the matrix to the  <dst> . \n As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension.  <s1>  of data in each segment are copied to destination area  <n1>  times. There are 4 segments in the second dimension.  <s2>  of data in each segment are copied to destination area  <n2>  times. Then, calculate matrix transpose based on 32-bit as one element and store the matrix into corresponding segments and dimensions of  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of output matrix.\n*  [in] src : The address of input matrix.\n*  [in] n2 : Tiling input iteration 2.\n*  [in] s2 : Tiling input stride 2.\n*  [in] n1 : Tiling input iteration 1.\n*  [in] s1 : Tiling input stride 1.\n*  [in] n7 : Tiling output iteration 7.\n*  [in] s7 : Tiling output stride 7.\n*  [in] n6 : Tiling output iteration 6.\n*  [in] s6 : Tiling output stride 6. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* (  \\times   =   \\times   = 16);\n*  <n1> ,  <n2> ,  <n6>  and  <n7>  must be an immediate integer on  (m)tp\\_2xx ;\n*  <s1> ,  <s2> ,  <s6>  and  <s7>  must be greater than or equal to zero;\n* Unit of  <s1> ,  <s2> ,  <s6> ,  <s7>  is 64 bytes;\n*  <dst>  cannot be overlapped with  <src> . "
  },
  {
    "content": "\n 3.27.13. __bang_tiling_2d_b64 \n^^^^^^^^^^^^^^^\n void  __bang_tiling_2d_b64 (void * dst ,  const  void * src , unsigned int  n2 , unsigned int  s2 , unsigned int  n1 , unsigned int  s1 , unsigned int  n7 , unsigned int  s7 , unsigned int  n6 , unsigned int  s6 )   \n Applies 2D tiling operation on  <src>  for matrix transpose and store the matrix to the  <dst> . \n As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension.  <s1>  of data in each segment are copied to destination area  <n1>  times. There are 4 segments in the second dimension.  <s2>  of data in each segment are copied to destination area  <n2>  times. Then, calculate matrix transpose based on 64-bit as one element and store the matrix into corresponding segments and dimensions of  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of output matrix.\n*  [in] src : The address of input matrix.\n*  [in] n2 : Tiling input iteration 2.\n*  [in] s2 : Tiling input stride 2.\n*  [in] n1 : Tiling input iteration 1.\n*  [in] s1 : Tiling input stride 1.\n*  [in] n7 : Tiling output iteration 7.\n*  [in] s7 : Tiling output stride 7.\n*  [in] n6 : Tiling output iteration 6.\n*  [in] s6 : Tiling output stride 6. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* (  \\times   =   \\times   = 8);\n*  <n1> ,  <n2> ,  <n6>  and  <n7>  must be an immediate integer on  (m)tp\\_2xx ;\n*  <s1> ,  <s2> ,  <s6>  and  <s7>  must be greater than or equal to zero;\n* Unit of  <s1> ,  <s2> ,  <s6> ,  <s7>  is 64 bytes;\n*  <dst>  cannot be overlapped with  <src> . "
  },
  {
    "content": "\n 3.27.14. __bang_tiling_2d_b8 \n^^^^^^^^^^^^^^^\n void  __bang_tiling_2d_b8 (void * dst ,  const  void * src , unsigned int  n2 , unsigned int  s2 , unsigned int  n1 , unsigned int  s1 , unsigned int  n7 , unsigned int  s7 , unsigned int  n6 , unsigned int  s6 )   \n Applies 2D tiling operation on  <src>  for matrix transpose and stores the matrix to the  <dst> . \n As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension.  <s1>  of data in each segment are copied to destination area  <n1>  times. There are 4 segments in the second dimension.  <s2>  of data in each segment are copied to destination area  <n2>  times. Then, calculate matrix transpose based on 8-bit as one element and store the matrix into corresponding segments and dimensions of  <dst> . \n Fig. 3.17 The Process of 2 Dimensional Tiling Function \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of output matrix.\n*  [in] src : The address of input matrix.\n*  [in] n2 : Tiling input iteration 2.\n*  [in] s2 : Tiling input stride 2.\n*  [in] n1 : Tiling input iteration 1.\n*  [in] s1 : Tiling input stride 1.\n*  [in] n7 : Tiling output iteration 7.\n*  [in] s7 : Tiling output stride 7.\n*  [in] n6 : Tiling output iteration 6.\n*  [in] s6 : Tiling output stride 6. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* (  \\times   =   \\times   = 64);\n*  <n1> ,  <n2> ,  <n6>  and  <n7>  must be an immediate integer on  (m)tp\\_2xx ;\n*  <s1> ,  <s2> ,  <s6>  and  <s7>  must be greater than or equal to zero;\n* Unit of  <s1> ,  <s2> ,  <s6> ,  <s7>  is 64 bytes;\n*  <dst>  cannot be overlapped with  <src> . "
  },
  {
    "content": "\n 3.27.15. __bang_tiling_3d_b1024 \n^^^^^^^^^^^^^^^\n void  __bang_tiling_3d_b1024 (void * dst ,  const  void * src , unsigned int  n5 , unsigned int  s5 , unsigned int  n4 , unsigned int  s4 , unsigned int  n3 , unsigned int  s3 , unsigned int  n10 , unsigned int  s10 , unsigned int  n9 , unsigned int  s9 , unsigned int  n8 , unsigned int  s8 , unsigned int  op )   \n Copies data from  <src>  to  <dst>  in 3 dimensions. \n As shown in Figure The Process of 3 Dimensional Tiling Function ,the cells with blue background indicate  <op>  of data to be copied in each segment. In this case, there are 3 segments in the first dimension.  <s3>  of data in each segment are copied to destination area  <n3>  times. There are 2 segments in the second dimension.  <s4>  of data in each segment are copied to destination area  <n4>  times. And there are 2 segments in the third dimension.  <s5>  of data in each segment are copied to destination area  <n5>  times. Then, copy the data into corresponding segments and dimensions of  <dst> . \n Fig. 3.18 The Process of 3 Dimensional Tiling Function \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of output tensor.\n*  [in] src : The address of input tensor.\n*  [in] n5 : Tiling input outer iteration 5.\n*  [in] s5 : Tiling input outer stride 5.\n*  [in] n4 : Tiling input outer iteration 4.\n*  [in] s4 : Tiling input outer stride 4.\n*  [in] n3 : Tiling input outer iteration 3.\n*  [in] s3 : Tiling input outer stride 3.\n*  [in] n10 : Tiling output outer iteration 10.\n*  [in] s10 : Tiling output outer stride 10.\n*  [in] n9 : Tiling output outer iteration 9.\n*  [in] s9 : Tiling output outer stride 9.\n*  [in] n8 : Tiling output outer iteration 8.\n*  [in] s8 : Tiling output outer stride 8.\n*  [in] op : The number of tiling unit (128 bytes). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <op>  must be an immediate integer;\n* Unit of  <s3> ,  <s4> ,  <s5> ,  <s8> ,  <s9>  and  <s10>  is 64 bytes;\n*  <s3> ,  <s4> ,  <s5> ,  <s8> ,  <s9>  and  <s10>  must be greater than or equal to zero;\n* (  \\times   \\times   ==   \\times   \\times  );\n*  <dst>  cannot be overlapped with  <src> . "
  },
  {
    "content": "\n 3.27.16. __bang_transpose \n^^^^^^^^^^^^^^^\n void  __bang_transpose (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  height , unsigned int  width )   \n void  __bang_transpose (half * dst ,  const  half * src , unsigned int  height , unsigned int  width )   \n void  __bang_transpose (short * dst ,  const  short * src , unsigned int  height , unsigned int  width )   \n void  __bang_transpose (unsigned short * dst ,  const  unsigned short * src , unsigned int  height , unsigned int  width )   \n void  __bang_transpose (int8_t * dst ,  const  int8_t * src , unsigned int  height , unsigned int  width )   \n void  __bang_transpose (char * dst ,  const  char * src , unsigned int  height , unsigned int  width )   \n void  __bang_transpose (unsigned char * dst ,  const  unsigned char * src , unsigned int  height , unsigned int  width )   \n void  __bang_transpose (float * dst ,  const  float * src , unsigned int  height , unsigned int  width )   \n void  __bang_transpose (int * dst ,  const  int * src , unsigned int  height , unsigned int  width )   \n void  __bang_transpose (unsigned int * dst ,  const  unsigned int * src , unsigned int  height , unsigned int  width )   \n Transposes operand  src[height][width] , a matrix, to  dst[width][height] . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination matrix, and the matrix has WH data layout.\n*  [in] src : The address of source matrix, and the matrix has HW data layout.\n*  [in] height : The height of  <src> .\n*  [in] width : The width of  <src> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <height> \\* sizeof(type)  and  <width> \\* sizeof(type)  must be divisible by 64 on  (m)tp\\_2xx ;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <height>  and  <width>  must be greater than zero. \n^^^^^^^^^^^^^^^\n Example \n```\n #include  \n #define WIDTH 128\n #define HEIGHT 64\n #define LEN (HEIGHT * WIDTH) \n __mlu_entry__ void kernel(short* dst, short* src) {\n   __nram__ short ny[LEN];\n   __nram__ short nx[LEN];\n  __memcpy(nx, src, LEN * sizeof(short), GDRAM2NRAM);\n  __bang_transpose(ny, nx, HEIGHT, WIDTH);\n  __memcpy(dst, ny, LEN * sizeof(short), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.28.1. __bang_abs \n^^^^^^^^^^^^^^^\n void  __bang_abs (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count )   \n void  __bang_abs (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_abs (float * dst ,  const  float * src , unsigned int  elem_count )   \n void  __bang_abs (char * dst ,  const  char * src , unsigned int  elem_count )   \n void  __bang_abs (short * dst ,  const  short * src , unsigned int  elem_count )   \n void  __bang_abs (int * dst ,  const  int * src , unsigned int  elem_count )   \n This function computes the absolute value of  <src>  element-wisely and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of the source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  int ,  short  and  char are not supported on  tp\\_520 ;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <elem\\_count>  must be greater than zero"
  },
  {
    "content": "\n 3.28.2. __bang_add \n^^^^^^^^^^^^^^^\n void  __bang_add (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n void  __bang_add (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_add (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n void  __bang_add (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_add (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_add (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function performs addition operation element-wisely on  <src0>  and  <src1>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  float  is the supported on  (m)tp\\_2xx  or higher;\n;\n*  <elem\\_count>  must be greater than zero. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_SIZE 128 \n __mlu_entry__ void kernel(float* c, float* a, float* b) {\n  __nram__ float a_tmp[DATA_SIZE];\n  __nram__ float c_tmp[DATA_SIZE];\n  __nram__ float b_tmp[DATA_SIZE];\n  __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n  __memcpy(b_tmp, b, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_add(c_tmp, a_tmp, b_tmp, DATA_SIZE);\n  __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.28.3. __bang_add_scalar \n^^^^^^^^^^^^^^^\n void  __bang_add_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n void  __bang_add_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_add_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n void  __bang_add_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_add_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_add_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function adds  <value>  to  <elem\\_count>  elements of  <src>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <elem\\_count>  must be greater than zero;\n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_SIZE 128 \n __mlu_entry__ void kernel(float* c, float* a, float b) {\n  __nram__ float a_tmp[DATA_SIZE];\n  __nram__ float c_tmp[DATA_SIZE];\n  __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_add_scalar(c_tmp, a_tmp, b, DATA_SIZE);\n  __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.28.4. __bang_add_tz \n^^^^^^^^^^^^^^^\n void  __bang_add_tz (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_add_tz (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_add_tz (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function performs addition operation element-wisely on  <src0>  and  <src1>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_SIZE 128 \n __mlu_entry__ void kernel(float* c, float* a, float* b) {\n  __nram__ float a_tmp[DATA_SIZE];\n  __nram__ float c_tmp[DATA_SIZE];\n  __nram__ float b_tmp[DATA_SIZE];\n  __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n  __memcpy(b_tmp, b, DATA_SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_add_tz(c_tmp, a_tmp, b_tmp, DATA_SIZE);\n  __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.28.5. __bang_adds \n^^^^^^^^^^^^^^^\n void  __bang_adds (unsigned char * dst ,  const  unsigned char * src0 ,  const  unsigned char * src1 , unsigned int  elem_count )   \n void  __bang_adds (unsigned short * dst ,  const  unsigned short * src0 ,  const  unsigned short * src1 , unsigned int  elem_count )   \n void  __bang_adds (unsigned int * dst ,  const  unsigned int * src0 ,  const  unsigned int * src1 , unsigned int  elem_count )   \n void  __bang_adds (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n void  __bang_adds (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_adds (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n This function performs saturated addition operation element-wisely on  <src0>  and  <src1>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.6. __bang_adds_scalar \n^^^^^^^^^^^^^^^\n void  __bang_adds_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n void  __bang_adds_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_adds_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n This function adds  <value>  to  <elem\\_count>  elements of  <src>  and saves the saturated result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <elem\\_count>  must be greater than zero. \n "
  },
  {
    "content": "\n 3.28.7. __bang_count \n^^^^^^^^^^^^^^^\n unsigned int  __bang_count ( const  half * src , unsigned int  elem_count )   \n unsigned int  __bang_count ( const  bfloat16_t * src , unsigned int  elem_count )   \n unsigned int  __bang_count ( const  float * src , unsigned int  elem_count )   \n Counts the number of non-zero elements in the input vector. \n^^^^^^^^^^^^^^^\n Parameters *  [in] src : The address of source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  unsigned int  The number of non-zero elements in the input vector. \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_SIZE 64 \n __mlu_entry__ void kernel(float* src, unsigned int elem_count) {\n  unsigned int counter = __bang_count(src, elem_count);\n} \n ``` \n"
  },
  {
    "content": "\n 3.28.8. __bang_count_bitindex \n^^^^^^^^^^^^^^^\n unsigned int  __bang_count_bitindex ( const  half * src , unsigned int  elem_count )   \n unsigned int  __bang_count_bitindex ( const  bfloat16_t * src , unsigned int  elem_count )   \n unsigned int  __bang_count_bitindex ( const  float * src , unsigned int  elem_count )   \n Counts the number of non-zero bit in the input vector. \n^^^^^^^^^^^^^^^\n Parameters *  [in] src : The address of source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  unsigned int  The number of non-zero bit in the input vector. \n^^^^^^^^^^^^^^^\n *  <elem\\_count>  must be greater than zero;\n*  <src> must point to  \\_\\_nram\\_\\_  address space;\n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_SIZE 64 \n __mlu_entry__ void kernel(float* src, unsigned int elem_count) {\n  unsigned int counter = __bang_count_bitindex(src, elem_count);\n} \n ``` \n"
  },
  {
    "content": "\n 3.28.9. __bang_cycle_add \n^^^^^^^^^^^^^^^\n void  __bang_cycle_add (int * dst ,  const  int * src ,  const  int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_add (short * dst ,  const  short * src ,  const  short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_add (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_add (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_add (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_add (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n This function divides  <src>  into N parts (  N = <src\\_elem\\_count> / <seg\\_elem\\_count>  ), adds each element in each part of  <src>  and the corresponding element in  <seg> , and assigns the result to  <dst> . \n Fig. 3.19 Description of  \\_\\_bang\\_cycle\\_add \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark ;\n*  <src\\_elem\\_count> \\* sizeof(type)  and  <seg\\_elem\\_count> \\* sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;\n*  <seg\\_elem\\_count> \\* sizeof(type)  cannot be greater than 65536 on  tp\\_322  when vector type is  int ,  short  and  char ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define N1 256 \n define N2 65280 \n __mlu_entry__ void kernel(half* c, half* a, half* b) {\n  __nram__ half a_tmp[N1];\n  __nram__ half b_tmp[N2];\n  __nram__ half c_tmp[N2];\n  __memcpy(a_tmp, a, N1 * sizeof(half), GDRAM2NRAM);\n  __memcpy(b_tmp, b, N2 * sizeof(half), GDRAM2NRAM);\n  __bang_cycle_add(c_tmp, b_tmp, a_tmp, N2, N1);\n  __memcpy(c, c_tmp, N2 * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.28.10. __bang_cycle_add_tz \n^^^^^^^^^^^^^^^\n void  __bang_cycle_add_tz (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_add_tz (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_add_tz (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n Adds two input vectors segment by segment in round-to-zero mode. This function is calculated in the same way as ::__bang_cycle_add function. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <src\\_elem\\_count> \\* sizeof(type)  and  <seg\\_elem\\_count> \\* sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define N1 256 \n define N2 65280 \n __mlu_entry__ void kernel(half* c, half* a, half* b) {\n  __nram__ half a_tmp[N1];\n  __nram__ half b_tmp[N2];\n  __nram__ half c_tmp[N2];\n  __memcpy(a_tmp, a, N1 * sizeof(half), GDRAM2NRAM);\n  __memcpy(b_tmp, b, N2 * sizeof(half), GDRAM2NRAM);\n  __bang_cycle_add_tz(c_tmp, b_tmp, a_tmp, N2, N1);\n  __memcpy(c, c_tmp, N2 * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.28.11. __bang_cycle_adds \n^^^^^^^^^^^^^^^\n void  __bang_cycle_adds (unsigned int * dst ,  const  unsigned int * src ,  const  unsigned int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_adds (unsigned short * dst ,  const  unsigned short * src ,  const  unsigned short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_adds (unsigned char * dst ,  const  unsigned char * src ,  const  unsigned char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_adds (int * dst ,  const  int * src ,  const  int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_adds (short * dst ,  const  short * src ,  const  short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_adds (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n This function divides  <src>  into N parts (  N = <src\\_elem\\_count> / <seg\\_elem\\_count>  ), adds each element in each part of  <src>  and the corresponding element in  <seg> , and assigns the saturated result to  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.28.12. __bang_cycle_mul \n^^^^^^^^^^^^^^^\n void  __bang_cycle_mul (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_mul (int * dst ,  const  int * src ,  const  int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_mul (short * dst ,  const  short * src ,  const  short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_mul (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_mul (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_mul (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n This function divides  <src>  into N parts (  N = <src\\_elem\\_count> / <seg\\_elem\\_count>  ), multiplies each element in each part of  <src>  and the corresponding element in  <seg> , and assigns the result to  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark ;\n*  <src\\_elem\\_count> \\* sizeof(type)  and  <seg\\_elem\\_count> \\* sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;\n*  <seg\\_elem\\_count> \\* sizeof(type)  cannot be greater than 65536 on  tp\\_322  when vector type is  int ,  short  and  char ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.28.13. __bang_cycle_mulh \n^^^^^^^^^^^^^^^\n void  __bang_cycle_mulh (unsigned int * dst ,  const  unsigned int * src ,  const  unsigned int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_mulh (unsigned short * dst ,  const  unsigned short * src ,  const  unsigned short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_mulh (unsigned char * dst ,  const  unsigned char * src ,  const  unsigned char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_mulh (int * dst ,  const  int * src ,  const  int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_mulh (short * dst ,  const  short * src ,  const  short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_mulh (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n This function divides  <src>  into N parts (  N = <src\\_elem\\_count> / <seg\\_elem\\_count>  ), multiplies each element in each part of  <src>  and the corresponding element in  <seg> , and assigns the upper half of result to  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.28.14. __bang_cycle_muls \n^^^^^^^^^^^^^^^\n void  __bang_cycle_muls (unsigned short * dst ,  const  unsigned char * src ,  const  unsigned char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_muls (unsigned int * dst ,  const  unsigned short * src ,  const  unsigned short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_muls (int * dst ,  const  short * src ,  const  short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_muls (short * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n This function divides  <src>  into N parts (  N = <src\\_elem\\_count> / <seg\\_elem\\_count>  ), multiplies each element in each part of  <src>  and the corresponding element in  <seg> , and assigns the result to  <dst> . The size of  <dst>  is twice as long as that of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <seg\\_elem\\_count> \\* sizeof(source type)  cannot be greater than 65536 on  tp\\_322 ;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.28.15. __bang_cycle_sub \n^^^^^^^^^^^^^^^\n void  __bang_cycle_sub (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_sub (int * dst ,  const  int * src ,  const  int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_sub (short * dst ,  const  short * src ,  const  short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_sub (half * dst ,  const  half * src ,  const  half * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_sub (bfloat16_t * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_sub (float * dst ,  const  float * src ,  const  float * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n This function divides  <src>  into N parts (  N = <src\\_elem\\_count> / <seg\\_elem\\_count>  ), subtracts each element in each part of  <src>  and the corresponding element in  <seg> , and assigns the result to  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark ;\n*  <src\\_elem\\_count> \\* sizeof(type)  and  <seg\\_elem\\_count> \\* sizeof(type)  must be divisible by 128 on  (m)tp\\_2xx ;\n*  <seg\\_elem\\_count> \\* sizeof(type)  cannot be greater than 65536 on  tp\\_322  when vector type is  int ,  short  and  char ;\n*  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.28.16. __bang_cycle_subs \n^^^^^^^^^^^^^^^\n void  __bang_cycle_subs (unsigned int * dst ,  const  unsigned int * src ,  const  unsigned int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_subs (unsigned short * dst ,  const  unsigned short * src ,  const  unsigned short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_subs (unsigned char * dst ,  const  unsigned char * src ,  const  unsigned char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_subs (int * dst ,  const  int * src ,  const  int * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_subs (short * dst ,  const  short * src ,  const  short * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n void  __bang_cycle_subs (char * dst ,  const  char * src ,  const  char * seg , unsigned int  src_elem_count , unsigned int  seg_elem_count )   \n This function divides  <src>  into N parts (  N = <src\\_elem\\_count> / <seg\\_elem\\_count>  ), subtracts each element in each part of  <src>  and the corresponding element in  <seg> , and assigns the saturated result to  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of first source vector.\n*  [in] seg : The address of second source vector.\n*  [in] src\\_elem\\_count : The number of elements in  <src>  vector.\n*  [in] seg\\_elem\\_count : The number of elements in  <seg>  vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src\\_elem\\_count>  must be divisible by  <seg\\_elem\\_count> ;\n*  <src\\_elem\\_count>  and  <seg\\_elem\\_count>  must be greater than zero;\n*  <src> ,  <seg>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.28.17. __bang_findfirst1 \n^^^^^^^^^^^^^^^\n unsigned int  __bang_findfirst1 ( const  half * src , unsigned int  elem_count )   \n unsigned int  __bang_findfirst1 ( const  bfloat16_t * src , unsigned int  elem_count )   \n unsigned int  __bang_findfirst1 ( const  float * src , unsigned int  elem_count )   \n Finds the first non-zero data in the values of  <src> , and returns the index of the first non-zero data. If  <src>  is all zero, returns 0xffff-ffff. \n^^^^^^^^^^^^^^^\n Parameters *  [in] src : The address of source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  unsigned int . \n^^^^^^^^^^^^^^^\n *  <elem\\_count>  must be greater than zero;\n*  <src>  must point to  \\_\\_nram\\_\\_  address space;\n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_SIZE 64 \n __mlu_entry__ void kernel(half* a) {\n  __nram__ half a_tmp[DATA_SIZE];\n  __memcpy(a_tmp, a, DATA_SIZE * sizeof(half), GDRAM2NRAM);\n  unsigned int num = __bang_findfirst1(a_tmp, DATA_SIZE);\n} \n ``` \n"
  },
  {
    "content": "\n 3.28.19. __bang_floor \n^^^^^^^^^^^^^^^\n void  __bang_floor (float * dst ,  const  float * src , unsigned int  elem_count )   \n This function performs floor operation element-wisely on  <src>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of the source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.20. __bang_histogram \n^^^^^^^^^^^^^^^\n void  __bang_histogram (half * dst ,  const  int8_t * src ,  const  int8_t * kernel , unsigned int  size )   \n void  __bang_histogram (float * dst ,  const  int8_t * src ,  const  int8_t * kernel , unsigned int  size )   \n void  __bang_histogram (int16_t * dst ,  const  int8_t * src ,  const  int8_t * kernel , unsigned int  size )   \n void  __bang_histogram (int32_t * dst ,  const  int8_t * src ,  const  int8_t * kernel , unsigned int  size )   \n void  __bang_histogram (half * dst ,  const  int16_t * src ,  const  int16_t * kernel , unsigned int  size )   \n void  __bang_histogram (float * dst ,  const  int16_t * src ,  const  int16_t * kernel , unsigned int  size )   \n void  __bang_histogram (int16_t * dst ,  const  int16_t * src ,  const  int16_t * kernel , unsigned int  size )   \n void  __bang_histogram (int32_t * dst ,  const  int16_t * src ,  const  int16_t * kernel , unsigned int  size )   \n void  __bang_histogram (float * dst ,  const  half * src ,  const  half * kernel , unsigned int  size )   \n void  __bang_histogram (float * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * kernel , unsigned int  size )   \n Generates a histogram of  <src>  according to kernel. \nThe data layout of  <kernel>  is 64 rows. Every row is 64 bytes, and the value of each row is corresponding to the histogram of x-axis. There are 32 values in each row when data type is  int16\\_t ,  half  or  bfloat16\\_t , and 64 values when data type is  int8\\_t . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector\n*  [in] src : The address of source vector\n*  [in] kernel : The address of kernel vector\n*  [in] size : The elements number of source vector \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  and  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <kernel>  must point to  \\_\\_wram\\_\\_  address space;\n* The address of  <dst>  and  <src>  must be 64-byte aligned;\n* The address of  <kernel>  must be 32-byte aligned;\n*  <size> \\* sizeof(typeof<src>)  must be 64-byte aligned on  (m)tp\\_2xx ;\n* The element number of  <dst>  is 64;\n*  <size>  must be greater than 0;\n*  <dst>  cannot be overlapped with  <src> . \n ^^^^^^^^^^^^^^^\n  Example \n For example,  <src>  is  [0, 1, 2, 3, 0, 1, 2, 3, 3]  and data type of  <src>  is  int16\\_t . If all numbers in kernel\u2019s first line are 1, all numbers in kernel\u2019s second line are 3, all numbers in kernel\u2019s third line are 9, data type of  <kernel>  is  int16\\_t . For  <dst> ,  dst[0]  is 2, which is equal to how many number 1(data of first line of kernel) in the  <src> . dst[2]  is 0, because there is no number 9(data of third line of kernel) in <src> . So  <dst>  is  [2, 3, 0, 0, 0, ...]  and the number of elements of  <dst>  is 64 and data type of  <dst>  is  int32\\_t . \n ``` \n include  \n define SRC_NUM 512 \n define DST_NUM 64 \n define KERNEL_NUM (64 * (64 / sizeof(int16_t))) \n define KERNEL_COLUMN (64 / sizeof(int16_t)) \n __mlu_entry__ void kernel(int32_t* dst, int16_t* src, int16_t* kernel, int size) {\n  __nram__ int32_t dst_tmp[DST_NUM];\n  __nram__ int16_t src_tmp[SRC_NUM];\n  __wram__ int16_t kernel_tmp[KERNEL_NUM];\n  __memcpy(src_tmp, src, SRC_NUM * sizeof(int16_t), GDRAM2NRAM);\n  __memcpy(kernel_tmp, kernel, KERNEL_NUM * sizeof(int16_t), GDRAM2WRAM);\n  __bang_write_zero((half*)dst_tmp, DST_NUM * 2);\n  __bang_histogram(dst_tmp, src_tmp, kernel_tmp, size);\n  __memcpy(dst, dst_tmp, DST_NUM * sizeof(int32_t), NRAM2GDRAM);\n} \n int main() {\n  ...\n  for (int i = 0; i < 64; i++) {\n    cpu_kernel[i][0] = ...;  // value of cpu_kernel[i][0] can calculate how many cpu_kernel[i][0] in the src\n    for (int j = 1; j < KERNEL_COLUMN; j++) {\n      cpu_kernel[i][j] = cpu_kernel[i][j-1];\n    }\n  }\n  ...\n  int16_t* mlu_kernel;\n  CNRT_CHECK(cnrtMalloc((void **)&mlu_kernel, KERNEL_NUM * sizeof(int16_t)));\n  CNRT_CHECK(cnrtMemcpy(mlu_kernel, cpu_kernel, KERNEL_NUM * sizeof(int16_t), CNRT_MEM_TRANS_DIR_HOST2DEV));\n  kernel<< >>(mlu_dst, mlu_src, mlu_kernel, SRC_NUM);\n  ...\n} \n ``` \n"
  },
  {
    "content": "\n 3.28.21. __bang_integral \n^^^^^^^^^^^^^^^\n void  __bang_integral (int * dst ,  const  short * src ,  const  short * kernel , unsigned int  size )   \n void  __bang_integral (short * dst ,  const  short * src ,  const  short * kernel , unsigned int  size )   \n void  __bang_integral (half * dst ,  const  int16_t * src ,  const  int16_t * kernel , unsigned int  size , int  fix_position )   \n void  __bang_integral (float * dst ,  const  int16_t * src ,  const  int16_t * kernel , unsigned int  size , int  fix_position )   \n void  __bang_integral (int * dst ,  const  char * src ,  const  char * kernel , unsigned int  size )   \n void  __bang_integral (short * dst ,  const  char * src ,  const  char * kernel , unsigned int  size )   \n void  __bang_integral (half * dst ,  const  int8_t * src ,  const  int8_t * kernel , unsigned int  size , int  fix_position )   \n void  __bang_integral (float * dst ,  const  int8_t * src ,  const  int8_t * kernel , unsigned int  size , int  fix_position )   \n void  __bang_integral (float * dst ,  const  float * src ,  const  float * kernel , unsigned int  size )   \n void  __bang_integral (float * dst ,  const  bfloat16_t * src ,  const  bfloat16_t * kernel , unsigned int  size )   \n void  __bang_integral (float * dst ,  const  half * src ,  const  half * kernel , unsigned int  size )   \n Generates integral of the input vector  <src>  according to  <kernel> . When the value of Lower Triangular Matrix(LTM) of  <kernel>  are 1 and the other values are 0, it is equivalent to the prefix sum of the input vector  <src> ;\nGenerally, the value of elements in the LTM of  <kernel>  should be  1 , so  <dst>[n]  is the sum of  <src>[0]  to  <src>[n] . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector\n*  [in] src : The address of source vector\n*  [in] kernel : The address of kernel vector\n*  [in] size : The elements number of source vector\n*  [in] fix\\_position : Sum of scale factor of  <src>  and  <kernel> . \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <dst>  and  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <kernel>  must point to  \\_\\_wram\\_\\_  address space;\n* The address of  <dst>  and  <src>  must be 64-byte aligned;\n* The address of  <kernel>  must be 32-byte aligned;\n*  <size> \\* sizeof(typeof<src>)  must be 64-byte aligned;\n*  <size> \\* sizeof(typeof<src>)  cannot be greater than  65472 ;\n*  <dst>  cannot be overlapped with  <src> ;\n* When data type of  <src>  is  int8\\_t  or  char ,  <kernel>  should be (64 \\times 64) Lower Triangular Matrix(LTM); when data type of  <src>  is  int16\\_t ,  short  or  half ,  <kernel>  should be (32 \\times 32) LTM; when datatype of  <src>  is  float ,  <kernel>  should be (16 \\times 16) LTM;  kernel  always requires 4096 bytes of memory, LTM should be placed at the beginning of the memory;\n*  <fix\\_position>  must be in the range  [-127, 127] . \n ^^^^^^^^^^^^^^^\n Compatibility between Various Architectures \n Example \n When Lower Triangular Matrix of  <kernel>  value to  k  and the other value to  0 .  <dst>[n]  is k times the sum of  <src>[0]  to  <src>[n] ; If  k  is 1,  <size>  is 64,  <src>  is  [1, 1, ... , 1, 1]  and data type of  <src>  is  short ,  <dst>  should be  [1, 2, 3, ..., 63, 64]  and data type of  <dst>  is  int ; If  k  is 2,  <size>  is 64,  <src>  is  [1, 1, ... , 1, 1]  and data type of  <src>  is  short ,  <dst>  should be  [2, 4, 6, ... 126, 128]  and data type of  <dst>  is  int . \n ``` \n include  \n define DATA_NUM 64 \n define KERNEL_NUM (4096 / sizeof(short)) \n define KERNEL_SIDE_LENGTH (64 / sizeof(short)) \n __mlu_entry__ void kernel(int* dst, short* src, short* kernel, int size) {\n  __nram__ int dst_tmp[DATA_NUM];\n  __nram__ short src_tmp[DATA_NUM];\n  __wram__ short kernel_tmp[KERNEL_NUM];\n  __memcpy(src_tmp, src, DATA_NUM * sizeof(short), GDRAM2NRAM);\n  __memcpy(kernel_tmp, kernel, KERNEL_NUM * sizeof(short), GDRAM2WRAM);\n  __bang_integral(dst_tmp, src_tmp, kernel_tmp, size);\n  __memcpy(dst, dst_tmp, DATA_NUM * sizeof(int), NRAM2GDRAM);\n} \n int main() {\n  ...\n// detailed layout, value of LTM of kernel is 1 and the other is 0\n  short cpu_kernel[KERNEL_SIDE_LENGTH][KERNEL_SIDE_LENGTH];\n  for (int i = 0; i < KERNEL_SIDE_LENGTH; i++) {\n    for (int j = 0; j < KERNEL_SIDE_LENGTH; j++) {\n      if( i >= j ) cpu_kernel[i][j] = 1;\n      else cpu_kernel[i][j] = 0;\n    }\n  }\n  ...\n  short *mlu_kernel;\n  CNRT_CHECK(cnrtMalloc((void **)&mlu_kernel, KERNEL_NUM * sizeof(short)));\n  CNRT_CHECK(cnrtMemcpy(mlu_kernel, cpu_kernel, KERNEL_NUM * sizeof(short), CNRT_MEM_TRANS_DIR_HOST2DEV));\n  kernel<< >>(mlu_dst, mlu_src, mlu_kernel, DATA_NUM);\n  ...\n} \n ``` \n"
  },
  {
    "content": "\n 3.28.22. __bang_lut \n^^^^^^^^^^^^^^^\n void  __bang_lut (int32_t * dst ,  const  uint32_t * index ,  const  int32_t * table , unsigned int  elem_count , unsigned int  table_length )   \n void  __bang_lut (int32_t * dst ,  const  uint16_t * index ,  const  int32_t * table , unsigned int  elem_count , unsigned int  table_length )   \n void  __bang_lut (int32_t * dst ,  const  uint8_t * index ,  const  int32_t * table , unsigned int  elem_count , unsigned int  table_length )   \n void  __bang_lut (int16_t * dst ,  const  uint16_t * index ,  const  int16_t * table , unsigned int  elem_count , unsigned int  table_length )   \n void  __bang_lut (int16_t * dst ,  const  uint8_t * index ,  const  int16_t * table , unsigned int  elem_count , unsigned int  table_length )   \n Applies lookup-table operation on  <index> , value in  <dst>  remains unchanged if the corresponding value in  <index>  is greater than or equal to  <table\\_length> . \n ^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] index : The address of index vector.\n*  [in] table : The address of table vector.\n*  [in] elem\\_count : Number of elements in index vector.\n*  [in] table\\_length : Number of elements in table vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <index> ,  <table>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  and  <table\\_length>  must be greater than zero;\n*  <dst> ,  <table>  and  <index>  cannot be overlapped. \n ^^^^^^^^^^^^^^^\n Example \n```\n  #include  \n __mlu_entry__ void kernel() {\n  __nram__ int dst[128] = {0,0,0,0,0,100,100};\n  __nram__ int idx[128] = {0,1,2,3,4,5,2277};\n  __nram__ int tbl[128] = {5,4,3,2,1};\n  __bang_lut(dst, idx, tbl, 8, 64);\n  // output: 5,4,3,2,1,0,100,5\n  printf(\"%d,%d,%d,%d,%d,%d,%d,%d\\n\",\n         dst[0], dst[1], dst[2], dst[3],\n         dst[4], dst[5], dst[6], dst[7]);\n} \n ``` \n"
  },
  {
    "content": "\n 3.28.23. __bang_lut_s16 \n^^^^^^^^^^^^^^^\n void  __bang_lut_s16 (int16_t * dst ,  const  int16_t * index ,  const  int16_t * table , unsigned int  elem_count , unsigned int  table_length )   \n Applies lookup-table operation on  <index> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] index : The address of index vector.\n*  [in] table : The address of table vector.\n*  [in] elem\\_count : Number of elements in index vector.\n*  [in] table\\_length : Number of elements in table vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <index> ,  <table>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* The data type of  <dst>  and  <table>  can be any type with the same size as that of  <src> ;\n*  <elem\\_count>  and  <table\\_length>  must be greater than zero;\n*  <dst> ,  <table>  and  <index>  cannot be overlapped;\n*  <table\\_length>  must be divisible by 64. "
  },
  {
    "content": "\n 3.28.24. __bang_lut_s32 \n^^^^^^^^^^^^^^^\n void  __bang_lut_s32 (int * dst ,  const  int * index ,  const  int * table , unsigned int  elem_count , unsigned int  table_length )   \n Applies lookup-table operation on  <index> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] index : The address of index vector.\n*  [in] table : The address of table vector.\n*  [in] elem\\_count : Number of elements in index vector.\n*  [in] table\\_length : Number of elements in table vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <index> ,  <table>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n* The data type of  <dst>  and  <table>  can be any type with the same size as that of  <src> ;\n*  <elem\\_count>  and  <table\\_length>  must be greater than zero;\n*  <dst> ,  <table>  and  <index>  cannot be overlapped;\n*  <table\\_length>  must be divisible by 64. "
  },
  {
    "content": "\n 3.28.25. __bang_mul \n^^^^^^^^^^^^^^^\n void  __bang_mul (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n void  __bang_mul (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_mul (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n void  __bang_mul (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_mul (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_mul (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function performs multiplication operation element-wisely on  <src0>  and  <src1>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.26. __bang_mul_scalar \n^^^^^^^^^^^^^^^\n void  __bang_mul_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n void  __bang_mul_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_mul_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n void  __bang_mul_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_mul_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_mul_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function multiplies  <elem\\_count>  elements of  <src>  by  <value>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> ;\n;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.27. __bang_mulh \n^^^^^^^^^^^^^^^\n void  __bang_mulh (unsigned int * dst ,  const  unsigned int * src0 ,  const  unsigned int * src1 , unsigned int  elem_count )   \n void  __bang_mulh (unsigned short * dst ,  const  unsigned short * src0 ,  const  unsigned short * src1 , unsigned int  elem_count )   \n void  __bang_mulh (unsigned char * dst ,  const  unsigned char * src0 ,  const  unsigned char * src1 , unsigned int  elem_count )   \n void  __bang_mulh (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n void  __bang_mulh (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_mulh (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n This function performs multiplication operation element-wisely on  <src0>  and  <src1>  and saves the result in  <dst> . Only upper half of each result is stored in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.28. __bang_mulh_scalar \n^^^^^^^^^^^^^^^\n void  __bang_mulh_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n void  __bang_mulh_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_mulh_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n This function multiplies  <value>  by  <elem\\_count>  elements of  <src>  and saves the result in  <dst> . Only the upper half of each result is stored in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.29. __bang_muls \n^^^^^^^^^^^^^^^\n void  __bang_muls (unsigned short * dst ,  const  unsigned char * src0 ,  const  unsigned char * src1 , unsigned int  elem_count )   \n void  __bang_muls (unsigned int * dst ,  const  unsigned short * src0 ,  const  unsigned short * src1 , unsigned int  elem_count )   \n void  __bang_muls (short * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n void  __bang_muls (int * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n This function performs multiplication operation element-wisely on  <src0>  and  <src1>  and saves the result in  <dst> . The size of  <dst>  is twice as long as that of  <src0>  and  <src1> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.30. __bang_muls_scalar \n^^^^^^^^^^^^^^^\n void  __bang_muls_scalar (unsigned short * dst ,  const  unsigned char * src , unsigned char  value , unsigned int  elem_count )   \n void  __bang_muls_scalar (unsigned int * dst ,  const  unsigned short * src , unsigned short  value , unsigned int  elem_count )   \n void  __bang_muls_scalar (short * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n void  __bang_muls_scalar (int * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n This function multiplies  <value>  by  <elem\\_count>  elements of  <src>  and saves the result in  <dst> . The size of  <dst>  is twice as long as that of  <src> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.31. __bang_nearbyint \n^^^^^^^^^^^^^^^\n void  __bang_nearbyint (float * dst ,  const  float * src , unsigned int  elem_count )   \n This function performs round operation element-wisely on  <src>  in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of the source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.32. __bang_neg \n^^^^^^^^^^^^^^^\n void  __bang_neg (char * dst ,  const  char * src , unsigned int  elem_count )   \n void  __bang_neg (short * dst ,  const  short * src , unsigned int  elem_count )   \n void  __bang_neg (int * dst ,  const  int * src , unsigned int  elem_count )   \n This function computes the opposite value of  <src>  element-wisely and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of the source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.33. __bang_nsa \n^^^^^^^^^^^^^^^\n void  __bang_nsa (char * dst ,  const  char * src , unsigned int  elem_count )   \n void  __bang_nsa (short * dst ,  const  short * src , unsigned int  elem_count )   \n void  __bang_nsa (unsigned char * dst ,  const  unsigned char * src , unsigned int  elem_count )   \n void  __bang_nsa (unsigned short * dst ,  const  unsigned short * src , unsigned int  elem_count )   \n void  __bang_nsa (unsigned int * dst ,  const  unsigned int * src , unsigned int  elem_count )   \n void  __bang_nsa (int * dst ,  const  int * src , unsigned int  elem_count )   \n This function counts the leading zeros or ones in  <src>  element-wisely and saves the result in  <dst> . A leading zero is any digit that comes before the first nonzero digit in binary without the signed bit. If the value of element in  <src>  is a signed positive number, the result is the number of leading zeros minus one; if it is a negative number, the result is the number of leading ones minus one; if it is an unsigned number, the result is the number of leading zeros. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of the source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.35. __bang_rand \n^^^^^^^^^^^^^^^\n void  __bang_rand (short * dst , unsigned int  elem_count )   \n Generates a vector of uniformly distributed random number of short type. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] elem\\_count : The number of elements in destination vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero and divisible by 64;\n*  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define DATA_SIZE 64 \n __mlu_entry__ void kernel(short *output) {\n  __nram__ short result[DATA_SIZE];\n  __bang_rand(result, DATA_SIZE);\n  __memcpy(output, result, DATA_SIZE * sizeof(short), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.28.36. __bang_reduce_sum \n^^^^^^^^^^^^^^^\n void  __bang_reduce_sum (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_reduce_sum (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count )   \n void  __bang_reduce_sum (float * dst ,  const  float * src , unsigned int  elem_count )   \n Takes every 128-byte data from  <src>  to add them up and stores the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n *  <dst>  and  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <elem\\_count>  must be greater than zero;\n*  <dst>  can be overlapped with  <src> ;\n* The total number of bytes of  <dst>  is at least 128;\n*  <elem\\_count> \\* sizeof(type)  must be divisible by 128;\n* The first element of every 128 bytes in destination operand  <dst>  is the sum of every 128-byte data, the other elements in destination operand  <dst>  of every 128 bytes will be set to zero on  (m)tp\\_2xx , and they will not be changed on  (m)tp\\_3xx ;\n* This instruction takes every 128 bytes to calculate each time. When vector type is float, This function will take the 32 elements to calculate. When vector type is half, This function will take the 64 elements to calculate. "
  },
  {
    "content": "\n 3.28.37. __bang_rol \n^^^^^^^^^^^^^^^\n void  __bang_rol (unsigned char * dst ,  const  unsigned char * src , unsigned int  shift_bits , unsigned int  elem_count )   \n void  __bang_rol (unsigned short * dst ,  const  unsigned short * src , unsigned int  shift_bits , unsigned int  elem_count )   \n void  __bang_rol (unsigned int * dst ,  const  unsigned int * src , unsigned int  shift_bits , unsigned int  elem_count )   \n This function performs left rotation operation on  <src>  element-wisely with  <shift\\_bits>  bits and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of the source vector.\n*  [in] shift\\_bits : The number of bits left shifted.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <shift\\_bits>  must be greater than or equal to zero;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.38. __bang_ror \n^^^^^^^^^^^^^^^\n void  __bang_ror (unsigned char * dst ,  const  unsigned char * src , unsigned int  shift_bits , unsigned int  elem_count )   \n void  __bang_ror (unsigned short * dst ,  const  unsigned short * src , unsigned int  shift_bits , unsigned int  elem_count )   \n void  __bang_ror (unsigned int * dst ,  const  unsigned int * src , unsigned int  shift_bits , unsigned int  elem_count )   \n This function performs right rotation operation on  <src>  element-wisely with  <shift\\_bits>  bits and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of the source vector.\n*  [in] shift\\_bits : The number of bits right shifted.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <shift\\_bits>  must be greater than or equal to zero;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.39. __bang_round \n^^^^^^^^^^^^^^^\n void  __bang_round (float * dst ,  const  float * src , unsigned int  elem_count )   \n This function performs round operation element-wisely on  <src>  in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of the source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  cannot be overlapped with  <src> ;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.40. __bang_set0in32 \n^^^^^^^^^^^^^^^\n void  __bang_set0in32 (void * dst ,  const  void * src , int  position , unsigned int  elem_count )   \n Set the specified bit to 0. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] position : The specified position to be set to 0.\n*  [in] elem\\_count : Number of elements in source. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n* The bit width of element in  <src>  and  <dst>  is 32 bits;\n*  <dst>  and  <src>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.28.41. __bang_set1in32 \n^^^^^^^^^^^^^^^\n void  __bang_set1in32 (void * dst ,  const  void * src , int  position , unsigned int  elem_count )   \n Set the specified bit to 1. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] position : The specified position to be set to 1.\n*  [in] elem\\_count : Number of elements in source. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  and  <src>  must point to  \\_\\_nram\\_\\_  address space;\n* The bit width of element in  <src>  and  <dst>  is 32 bits;\n*  <dst>  can be overlapped with  <src> . "
  },
  {
    "content": "\n 3.28.42. __bang_sll \n^^^^^^^^^^^^^^^\n void  __bang_sll (char * dst ,  const  char * src , unsigned int  shift_bits , unsigned int  elem_count )   \n void  __bang_sll (short * dst ,  const  short * src , unsigned int  shift_bits , unsigned int  elem_count )   \n void  __bang_sll (int * dst ,  const  int * src , unsigned int  shift_bits , unsigned int  elem_count )   \n This function performs logical left shift element-wisely on  <src>  with  <shift\\_bits>  bits and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of the first source vector.\n*  [in] shift\\_bits : The number of bits left shifted.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <shift\\_bits>  must be greater than or equal to zero;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.43. __bang_square \n^^^^^^^^^^^^^^^\n void  __bang_square (unsigned short * dst ,  const  unsigned char * src , unsigned int  elem_count )   \n void  __bang_square (unsigned int * dst ,  const  unsigned short * src , unsigned int  elem_count )   \n void  __bang_square (short * dst ,  const  char * src , unsigned int  elem_count )   \n void  __bang_square (int * dst ,  const  short * src , unsigned int  elem_count )   \n void  __bang_square (half * dst ,  const  half * src , unsigned int  elem_count )   \n void  __bang_square (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count )   \n void  __bang_square (float * dst ,  const  float * src , unsigned int  elem_count )   \n Applies square activation operation on  <src>  element-wisely, and stores the result in  <dst> . (  =  ^2). \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark \n*  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_SIZE 64 \n __mlu_entry__ void kernel(half* c, half* a) {\n  __nram__ half a_tmp[DATA_SIZE];\n  __nram__ half c_tmp[DATA_SIZE];\n  __memcpy(a_tmp, a, DATA_SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_square(c_tmp, a_tmp, DATA_SIZE);\n  __memcpy(c, c_tmp, DATA_SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.28.44. __bang_sra \n^^^^^^^^^^^^^^^\n void  __bang_sra (char * dst ,  const  char * src , unsigned int  shift_bits , unsigned int  elem_count )   \n void  __bang_sra (short * dst ,  const  short * src , unsigned int  shift_bits , unsigned int  elem_count )   \n void  __bang_sra (int * dst ,  const  int * src , unsigned int  shift_bits , unsigned int  elem_count )   \n This function performs arithmetic right shift element-wisely on  <src>  with  <shift\\_bits>  bits and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of the first source vector.\n*  [in] shift\\_bits : The number of bits right shifted.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <shift\\_bits>  must be greater than or equal to zero;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.45. __bang_srl \n^^^^^^^^^^^^^^^\n void  __bang_srl (unsigned char * dst ,  const  unsigned char * src , unsigned int  shift_bits , unsigned int  elem_count )   \n void  __bang_srl (unsigned short * dst ,  const  unsigned short * src , unsigned int  shift_bits , unsigned int  elem_count )   \n void  __bang_srl (unsigned int * dst ,  const  unsigned int * src , unsigned int  shift_bits , unsigned int  elem_count )   \n This function performs logical right shift element-wisely on  <src>  with  <shift\\_bits>  bits and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of the first source vector.\n*  [in] shift\\_bits : The number of bits right shifted.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <shift\\_bits>  must be greater than or equal to zero;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.46. __bang_sub \n^^^^^^^^^^^^^^^\n void  __bang_sub (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n void  __bang_sub (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_sub (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n void  __bang_sub (unsigned char * dst ,  const  unsigned char * src0 ,  const  unsigned char * src1 , unsigned int  elem_count )   \n void  __bang_sub (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_sub (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_sub (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n This function performs subtraction operation element-wisely on  <src0>  and  <src1>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.28.47. __bang_sub_scalar \n^^^^^^^^^^^^^^^\n void  __bang_sub_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n void  __bang_sub_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_sub_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n void  __bang_sub_scalar (half * dst ,  const  half * src , half  value , unsigned int  elem_count )   \n void  __bang_sub_scalar (bfloat16_t * dst ,  const  bfloat16_t * src , bfloat16_t  value , unsigned int  elem_count )   \n void  __bang_sub_scalar (float * dst ,  const  float * src , float  value , unsigned int  elem_count )   \n This function subtracts  <value>  from  <elem\\_count>  elements of  <src>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <elem\\_count>  must be greater than zero;\n"
  },
  {
    "content": "\n 3.28.48. __bang_subs \n^^^^^^^^^^^^^^^\n void  __bang_subs (unsigned char * dst ,  const  unsigned char * src0 ,  const  unsigned char * src1 , unsigned int  elem_count )   \n void  __bang_subs (unsigned short * dst ,  const  unsigned short * src0 ,  const  unsigned short * src1 , unsigned int  elem_count )   \n void  __bang_subs (unsigned int * dst ,  const  unsigned int * src0 ,  const  unsigned int * src1 , unsigned int  elem_count )   \n void  __bang_subs (char * dst ,  const  char * src0 ,  const  char * src1 , unsigned int  elem_count )   \n void  __bang_subs (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_subs (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n This function performs saturated subtraction operation element-wisely on  <src0>  and  <src1>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of the first source vector.\n*  [in] src1 : The address of the second source vector.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src0> ,  <src1>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst> ,  <src0>  and  <src1>  can be overlapped;\n*  <elem\\_count>  must be greater than zero. \n "
  },
  {
    "content": "\n 3.28.49. __bang_subs_scalar \n^^^^^^^^^^^^^^^\n void  __bang_subs_scalar (char * dst ,  const  char * src , char  value , unsigned int  elem_count )   \n void  __bang_subs_scalar (short * dst ,  const  short * src , short  value , unsigned int  elem_count )   \n void  __bang_subs_scalar (int * dst ,  const  int * src , int  value , unsigned int  elem_count )   \n This function subtracts  <value>  from  <elem\\_count>  elements of  <src>  and saves the saturated result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] value : The source scalar.\n*  [in] elem\\_count : The number of elements in source vector. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <elem\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.29.1. __bang_cos \n^^^^^^^^^^^^^^^\n void  __bang_cos (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count )   \n void  __bang_cos (float * dst ,  const  float * src , unsigned int  elem_count )   \n This function computes the cosine of each element in  <src>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source and destination. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> "
  },
  {
    "content": "\n 3.29.2. __bang_div \n^^^^^^^^^^^^^^^\n void  __bang_div (bfloat16_t * dst ,  const  bfloat16_t * src0 ,  const  bfloat16_t * src1 , unsigned int  elem_count )   \n void  __bang_div (half * dst ,  const  half * src0 ,  const  half * src1 , unsigned int  elem_count )   \n void  __bang_div (float * dst ,  const  float * src0 ,  const  float * src1 , unsigned int  elem_count )   \n void  __bang_div (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_div (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n void  __bang_div (unsigned short * dst ,  const  unsigned short * src0 ,  const  unsigned short * src1 , unsigned int  elem_count )   \n void  __bang_div (unsigned int * dst ,  const  unsigned int * src0 ,  const  unsigned int * src1 , unsigned int  elem_count )   \n void  __bang_div (bfloat16_t * dst ,  const  bfloat16_t * src0 , bfloat16_t  src1 , unsigned int  elem_count )   \n void  __bang_div (half * dst ,  const  half * src0 , half  src1 , unsigned int  elem_count )   \n void  __bang_div (float * dst ,  const  float * src0 , float  src1 , unsigned int  elem_count )   \n void  __bang_div (short * dst ,  const  short * src0 , short  src1 , unsigned int  elem_count )   \n void  __bang_div (int * dst ,  const  int * src0 , int  src1 , unsigned int  elem_count )   \n void  __bang_div (unsigned short * dst ,  const  unsigned short * src0 , unsigned short  src1 , unsigned int  elem_count )   \n void  __bang_div (unsigned int * dst ,  const  unsigned int * src0 , unsigned int  src1 , unsigned int  elem_count )   \n This function computes the division of each element in  <src0>  and  <src1> , and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector, or the value of second source scalar.\n*  [in] elem\\_count : Number of elements in source and destination. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  and  <src0>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space if it is a vector;\n* The value of  <src1>  cannot be equal to zero;\n*  <dst> ,  <src0>  and  <src1>  (vector address) can be overlapped\n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_NUM 128 \n __mlu_entry__ void kernel(int *output, int *src) {\n  __nram__ int _src[DATA_NUM];\n  __nram__ int _output[DATA_NUM];\n  __memcpy(_src, src, DATA_NUM * sizeof(int), GDRAM2NRAM);\n  __bang_div(_output, _src, 10, DATA_NUM);\n  __memcpy(output, _output, DATA_NUM * sizeof(int), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.29.3. __bang_log \n^^^^^^^^^^^^^^^\n void  __bang_log (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count )   \n void  __bang_log (float * dst ,  const  float * src , unsigned int  elem_count )   \n This function computes the binary logarithm of each element in  <src>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source and destination. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> "
  },
  {
    "content": "\n 3.29.4. __bang_pow2 \n^^^^^^^^^^^^^^^\n void  __bang_pow2 (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count )   \n void  __bang_pow2 (float * dst ,  const  float * src , unsigned int  elem_count )   \n This function computes the value of 2 to the power of  <src>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source and destination. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> "
  },
  {
    "content": "\n 3.29.5. __bang_recip \n^^^^^^^^^^^^^^^\n void  __bang_recip (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count )   \n void  __bang_recip (float * dst ,  const  float * src , unsigned int  elem_count )   \n This function computes the reciprocal of each element in  <src>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source and destination. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> "
  },
  {
    "content": "\n 3.29.6. __bang_rem \n^^^^^^^^^^^^^^^\n void  __bang_rem (short * dst ,  const  short * src0 ,  const  short * src1 , unsigned int  elem_count )   \n void  __bang_rem (int * dst ,  const  int * src0 ,  const  int * src1 , unsigned int  elem_count )   \n void  __bang_rem (unsigned short * dst ,  const  unsigned short * src0 ,  const  unsigned short * src1 , unsigned int  elem_count )   \n void  __bang_rem (unsigned int * dst ,  const  unsigned int * src0 ,  const  unsigned int * src1 , unsigned int  elem_count )   \n void  __bang_rem (short * dst ,  const  short * src0 , short  src1 , unsigned int  elem_count )   \n void  __bang_rem (int * dst ,  const  int * src0 , int  src1 , unsigned int  elem_count )   \n void  __bang_rem (unsigned short * dst ,  const  unsigned short * src0 , unsigned short  src1 , unsigned int  elem_count )   \n void  __bang_rem (unsigned int * dst ,  const  unsigned int * src0 , unsigned int  src1 , unsigned int  elem_count )   \n This function computes the remainder of each element in  <src>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src0 : The address of first source vector.\n*  [in] src1 : The address of second source vector, or the value of second source scalar.\n*  [in] elem\\_count : Number of elements in source and destination. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <dst>  and  <src0>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src1>  must point to  \\_\\_nram\\_\\_  address space if it is a vector;\n* The value of  <src1>  cannot be equal to zero;\n*  <dst> ,  <src0>  and  <src1>  (vector address) can be overlapped. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_NUM 128 \n __mlu_entry__ void kernel(int *output, int *src) {\n  __nram__ int _src[DATA_NUM];\n  __nram__ int _output[DATA_NUM];\n  __memcpy(_src, src, DATA_NUM * sizeof(int), GDRAM2NRAM);\n  __bang_rem(_output, _src, 10, DATA_NUM);\n  __memcpy(output, _output, DATA_NUM * sizeof(int), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.29.7. __bang_rsqrt \n^^^^^^^^^^^^^^^\n void  __bang_rsqrt (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count )   \n void  __bang_rsqrt (float * dst ,  const  float * src , unsigned int  elem_count )   \n This function computes the reciprocal of square root of each element in  <src>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source and destination. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> "
  },
  {
    "content": "\n 3.29.8. __bang_sin \n^^^^^^^^^^^^^^^\n void  __bang_sin (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count )   \n void  __bang_sin (float * dst ,  const  float * src , unsigned int  elem_count )   \n This function computes the sine of each element in  <src>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source and destination. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define DATA_NUM 128 \n __mlu_entry__ void kernel(float *output, float *src) {\n  __nram__ float _src[DATA_NUM];\n  __nram__ float _output[DATA_NUM];\n  __memcpy(_src, src, DATA_NUM * sizeof(float), GDRAM2NRAM);\n  __bang_sin(_output, _src, DATA_NUM);\n  __memcpy(output, _output, DATA_NUM * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.29.9. __bang_sqrt \n^^^^^^^^^^^^^^^\n void  __bang_sqrt (bfloat16_t * dst ,  const  bfloat16_t * src , unsigned int  elem_count )   \n void  __bang_sqrt (float * dst ,  const  float * src , unsigned int  elem_count )   \n This function computes the square root of each element in  <src>  and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] elem\\_count : Number of elements in source and destination. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <elem\\_count>  must be greater than zero;\n*  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst>  can be overlapped with  <src> "
  },
  {
    "content": "\n 3.30.1. __bang_bfloat162float \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162float (float * dst ,  const  bfloat16_t * src , unsigned int  src_count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  float  element-wisely and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(float *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_tmp[SIZE];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162float(dst_tmp, src_tmp, SIZE);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.2. __bang_bfloat162half \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162half (half * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  half  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(half *dst, bfloat16_t *src) {\n  __nram__ half dst_nram[LEN];\n  __nram__ bfloat16_t src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162half(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.3. __bang_bfloat162half_dn \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162half_dn (half * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  half  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(half *dst, bfloat16_t *src) {\n  __nram__ half dst_nram[LEN];\n  __nram__ bfloat16_t src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162half_dn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.4. __bang_bfloat162half_oz \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162half_oz (half * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  half  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(half *dst, bfloat16_t *src) {\n  __nram__ half dst_nram[LEN];\n  __nram__ bfloat16_t src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162half_oz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.5. __bang_bfloat162half_rd \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162half_rd (half * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  half  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(half *dst, bfloat16_t *src) {\n  __nram__ half dst_nram[LEN];\n  __nram__ bfloat16_t src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162half_rd(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.6. __bang_bfloat162half_rm \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162half_rm (half * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  half  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(half *dst, bfloat16_t *src) {\n  __nram__ half dst_nram[LEN];\n  __nram__ bfloat16_t src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162half_rm(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.7. __bang_bfloat162half_rn \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162half_rn (half * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  half  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(half *dst, bfloat16_t *src) {\n  __nram__ half dst_nram[LEN];\n  __nram__ bfloat16_t src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162half_rn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.8. __bang_bfloat162half_tz \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162half_tz (half * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  half  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(half *dst, bfloat16_t *src) {\n  __nram__ half dst_nram[LEN];\n  __nram__ bfloat16_t src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162half_tz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.9. __bang_bfloat162half_up \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162half_up (half * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  half  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(half *dst, bfloat16_t *src) {\n  __nram__ half dst_nram[LEN];\n  __nram__ bfloat16_t src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162half_up(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.10. __bang_bfloat162int16 \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int16 (int16_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int16(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.11. __bang_bfloat162int16_dn \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int16_dn (int16_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int16\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int16_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.12. __bang_bfloat162int16_oz \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int16_oz (int16_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int16\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int16_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.13. __bang_bfloat162int16_rd \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int16_rd (int16_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int16\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int16_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.14. __bang_bfloat162int16_rm \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int16_rm (int16_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int16\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int16_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.15. __bang_bfloat162int16_rn \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int16_rn (int16_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int16\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int16_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.16. __bang_bfloat162int16_tz \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int16_tz (int16_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int16_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.17. __bang_bfloat162int16_up \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int16_up (int16_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int16\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int16_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.18. __bang_bfloat162int32 \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int32 (int32_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int32\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int32(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.19. __bang_bfloat162int32_dn \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int32_dn (int32_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int32\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int32_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.20. __bang_bfloat162int32_oz \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int32_oz (int32_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int32\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int32_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.21. __bang_bfloat162int32_rd \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int32_rd (int32_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int32\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int32_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.22. __bang_bfloat162int32_rm \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int32_rm (int32_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int32\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int32_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.23. __bang_bfloat162int32_rn \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int32_rn (int32_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int32\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int32_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.24. __bang_bfloat162int32_tz \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int32_tz (int32_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int32\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int32_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.25. __bang_bfloat162int32_up \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int32_up (int32_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int32\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int32_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.26. __bang_bfloat162int4_dn \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int4_dn (int4x2_t * dst ,  const  bfloat16_t * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int4  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int4_dn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.27. __bang_bfloat162int4_oz \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int4_oz (int4x2_t * dst ,  const  bfloat16_t * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int4  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int4_oz(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.28. __bang_bfloat162int4_rd \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int4_rd (int4x2_t * dst ,  const  bfloat16_t * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int4  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int4_rd(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.29. __bang_bfloat162int4_rm \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int4_rm (int4x2_t * dst ,  const  bfloat16_t * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int4  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int4_rm(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.30. __bang_bfloat162int4_rn \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int4_rn (int4x2_t * dst ,  const  bfloat16_t * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int4  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int4_rn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.31. __bang_bfloat162int4_tz \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int4_tz (int4x2_t * dst ,  const  bfloat16_t * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int4  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int4_tz(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.32. __bang_bfloat162int4_up \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int4_up (int4x2_t * dst ,  const  bfloat16_t * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int4  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int4_up(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.33. __bang_bfloat162int8 \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int8 (int8_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int8\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int8(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.34. __bang_bfloat162int8_dn \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int8_dn (int8_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int8\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int8_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.35. __bang_bfloat162int8_oz \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int8_oz (int8_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int8\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int8_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.36. __bang_bfloat162int8_rd \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int8_rd (int8_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int8\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int8_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.37. __bang_bfloat162int8_rm \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int8_rm (int8_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int8\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int8_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.38. __bang_bfloat162int8_rn \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int8_rn (int8_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int8\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int8_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.39. __bang_bfloat162int8_tz \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int8_tz (int8_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int8\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int8_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.40. __bang_bfloat162int8_up \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162int8_up (int8_t * dst ,  const  bfloat16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  bfloat16\\_t  to  int8\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162int8_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.41. __bang_bfloat162tf32 \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162tf32 (float * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  tf32  element-wisely and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162tf32(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.42. __bang_bfloat162uchar \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162uchar (unsigned char * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  unsigned char  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162uchar(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.43. __bang_bfloat162uchar_dn \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162uchar_dn (unsigned char * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  unsigned char  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162uchar_dn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.44. __bang_bfloat162uchar_oz \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162uchar_oz (unsigned char * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  unsigned char  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162uchar_oz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.45. __bang_bfloat162uchar_rd \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162uchar_rd (unsigned char * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  unsigned char  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162uchar_rd(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.46. __bang_bfloat162uchar_rm \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162uchar_rm (unsigned char * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  unsigned char  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162uchar_rm(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.47. __bang_bfloat162uchar_rn \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162uchar_rn (unsigned char * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  unsigned char  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162uchar_rn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.48. __bang_bfloat162uchar_tz \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162uchar_tz (unsigned char * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  unsigned char  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162uchar_tz(dst_nram, src_nram);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.49. __bang_bfloat162uchar_up \n^^^^^^^^^^^^^^^\n void  __bang_bfloat162uchar_up (unsigned char * dst ,  const  bfloat16_t * src , unsigned int  count )   \n This function converts type of  <src>  from  bfloat16\\_t  to  unsigned char  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, bfloat16_t *src) {\n  __nram__ bfloat16_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(bfloat16_t), GDRAM2NRAM);\n  __bang_bfloat162uchar_up(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.50. __bang_float2bfloat16_dn \n^^^^^^^^^^^^^^^\n void  __bang_float2bfloat16_dn (bfloat16_t * dst ,  const  float * src , unsigned int  src_count )   \n This function converts type of  <src>  from  float  to  bfloat16\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.30.51. __bang_float2bfloat16_oz \n^^^^^^^^^^^^^^^\n void  __bang_float2bfloat16_oz (bfloat16_t * dst ,  const  float * src , unsigned int  src_count )   \n This function converts type of  <src>  from  float  to  bfloat16\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.30.52. __bang_float2bfloat16_rd \n^^^^^^^^^^^^^^^\n void  __bang_float2bfloat16_rd (bfloat16_t * dst ,  const  float * src , unsigned int  src_count )   \n This function converts type of  <src>  from  float  to  bfloat16\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.30.53. __bang_float2bfloat16_rm \n^^^^^^^^^^^^^^^\n void  __bang_float2bfloat16_rm (bfloat16_t * dst ,  const  float * src , unsigned int  src_count )   \n This function converts type of  <src>  from  float  to  bfloat16\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. \n ^^^^^^^^^^^^^^^\n \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ bfloat16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2bfloat16_rm(dst_tmp, src_tmp, SIZE);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.54. __bang_float2bfloat16_rn \n^^^^^^^^^^^^^^^\n void  __bang_float2bfloat16_rn (bfloat16_t * dst ,  const  float * src , unsigned int  src_count )   \n This function converts type of  <src>  from  float  to  bfloat16\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.30.55. __bang_float2bfloat16_tz \n^^^^^^^^^^^^^^^\n void  __bang_float2bfloat16_tz (bfloat16_t * dst ,  const  float * src , unsigned int  src_count )   \n This function converts type of  <src>  from  float  to  bfloat16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.30.56. __bang_float2bfloat16_up \n^^^^^^^^^^^^^^^\n void  __bang_float2bfloat16_up (bfloat16_t * dst ,  const  float * src , unsigned int  src_count )   \n This function converts type of  <src>  from  float  to  bfloat16\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. "
  },
  {
    "content": "\n 3.30.57. __bang_float2half_dn \n^^^^^^^^^^^^^^^\n void  __bang_float2half_dn (half * dst ,  const  float * src , unsigned int  src_count )   \n void  __bang_float2half_dn (half * dst ,  const  float * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  float  to  half  element-wisely in round-down mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-down mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark \n*  <src\\_stride>  must be divisible by sizeof(float);\n* (  \\div sizeof(float) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. "
  },
  {
    "content": "\n 3.30.58. __bang_float2half_oz \n^^^^^^^^^^^^^^^\n void  __bang_float2half_oz (half * dst ,  const  float * src , unsigned int  src_count )   \n void  __bang_float2half_oz (half * dst ,  const  float * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  float  to  half  element-wisely in round-off-zero mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-off-zero mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(half) , and divisible by 64 on  (m)tp\\_2xx , and divisible by sizeof(half) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(float);\n* (  \\div sizeof(float) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. "
  },
  {
    "content": "\n 3.30.59. __bang_float2half_rd \n^^^^^^^^^^^^^^^\n void  __bang_float2half_rd (half * dst ,  const  float * src , unsigned int  src_count )   \n void  __bang_float2half_rd (half * dst ,  const  float * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  float  to  half  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-nearest-off-zero mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(half) , and divisible by 64 on  (m)tp\\_2xx , and divisible by sizeof(half) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(float);\n* (  \\div sizeof(float) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. "
  },
  {
    "content": "\n 3.30.60. __bang_float2half_rm \n^^^^^^^^^^^^^^^\n void  __bang_float2half_rm (half * dst ,  const  float * src , unsigned int  src_count )   \n void  __bang_float2half_rm (half * dst ,  const  float * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  float  to  half  element-wisely in round-math mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-math mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(half) , and divisible by sizeof(half) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(float);\n* (  \\div sizeof(float) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(half *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ half dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2half_rm(dst_tmp, src_tmp, SIZE);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.61. __bang_float2half_rn \n^^^^^^^^^^^^^^^\n void  __bang_float2half_rn (half * dst ,  const  float * src , unsigned int  src_count )   \n void  __bang_float2half_rn (half * dst ,  const  float * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  float  to  half  element-wisely in round-nearest-even mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-nearest-even mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(half) , and divisible by sizeof(half) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(float);\n* (  \\div sizeof(float) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. "
  },
  {
    "content": "\n 3.30.62. __bang_float2half_sr \n^^^^^^^^^^^^^^^\n void  __bang_float2half_sr (half * dst ,  const  float * src , int * srv , unsigned int  count )   \n Converts source vector with element type  float  to destination vector with element type  half  in round-stochastic mode. The number of elements in the source and destination vectors is  <count> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] srv : The address of stochastic vector.\n*  [in] count : The elements number of conversion. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <src> ,  <srv>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space. \n"
  },
  {
    "content": "\n 3.30.63. __bang_float2half_tz \n^^^^^^^^^^^^^^^\n void  __bang_float2half_tz (half * dst ,  const  float * src , unsigned int  src_count )   \n void  __bang_float2half_tz (half * dst ,  const  float * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  float  to  half  element-wisely in round-to-zero mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-to-zero mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(half) , and divisible by 64 on  (m)tp\\_2xx , and divisible by sizeof(half) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(float);\n* (  \\div sizeof(float) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SRC_STRIDE 160 \n define DST_STRIDE 320 \n define LEN 128 \n define SEG_NUM 20 \n __mlu_entry__ void kernel(half *dst, float *src, int size) {\n  __nram__ float src_tmp[SRC_STRIDE * SEG_NUM + LEN];\n  __nram__ half dst_tmp[DST_STRIDE / sizeof(half) * SEG_NUM + LEN];\n  __memcpy(src_tmp, src, size * sizeof(float), GDRAM2NRAM);\n  __bang_float2half_tz(dst_tmp, src_tmp, LEN, DST_STRIDE, SRC_STRIDE, SEG_NUM);\n  __memcpy(dst, dst_tmp, (DST_STRIDE * SEG_NUM + LEN * sizeof(half)), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.64. __bang_float2half_up \n^^^^^^^^^^^^^^^\n void  __bang_float2half_up (half * dst ,  const  float * src , unsigned int  src_count )   \n void  __bang_float2half_up (half * dst ,  const  float * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  float  to  half  element-wisely in round-up mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-up mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(half) , and divisible by 64 on  (m)tp\\_2xx , and divisible by sizeof(half) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(float);\n* (  \\div sizeof(float) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. "
  },
  {
    "content": "\n 3.30.65. __bang_float2int16_dn \n^^^^^^^^^^^^^^^\n void  __bang_float2int16_dn (int16_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int16\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(int16_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int16_dn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.66. __bang_float2int16_oz \n^^^^^^^^^^^^^^^\n void  __bang_float2int16_oz (int16_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int16\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.67. __bang_float2int16_rd \n^^^^^^^^^^^^^^^\n void  __bang_float2int16_rd (int16_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int16\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.68. __bang_float2int16_rm \n^^^^^^^^^^^^^^^\n void  __bang_float2int16_rm (int16_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int16\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.69. __bang_float2int16_rn \n^^^^^^^^^^^^^^^\n void  __bang_float2int16_rn (int16_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int16\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.70. __bang_float2int16_tz \n^^^^^^^^^^^^^^^\n void  __bang_float2int16_tz (int16_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.71. __bang_float2int16_up \n^^^^^^^^^^^^^^^\n void  __bang_float2int16_up (int16_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int16\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.72. __bang_float2int32 \n^^^^^^^^^^^^^^^\n void  __bang_float2int32 (int32_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int32\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(int32_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int32(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.73. __bang_float2int32_dn \n^^^^^^^^^^^^^^^\n void  __bang_float2int32_dn (int32_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int32\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(int32_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int32_dn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.74. __bang_float2int32_oz \n^^^^^^^^^^^^^^^\n void  __bang_float2int32_oz (int32_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int32\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(int32_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int32_oz(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.75. __bang_float2int32_rd \n^^^^^^^^^^^^^^^\n void  __bang_float2int32_rd (int32_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int32\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(int32_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int32_rd(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.76. __bang_float2int32_rm \n^^^^^^^^^^^^^^^\n void  __bang_float2int32_rm (int32_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int32\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(int32_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int32_rm(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.77. __bang_float2int32_rn \n^^^^^^^^^^^^^^^\n void  __bang_float2int32_rn (int32_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int32\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(int32_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int32_rn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.78. __bang_float2int32_tz \n^^^^^^^^^^^^^^^\n void  __bang_float2int32_tz (int32_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int32\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(int32_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int32_tz(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.79. __bang_float2int32_up \n^^^^^^^^^^^^^^^\n void  __bang_float2int32_up (int32_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int32\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(int32_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int32_up(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.80. __bang_float2int4_dn \n^^^^^^^^^^^^^^^\n void  __bang_float2int4_dn (int4x2_t * dst ,  const  float * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  float  to  int4  element-wisely in round-down mode. and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int4_dn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.81. __bang_float2int4_oz \n^^^^^^^^^^^^^^^\n void  __bang_float2int4_oz (int4x2_t * dst ,  const  float * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  float  to  int4  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int4_oz(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.82. __bang_float2int4_rd \n^^^^^^^^^^^^^^^\n void  __bang_float2int4_rd (int4x2_t * dst ,  const  float * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  float  to  int4  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int4_rd(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.83. __bang_float2int4_rm \n^^^^^^^^^^^^^^^\n void  __bang_float2int4_rm (int4x2_t * dst ,  const  float * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  float  to  int4  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int4_rm(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.84. __bang_float2int4_rn \n^^^^^^^^^^^^^^^\n void  __bang_float2int4_rn (int4x2_t * dst ,  const  float * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  float  to  int4  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int4_rn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.85. __bang_float2int4_tz \n^^^^^^^^^^^^^^^\n void  __bang_float2int4_tz (int4x2_t * dst ,  const  float * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  float  to  int4  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int4_tz(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.86. __bang_float2int4_up \n^^^^^^^^^^^^^^^\n void  __bang_float2int4_up (int4x2_t * dst ,  const  float * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  float  to  int4  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int4_up(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.87. __bang_float2int8_dn \n^^^^^^^^^^^^^^^\n void  __bang_float2int8_dn (int8_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int8\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(int8_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int8_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int8_dn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.88. __bang_float2int8_oz \n^^^^^^^^^^^^^^^\n void  __bang_float2int8_oz (int8_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int8\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.89. __bang_float2int8_rd \n^^^^^^^^^^^^^^^\n void  __bang_float2int8_rd (int8_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int8\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.90. __bang_float2int8_rm \n^^^^^^^^^^^^^^^\n void  __bang_float2int8_rm (int8_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int8\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.91. __bang_float2int8_rn \n^^^^^^^^^^^^^^^\n void  __bang_float2int8_rn (int8_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int8\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.92. __bang_float2int8_tz \n^^^^^^^^^^^^^^^\n void  __bang_float2int8_tz (int8_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int8\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.93. __bang_float2int8_up \n^^^^^^^^^^^^^^^\n void  __bang_float2int8_up (int8_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  int8\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.94. __bang_float2tf32 \n^^^^^^^^^^^^^^^\n void  __bang_float2tf32 (float * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  float  to  tf32  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_float2tf32(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.95. __bang_float2tf32_dn \n^^^^^^^^^^^^^^^\n void  __bang_float2tf32_dn (float * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  float  to  tf32  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_float2tf32_dn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.96. __bang_float2tf32_oz \n^^^^^^^^^^^^^^^\n void  __bang_float2tf32_oz (float * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  float  to  tf32  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_float2tf32_oz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.97. __bang_float2tf32_rd \n^^^^^^^^^^^^^^^\n void  __bang_float2tf32_rd (float * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  float  to  tf32  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_float2tf32_rd(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.98. __bang_float2tf32_rm \n^^^^^^^^^^^^^^^\n void  __bang_float2tf32_rm (float * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  float  to  tf32  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_float2tf32_rm(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.99. __bang_float2tf32_rn \n^^^^^^^^^^^^^^^\n void  __bang_float2tf32_rn (float * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  float  to  tf32  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_float2tf32_rn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.100. __bang_float2tf32_sr \n^^^^^^^^^^^^^^^\n void  __bang_float2tf32_sr (float * dst ,  const  float * src ,  const  int * srv , unsigned int  count )   \n Converts source vector with element type  float  to destination vector with element type  tf32  in round-stochastic mode. The number of elements in the source and destination vectors is  <count> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] srv : The address of stochastic vector.\n*  [in] count : The elements number of conversion. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <src> ,  <srv>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space. \n"
  },
  {
    "content": "\n 3.30.101. __bang_float2tf32_tz \n^^^^^^^^^^^^^^^\n void  __bang_float2tf32_tz (float * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  float  to  tf32  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_float2tf32_tz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.102. __bang_float2tf32_up \n^^^^^^^^^^^^^^^\n void  __bang_float2tf32_up (float * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  float  to  tf32  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_float2tf32_up(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.103. __bang_float2uchar \n^^^^^^^^^^^^^^^\n void  __bang_float2uchar (unsigned char * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  float  to  unsigned char  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_float2uchar(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.104. __bang_float2uchar_dn \n^^^^^^^^^^^^^^^\n void  __bang_float2uchar_dn (unsigned char * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  float  to  unsigned char  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_float2uchar_dn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.105. __bang_float2uchar_oz \n^^^^^^^^^^^^^^^\n void  __bang_float2uchar_oz (unsigned char * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  float  to  unsigned char  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_float2uchar_oz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.106. __bang_float2uchar_rd \n^^^^^^^^^^^^^^^\n void  __bang_float2uchar_rd (unsigned char * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  float  to  unsigned char  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_float2uchar_rd(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.107. __bang_float2uchar_rm \n^^^^^^^^^^^^^^^\n void  __bang_float2uchar_rm (unsigned char * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  float  to  unsigned char  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_float2uchar_rm(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.108. __bang_float2uchar_rn \n^^^^^^^^^^^^^^^\n void  __bang_float2uchar_rn (unsigned char * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  float  to  unsigned char  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_float2uchar_rn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.109. __bang_float2uchar_tz \n^^^^^^^^^^^^^^^\n void  __bang_float2uchar_tz (unsigned char * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  float  to  unsigned char  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_float2uchar_tz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.110. __bang_float2uchar_up \n^^^^^^^^^^^^^^^\n void  __bang_float2uchar_up (unsigned char * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  float  to  unsigned char  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_float2uchar_up(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.111. __bang_float2uint16_dn \n^^^^^^^^^^^^^^^\n void  __bang_float2uint16_dn (uint16_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint16\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(uint16_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ uint16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2uint16_dn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(uint16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.112. __bang_float2uint16_oz \n^^^^^^^^^^^^^^^\n void  __bang_float2uint16_oz (uint16_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint16\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.113. __bang_float2uint16_rd \n^^^^^^^^^^^^^^^\n void  __bang_float2uint16_rd (uint16_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint16\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.114. __bang_float2uint16_rm \n^^^^^^^^^^^^^^^\n void  __bang_float2uint16_rm (uint16_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint16\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.115. __bang_float2uint16_rn \n^^^^^^^^^^^^^^^\n void  __bang_float2uint16_rn (uint16_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint16\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.116. __bang_float2uint16_tz \n^^^^^^^^^^^^^^^\n void  __bang_float2uint16_tz (uint16_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.117. __bang_float2uint16_up \n^^^^^^^^^^^^^^^\n void  __bang_float2uint16_up (uint16_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint16\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.118. __bang_float2uint32_dn \n^^^^^^^^^^^^^^^\n void  __bang_float2uint32_dn (uint32_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint32\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(uint32_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ uint32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2uint32_dn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(uint32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.119. __bang_float2uint32_oz \n^^^^^^^^^^^^^^^\n void  __bang_float2uint32_oz (uint32_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint32\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.120. __bang_float2uint32_rd \n^^^^^^^^^^^^^^^\n void  __bang_float2uint32_rd (uint32_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint32\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.121. __bang_float2uint32_rm \n^^^^^^^^^^^^^^^\n void  __bang_float2uint32_rm (uint32_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint32\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.122. __bang_float2uint32_rn \n^^^^^^^^^^^^^^^\n void  __bang_float2uint32_rn (uint32_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint32\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.123. __bang_float2uint32_tz \n^^^^^^^^^^^^^^^\n void  __bang_float2uint32_tz (uint32_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint32\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.124. __bang_float2uint32_up \n^^^^^^^^^^^^^^^\n void  __bang_float2uint32_up (uint32_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint32\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.125. __bang_float2uint8_dn \n^^^^^^^^^^^^^^^\n void  __bang_float2uint8_dn (uint8_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint8\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(uint8_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ uint8_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2uint8_dn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(uint8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.126. __bang_float2uint8_oz \n^^^^^^^^^^^^^^^\n void  __bang_float2uint8_oz (uint8_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint8\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.127. __bang_float2uint8_rd \n^^^^^^^^^^^^^^^\n void  __bang_float2uint8_rd (uint8_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint8\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.128. __bang_float2uint8_rm \n^^^^^^^^^^^^^^^\n void  __bang_float2uint8_rm (uint8_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint8\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.129. __bang_float2uint8_rn \n^^^^^^^^^^^^^^^\n void  __bang_float2uint8_rn (uint8_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint8\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.130. __bang_float2uint8_tz \n^^^^^^^^^^^^^^^\n void  __bang_float2uint8_tz (uint8_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint8\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.131. __bang_float2uint8_up \n^^^^^^^^^^^^^^^\n void  __bang_float2uint8_up (uint8_t * dst ,  const  float * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  float  to  uint8\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.132. __bang_half2bfloat16 \n^^^^^^^^^^^^^^^\n void  __bang_half2bfloat16 (bfloat16_t * dst ,  const  half * src , unsigned int  count )   \n This function converts type of  <src>  from  half  to  bfloat16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float16_t *dst, half *src) {\n  __nram__ bfloat16_t dst_nram[LEN];\n  __nram__ half src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2bfloat16(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.133. __bang_half2bfloat16_dn \n^^^^^^^^^^^^^^^\n void  __bang_half2bfloat16_dn (bfloat16_t * dst ,  const  half * src , unsigned int  count )   \n This function converts type of  <src>  from  half  to  bfloat16\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, half *src) {\n  __nram__ bfloat16_t dst_nram[LEN];\n  __nram__ half src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2bfloat16_dn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.134. __bang_half2bfloat16_oz \n^^^^^^^^^^^^^^^\n void  __bang_half2bfloat16_oz (bfloat16_t * dst ,  const  half * src , unsigned int  count )   \n This function converts type of  <src>  from  half  to  bfloat16\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, half *src) {\n  __nram__ bfloat16_t dst_nram[LEN];\n  __nram__ half src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2bfloat16_oz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.135. __bang_half2bfloat16_rd \n^^^^^^^^^^^^^^^\n void  __bang_half2bfloat16_rd (bfloat16_t * dst ,  const  half * src , unsigned int  count )   \n This function converts type of  <src>  from  half  to  bfloat16\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, half *src) {\n  __nram__ bfloat16_t dst_nram[LEN];\n  __nram__ half src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2bfloat16_rd(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.136. __bang_half2bfloat16_rm \n^^^^^^^^^^^^^^^\n void  __bang_half2bfloat16_rm (bfloat16_t * dst ,  const  half * src , unsigned int  count )   \n This function converts type of  <src>  from  half  to  bfloat16\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, half *src) {\n  __nram__ bfloat16_t dst_nram[LEN];\n  __nram__ half src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2bfloat16_rm(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.137. __bang_half2bfloat16_rn \n^^^^^^^^^^^^^^^\n void  __bang_half2bfloat16_rn (bfloat16_t * dst ,  const  half * src , unsigned int  count )   \n This function converts type of  <src>  from  half  to  bfloat16\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, half *src) {\n  __nram__ bfloat16_t dst_nram[LEN];\n  __nram__ half src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2bfloat16_rn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.138. __bang_half2bfloat16_tz \n^^^^^^^^^^^^^^^\n void  __bang_half2bfloat16_tz (bfloat16_t * dst ,  const  half * src , unsigned int  count )   \n This function converts type of  <src>  from  half  to  bfloat16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, half *src) {\n  __nram__ bfloat16_t dst_nram[LEN];\n  __nram__ half src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2bfloat16_tz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.139. __bang_half2bfloat16_up \n^^^^^^^^^^^^^^^\n void  __bang_half2bfloat16_up (bfloat16_t * dst ,  const  half * src , unsigned int  count )   \n This function converts type of  <src>  from  half  to  bfloat16\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, half *src) {\n  __nram__ bfloat16_t dst_nram[LEN];\n  __nram__ half src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2bfloat16_up(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.140. __bang_half2float \n^^^^^^^^^^^^^^^\n void  __bang_half2float (float * dst ,  const  half * src , unsigned int  src_count )   \n void  __bang_half2float (float * dst ,  const  half * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  half  to  float  element-wisely in round-to-zero mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-to-zero mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(float) , and divisible by 64 on  (m)tp\\_2xx , and divisible by sizeof(float) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(half);\n* (  \\div sizeof(half) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  cannot be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SRC_STRIDE 160 \n define DST_STRIDE 512 \n define LEN 128 \n define SEG_NUM 20 \n __mlu_entry__ void kernel(float *dst, half *src, int size) {\n  __nram__ half src_tmp[SRC_STRIDE * SEG_NUM + LEN];\n  __nram__ float dst_tmp[DST_STRIDE / sizeof(float) * SEG_NUM + LEN];\n  __memcpy(src_tmp, src, size * sizeof(half), GDRAM2NRAM);\n  __bang_half2float(dst_tmp, src_tmp, LEN, DST_STRIDE, SRC_STRIDE, SEG_NUM);\n  __memcpy(dst, dst_tmp, (DST_STRIDE * SEG_NUM + LEN * sizeof(float)), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.141. __bang_half2int16_dn \n^^^^^^^^^^^^^^^\n void  __bang_half2int16_dn (int16_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  half  to  int16\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(int16_t *dst, half *src) {\n  __nram__ half src_tmp[SIZE];\n  __nram__ int16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_half2int16_dn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.142. __bang_half2int16_oz \n^^^^^^^^^^^^^^^\n void  __bang_half2int16_oz (int16_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  half  to  int16\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.143. __bang_half2int16_rd \n^^^^^^^^^^^^^^^\n void  __bang_half2int16_rd (int16_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  half  to  int16\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.144. __bang_half2int16_rm \n^^^^^^^^^^^^^^^\n void  __bang_half2int16_rm (int16_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  half  to  int16\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.145. __bang_half2int16_rn \n^^^^^^^^^^^^^^^\n void  __bang_half2int16_rn (int16_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  half  to  int16\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.146. __bang_half2int16_tz \n^^^^^^^^^^^^^^^\n void  __bang_half2int16_tz (int16_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  half  to  int16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . "
  },
  {
    "content": "\n 3.30.147. __bang_half2int16_up \n^^^^^^^^^^^^^^^\n void  __bang_half2int16_up (int16_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  half  to  int16\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . "
  },
  {
    "content": "\n 3.30.148. __bang_half2int32 \n^^^^^^^^^^^^^^^\n void  __bang_half2int32 (int32_t * dst ,  const  half * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  half  to  int32\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, half *src) {\n  __nram__ half src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2int32(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.149. __bang_half2int32_dn \n^^^^^^^^^^^^^^^\n void  __bang_half2int32_dn (int32_t * dst ,  const  half * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  half  to  int32\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, half *src) {\n  __nram__ half src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2int32_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.150. __bang_half2int32_oz \n^^^^^^^^^^^^^^^\n void  __bang_half2int32_oz (int32_t * dst ,  const  half * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  half  to  int32\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, half *src) {\n  __nram__ half src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2int32_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.151. __bang_half2int32_rd \n^^^^^^^^^^^^^^^\n void  __bang_half2int32_rd (int32_t * dst ,  const  half * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  half  to  int32\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, half *src) {\n  __nram__ half src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2int32_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.152. __bang_half2int32_rm \n^^^^^^^^^^^^^^^\n void  __bang_half2int32_rm (int32_t * dst ,  const  half * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  half  to  int32\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, half *src) {\n  __nram__ half src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2int32_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.153. __bang_half2int32_rn \n^^^^^^^^^^^^^^^\n void  __bang_half2int32_rn (int32_t * dst ,  const  half * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  half  to  int32\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, half *src) {\n  __nram__ half src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2int32_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.154. __bang_half2int32_tz \n^^^^^^^^^^^^^^^\n void  __bang_half2int32_tz (int32_t * dst ,  const  half * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  half  to  int32\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, half *src) {\n  __nram__ half src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2int32_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.155. __bang_half2int32_up \n^^^^^^^^^^^^^^^\n void  __bang_half2int32_up (int32_t * dst ,  const  half * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  half  to  int32\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, half *src) {\n  __nram__ half src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2int32_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.156. __bang_half2int4_dn \n^^^^^^^^^^^^^^^\n void  __bang_half2int4_dn (int4x2_t * dst ,  const  half * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  half  to  int4  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, half *src) {\n  __nram__ half src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_half2int4_dn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.157. __bang_half2int4_oz \n^^^^^^^^^^^^^^^\n void  __bang_half2int4_oz (int4x2_t * dst ,  const  half * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  half  to  int4  element-wisely in in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, half *src) {\n  __nram__ half src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_half2int4_oz(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.158. __bang_half2int4_rd \n^^^^^^^^^^^^^^^\n void  __bang_half2int4_rd (int4x2_t * dst ,  const  half * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  half  to  int4  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, float *src) {\n  __nram__ float src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_float2int4_tz(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.159. __bang_half2int4_rm \n^^^^^^^^^^^^^^^\n void  __bang_half2int4_rm (int4x2_t * dst ,  const  half * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  half  to  int4  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, half *src) {\n  __nram__ half src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_half2int4_rm(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.160. __bang_half2int4_rn \n^^^^^^^^^^^^^^^\n void  __bang_half2int4_rn (int4x2_t * dst ,  const  half * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  half  to  int4  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, half *src) {\n  __nram__ half src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_half2int4_rn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.161. __bang_half2int4_tz \n^^^^^^^^^^^^^^^\n void  __bang_half2int4_tz (int4x2_t * dst ,  const  half * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  half  to  int4  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, half *src) {\n  __nram__ half src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_half2int4_tz(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.162. __bang_half2int4_up \n^^^^^^^^^^^^^^^\n void  __bang_half2int4_up (int4x2_t * dst ,  const  half * src , unsigned int  size , int  dst_position )   \n This function converts type of  <src>  from  half  to  int4  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, half *src) {\n  __nram__ half src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_half2int4_up(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.163. __bang_half2int8_dn \n^^^^^^^^^^^^^^^\n void  __bang_half2int8_dn (int8_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position )   \n void  __bang_half2int8_dn (int8_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  half  to  int8\\_t  element-wisely in round-down mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements according to  <fix\\_position>  in round-down mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n Fig. 3.20 The Process of Conversion with Stride \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src\\_stride>  must be divisible by sizeof(half);\n* (  \\div sizeof(half) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SRC_STRIDE 160 \n define DST_STRIDE 320 \n define LEN 128 \n define SEG_NUM 20 \n define POS 5 \n __mlu_entry__ void kernel(int8_t *dst, half *src, int size) {\n  __nram__ half src_tmp[SRC_STRIDE * SEG_NUM + LEN];\n  __nram__ int8_t dst_tmp[DST_STRIDE / sizeof(int8_t) * SEG_NUM + LEN];\n  __memcpy(src_tmp, src, size, GDRAM2NRAM);\n  __bang_half2int8_dn(dst_tmp, src_tmp, LEN, POS, DST_STRIDE, SRC_STRIDE, SEG_NUM);\n  __memcpy(dst, dst_tmp, (DST_STRIDE * SEG_NUM + LEN * sizeof(half)), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.164. __bang_half2int8_oz \n^^^^^^^^^^^^^^^\n void  __bang_half2int8_oz (int8_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position )   \n void  __bang_half2int8_oz (int8_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  half  to  int8\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements according to  <fix\\_position>  in round-off-zero mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src\\_stride>  must be divisible by sizeof(half);\n* (  \\div sizeof(half) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. "
  },
  {
    "content": "\n 3.30.165. __bang_half2int8_rd \n^^^^^^^^^^^^^^^\n void  __bang_half2int8_rd (int8_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position )   \n void  __bang_half2int8_rd (int8_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  half  to  int8\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements according to  <fix\\_position>  in round-nearest-off-zero mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src\\_stride>  must be divisible by sizeof(half);\n* (  \\div sizeof(half) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. "
  },
  {
    "content": "\n 3.30.166. __bang_half2int8_rm \n^^^^^^^^^^^^^^^\n void  __bang_half2int8_rm (int8_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position )   \n void  __bang_half2int8_rm (int8_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  half  to  int8\\_t  element-wisely in round-math mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements according to  <fix\\_position>  in round-math mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src\\_count>  must be greater than zero;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(int8\\_t) , and divisible by sizeof(int8_t) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(half);\n* (  \\div sizeof(half) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise."
  },
  {
    "content": "\n 3.30.167. __bang_half2int8_rn \n^^^^^^^^^^^^^^^\n void  __bang_half2int8_rn (int8_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position )   \n void  __bang_half2int8_rn (int8_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  half  to  int8\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements according to  <fix\\_position>  in round-nearest-even mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src\\_count>  must be greater than zero;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(int8\\_t) , and divisible by sizeof(int8_t) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(half);\n* (  \\div sizeof(half) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise."
  },
  {
    "content": "\n 3.30.168. __bang_half2int8_tz \n^^^^^^^^^^^^^^^\n void  __bang_half2int8_tz (int8_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position )   \n void  __bang_half2int8_tz (int8_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  half  to  int8\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements according to  <fix\\_position>  in round-to-zero mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src\\_stride>  must be divisible by sizeof(half);\n* (  \\div sizeof(half) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. "
  },
  {
    "content": "\n 3.30.169. __bang_half2int8_up \n^^^^^^^^^^^^^^^\n void  __bang_half2int8_up (int8_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position )   \n void  __bang_half2int8_up (int8_t * dst ,  const  half * src , unsigned int  src_count , int  fix_position , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  half  to  int8\\_t  element-wisely in round-up mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements according to  <fix\\_position>  in round-up mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src\\_stride>  must be divisible by sizeof(half);\n* (  \\div sizeof(half) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. "
  },
  {
    "content": "\n 3.30.170. __bang_half2short_dn \n^^^^^^^^^^^^^^^\n void  __bang_half2short_dn (short * dst ,  const  half * src , unsigned int  src_count )   \n void  __bang_half2short_dn (short * dst ,  const  half * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  half  to  short  element-wisely in round-down mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-down mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(short) , and divisible by 64 on  (m)tp\\_2xx , and divisible by sizeof(short) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(half);\n* (  \\div sizeof(half) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SRC_STRIDE 160 \n define DST_STRIDE 320 \n define LEN 128 \n define SEG_NUM 20 \n __mlu_entry__ void kernel(short *dst, half *src, int size) {\n  __nram__ half src_tmp[SRC_STRIDE * SEG_NUM + LEN];\n  __nram__ short dst_tmp[DST_STRIDE / sizeof(short) * SEG_NUM + LEN];\n  __memcpy(src_tmp, src, size * sizeof(half), GDRAM2NRAM);\n  __bang_half2short_dn(dst_tmp, src_tmp, LEN, DST_STRIDE, SRC_STRIDE, SEG_NUM);\n  __memcpy(dst, dst_tmp, (DST_STRIDE * SEG_NUM + LEN * sizeof(short)), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.171. __bang_half2short_oz \n^^^^^^^^^^^^^^^\n void  __bang_half2short_oz (short * dst ,  const  half * src , unsigned int  src_count )   \n void  __bang_half2short_oz (short * dst ,  const  half * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  half  to  short  element-wisely in round-off-zero mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-off-zero mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(short) , and divisible by 64 on  (m)tp\\_2xx , and divisible by sizeof(short) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(half);\n* (  \\div sizeof(half) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. "
  },
  {
    "content": "\n 3.30.172. __bang_half2short_rd \n^^^^^^^^^^^^^^^\n void  __bang_half2short_rd (short * dst ,  const  half * src , unsigned int  src_count )   \n void  __bang_half2short_rd (short * dst ,  const  half * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  half  to  short  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-nearest-off-zero mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(short) , and divisible by 64 on  (m)tp\\_2xx , and divisible by sizeof(short) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(half);\n* (  \\div sizeof(half) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. "
  },
  {
    "content": "\n 3.30.173. __bang_half2short_rm \n^^^^^^^^^^^^^^^\n void  __bang_half2short_rm (short * dst ,  const  half * src , unsigned int  src_count )   \n void  __bang_half2short_rm (short * dst ,  const  half * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  half  to  short  element-wisely in round-math mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-math mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(short) , and divisible by sizeof(short) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(half);\n* (  \\div sizeof(half) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(short *dst, half *src) {\n  __nram__ half src_tmp[SIZE];\n  __nram__ short dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_half2short_rm(dst_tmp, src_tmp, SIZE);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(short), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.174. __bang_half2short_rn \n^^^^^^^^^^^^^^^\n void  __bang_half2short_rn (short * dst ,  const  half * src , unsigned int  src_count )   \n void  __bang_half2short_rn (short * dst ,  const  half * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  half  to  short  element-wisely in round-nearest-even mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-nearest-even mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(short) , and divisible by sizeof(short) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(half);\n* (  \\div sizeof(half) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. "
  },
  {
    "content": "\n 3.30.175. __bang_half2short_tz \n^^^^^^^^^^^^^^^\n void  __bang_half2short_tz (short * dst ,  const  half * src , unsigned int  src_count )   \n void  __bang_half2short_tz (short * dst ,  const  half * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  half  to  short  element-wisely in round-to-zero mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-to-zero mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(short) , and divisible by 64 on  (m)tp\\_2xx , and divisible by sizeof(short) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(half);\n* (  \\div sizeof(half) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. "
  },
  {
    "content": "\n 3.30.176. __bang_half2short_up \n^^^^^^^^^^^^^^^\n void  __bang_half2short_up (short * dst ,  const  half * src , unsigned int  src_count )   \n void  __bang_half2short_up (short * dst ,  const  half * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  half  to  short  element-wisely in round-up mode and saves the result in  <dst> . <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-up mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(short) , and divisible by 64 on  (m)tp\\_2xx , and divisible by sizeof(short) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(half);\n* (  \\div sizeof(half) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. "
  },
  {
    "content": "\n 3.30.177. __bang_half2tf32 \n^^^^^^^^^^^^^^^\n void  __bang_half2tf32 (float * dst ,  const  half * src , unsigned int  count )   \n This function converts type of  <src>  from  half  to  tf32  element-wisely and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, half *src) {\n  __nram__ half src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(half), GDRAM2NRAM);\n  __bang_half2tf32(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.178. __bang_half2uchar_dn \n^^^^^^^^^^^^^^^\n void  __bang_half2uchar_dn (unsigned char * dst ,  const  half * src , unsigned int  src_count )   \n void  __bang_half2uchar_dn (unsigned char * dst ,  const  half * src , half * src_addition , unsigned int  src_count )   \n This function converts type of  <src>  from  half  to  unsigned char  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_addition : The address of additional vector for source.\n*  [in] src\\_count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  ,  <dst>  and  <src\\_addition>  must point to  \\_\\_nram\\_\\_  address space;\n* The size of  <src\\_addition>  vector is identical to the size of  <src>  and  <dst> ;\n* The difference between two version is that the version without  <src\\_addition>  can convert data in the range of  [0,127] , the version with  <src\\_addition>  can convert data in the range of  [0,255] ;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(unsigned char *dst, half *src) {\n  __nram__ half src_tmp[SIZE];\n  __nram__ unsigned char dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_half2uchar_dn(dst_tmp, src_tmp, SIZE);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.179. __bang_half2uchar_oz \n^^^^^^^^^^^^^^^\n void  __bang_half2uchar_oz (unsigned char * dst ,  const  half * src , unsigned int  src_count )   \n This function converts type of  <src>  from  half  to  unsigned char  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(unsigned char *dst, half *src) {\n  __nram__ half src_tmp[SIZE];\n  __nram__ unsigned char dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_half2uchar_oz(dst_tmp, src_tmp, SIZE);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.180. __bang_half2uchar_rd \n^^^^^^^^^^^^^^^\n void  __bang_half2uchar_rd (unsigned char * dst ,  const  half * src , unsigned int  src_count )   \n This function converts type of  <src>  from  half  to  unsigned char  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(unsigned char *dst, half *src) {\n  __nram__ half src_tmp[SIZE];\n  __nram__ unsigned char dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_half2uchar_rd(dst_tmp, src_tmp, SIZE);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.181. __bang_half2uchar_rm \n^^^^^^^^^^^^^^^\n void  __bang_half2uchar_rm (unsigned char * dst ,  const  half * src , unsigned int  src_count )   \n This function converts type of  <src>  from  half  to  unsigned char  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(unsigned char *dst, half *src) {\n  __nram__ half src_tmp[SIZE];\n  __nram__ unsigned char dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_half2uchar_rm(dst_tmp, src_tmp, SIZE);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.182. __bang_half2uchar_rn \n^^^^^^^^^^^^^^^\n void  __bang_half2uchar_rn (unsigned char * dst ,  const  half * src , unsigned int  src_count )   \n This function converts type of  <src>  from  half  to  unsigned char  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(unsigned char *dst, half *src) {\n  __nram__ half src_tmp[SIZE];\n  __nram__ unsigned char dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_half2uchar_rn(dst_tmp, src_tmp, SIZE);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.183. __bang_half2uchar_tz \n^^^^^^^^^^^^^^^\n void  __bang_half2uchar_tz (unsigned char * dst ,  const  half * src , unsigned int  src_count )   \n This function converts type of  <src>  from  half  to  unsigned char  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(unsigned char *dst, half *src) {\n  __nram__ half src_tmp[SIZE];\n  __nram__ unsigned char dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_half2uchar_tz(dst_tmp, src_tmp, SIZE);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.184. __bang_half2uchar_up \n^^^^^^^^^^^^^^^\n void  __bang_half2uchar_up (unsigned char * dst ,  const  half * src , unsigned int  src_count )   \n This function converts type of  <src>  from  half  to  unsigned char  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(unsigned char *dst, half *src) {\n  __nram__ half src_tmp[SIZE];\n  __nram__ unsigned char dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);\n  __bang_half2uchar_up(dst_tmp, src_tmp, SIZE);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.185. __bang_int162bfloat16 \n^^^^^^^^^^^^^^^\n void  __bang_int162bfloat16 (bfloat16_t * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  bfloat16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162bfloat16(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.186. __bang_int162bfloat16_dn \n^^^^^^^^^^^^^^^\n void  __bang_int162bfloat16_dn (bfloat16_t * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  bfloat16\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162bfloat16_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.187. __bang_int162bfloat16_oz \n^^^^^^^^^^^^^^^\n void  __bang_int162bfloat16_oz (bfloat16_t * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  bfloat16\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162bfloat16_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.188. __bang_int162bfloat16_rd \n^^^^^^^^^^^^^^^\n void  __bang_int162bfloat16_rd (bfloat16_t * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  bfloat16\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162bfloat16_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.189. __bang_int162bfloat16_rm \n^^^^^^^^^^^^^^^\n void  __bang_int162bfloat16_rm (bfloat16_t * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  bfloat16\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162bfloat16_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.190. __bang_int162bfloat16_rn \n^^^^^^^^^^^^^^^\n void  __bang_int162bfloat16_rn (bfloat16_t * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  bfloat16\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162bfloat16_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.191. __bang_int162bfloat16_tz \n^^^^^^^^^^^^^^^\n void  __bang_int162bfloat16_tz (bfloat16_t * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  bfloat16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162bfloat16_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.192. __bang_int162bfloat16_up \n^^^^^^^^^^^^^^^\n void  __bang_int162bfloat16_up (bfloat16_t * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  bfloat16\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162bfloat16_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.193. __bang_int162float \n^^^^^^^^^^^^^^^\n void  __bang_int162float (float * dst ,  const  int16_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  float  element-wisely in round-to-zero mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  cannot be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(float *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_int162float(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.194. __bang_int162half \n^^^^^^^^^^^^^^^\n void  __bang_int162half (half * dst ,  const  int16_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  half  element-wisely in round-to-zero mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <src\\_count>  must be divisible by 64 on  (m)tp\\_2xx ;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(half *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ half dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162half(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.195. __bang_int162half_dn \n^^^^^^^^^^^^^^^\n void  __bang_int162half_dn (half * dst ,  const  int16_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  half  element-wisely in round-down mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <src\\_count>  must be divisible by 64 on  (m)tp\\_2xx ;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(half *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ half dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162half_dn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.196. __bang_int162half_oz \n^^^^^^^^^^^^^^^\n void  __bang_int162half_oz (half * dst ,  const  int16_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  half  element-wisely in round-off-zero mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <src\\_count>  must be divisible by 64 on  (m)tp\\_2xx ;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(half *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ half dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162half_oz(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.197. __bang_int162half_rd \n^^^^^^^^^^^^^^^\n void  __bang_int162half_rd (half * dst ,  const  int16_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  half  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <src\\_count>  must be divisible by 64 on  (m)tp\\_2xx ;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(half *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ half dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162half_rd(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.198. __bang_int162half_rm \n^^^^^^^^^^^^^^^\n void  __bang_int162half_rm (half * dst ,  const  int16_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  half  element-wisely in round-math mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(half *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ half dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162half_rm(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.199. __bang_int162half_rn \n^^^^^^^^^^^^^^^\n void  __bang_int162half_rn (half * dst ,  const  int16_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  half  element-wisely in round-nearest-even mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(half *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ half dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162half_rn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.200. __bang_int162half_tz \n^^^^^^^^^^^^^^^\n void  __bang_int162half_tz (half * dst ,  const  int16_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  half  element-wisely in round-to-zero mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <src\\_count>  must be divisible by 64 on  (m)tp\\_2xx ;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(half *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ half dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162half_tz(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.201. __bang_int162half_up \n^^^^^^^^^^^^^^^\n void  __bang_int162half_up (half * dst ,  const  int16_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  half  element-wisely in round-up mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <src\\_count>  must be divisible by 64 on  (m)tp\\_2xx ;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(half *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ half dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162half_up(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.202. __bang_int162int32 \n^^^^^^^^^^^^^^^\n void  __bang_int162int32 (int32_t * dst ,  const  int16_t * src , unsigned int  src_count , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int16\\_t  to  int32\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] ;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define DST_POS 3 \n define SRC_POS 5 \n __mlu_entry__ void kernel(int32_t *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162int32(dst_tmp, src_tmp, SIZE, DST_POS, SRC_POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.203. __bang_int162int4_dn \n^^^^^^^^^^^^^^^\n void  __bang_int162int4_dn (int4x2_t * dst ,  const  int16_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int16\\_t  to  int4  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162int4_dn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.204. __bang_int162int4_oz \n^^^^^^^^^^^^^^^\n void  __bang_int162int4_oz (int4x2_t * dst ,  const  int16_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int16\\_t  to  int4  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int16_t *src) {\n  __nram__ int16_tt src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162int4_oz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.205. __bang_int162int4_rd \n^^^^^^^^^^^^^^^\n void  __bang_int162int4_rd (int4x2_t * dst ,  const  int16_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int16\\_t  to  int4  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162int4_rd(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.206. __bang_int162int4_rm \n^^^^^^^^^^^^^^^\n void  __bang_int162int4_rm (int4x2_t * dst ,  const  int16_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int16\\_t  to  int4  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162int4_rm(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.207. __bang_int162int4_rn \n^^^^^^^^^^^^^^^\n void  __bang_int162int4_rn (int4x2_t * dst ,  const  int16_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int16\\_t  to  int4  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162int4_rn(dst_tmp, src_tmp, SIZE);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.208. __bang_int162int4_tz \n^^^^^^^^^^^^^^^\n void  __bang_int162int4_tz (int4x2_t * dst ,  const  int16_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int16\\_t  to  int4  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162int4_tz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.209. __bang_int162int4_up \n^^^^^^^^^^^^^^^\n void  __bang_int162int4_up (int4x2_t * dst ,  const  int16_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int16\\_t  to  int4  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162int4_up(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.210. __bang_int162int8 \n^^^^^^^^^^^^^^^\n void  __bang_int162int8 (int8_t * dst ,  const  int16_t * src , unsigned int  src_count , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int16\\_t  to  int8\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define DST_POS 3 \n define SRC_POS 5 \n __mlu_entry__ void kernel(int8_t *dst, int16_t *src) {\n  __nram__ int16_t src_tmp[SIZE];\n  __nram__ int8_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162int8(dst_tmp, src_tmp, SIZE, DST_POS, SRC_POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.211. __bang_int162tf32 \n^^^^^^^^^^^^^^^\n void  __bang_int162tf32 (float * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  tf32  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162tf32(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.212. __bang_int162tf32_dn \n^^^^^^^^^^^^^^^\n void  __bang_int162tf32_dn (float * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  tf32  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162tf32_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.213. __bang_int162tf32_oz \n^^^^^^^^^^^^^^^\n void  __bang_int162tf32_oz (float * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  tf32  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162tf32_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.214. __bang_int162tf32_rd \n^^^^^^^^^^^^^^^\n void  __bang_int162tf32_rd (float * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  tf32  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162tf32_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.215. __bang_int162tf32_rm \n^^^^^^^^^^^^^^^\n void  __bang_int162tf32_rm (float * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  tf32  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162tf32_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.216. __bang_int162tf32_rn \n^^^^^^^^^^^^^^^\n void  __bang_int162tf32_rn (float * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  tf32  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162tf32_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.217. __bang_int162tf32_tz \n^^^^^^^^^^^^^^^\n void  __bang_int162tf32_tz (float * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  tf32  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162tf32_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.218. __bang_int162tf32_up \n^^^^^^^^^^^^^^^\n void  __bang_int162tf32_up (float * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  tf32  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162tf32_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.219. __bang_int162uchar \n^^^^^^^^^^^^^^^\n void  __bang_int162uchar (unsigned char * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  unsigned char  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162uchar(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.220. __bang_int162uchar_dn \n^^^^^^^^^^^^^^^\n void  __bang_int162uchar_dn (unsigned char * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  unsigned char  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162uchar_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.221. __bang_int162uchar_oz \n^^^^^^^^^^^^^^^\n void  __bang_int162uchar_oz (unsigned char * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  unsigned char  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162uchar_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.222. __bang_int162uchar_rd \n^^^^^^^^^^^^^^^\n void  __bang_int162uchar_rd (unsigned char * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  unsigned char  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162uchar_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.223. __bang_int162uchar_rm \n^^^^^^^^^^^^^^^\n void  __bang_int162uchar_rm (unsigned char * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  unsigned char  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162uchar_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.224. __bang_int162uchar_rn \n^^^^^^^^^^^^^^^\n void  __bang_int162uchar_rn (unsigned char * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  unsigned char  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162uchar_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.225. __bang_int162uchar_tz \n^^^^^^^^^^^^^^^\n void  __bang_int162uchar_tz (unsigned char * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  unsigned char  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162uchar_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.226. __bang_int162uchar_up \n^^^^^^^^^^^^^^^\n void  __bang_int162uchar_up (unsigned char * dst ,  const  int16_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int16\\_t  to  unsigned char  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int16_t *src) {\n  __nram__ int16_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int162uchar_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.227. __bang_int322bfloat16 \n^^^^^^^^^^^^^^^\n void  __bang_int322bfloat16 (bfloat16_t * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  bfloat16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322bfloat16(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.228. __bang_int322bfloat16_dn \n^^^^^^^^^^^^^^^\n void  __bang_int322bfloat16_dn (bfloat16_t * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  bfloat16\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322bfloat16_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.229. __bang_int322bfloat16_oz \n^^^^^^^^^^^^^^^\n void  __bang_int322bfloat16_oz (bfloat16_t * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  bfloat16\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322bfloat16_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.230. __bang_int322bfloat16_rd \n^^^^^^^^^^^^^^^\n void  __bang_int322bfloat16_rd (bfloat16_t * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  bfloat16\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322bfloat16_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.231. __bang_int322bfloat16_rm \n^^^^^^^^^^^^^^^\n void  __bang_int322bfloat16_rm (bfloat16_t * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  bfloat16\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322bfloat16_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.232. __bang_int322bfloat16_rn \n^^^^^^^^^^^^^^^\n void  __bang_int322bfloat16_rn (bfloat16_t * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  bfloat16\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322bfloat16_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.233. __bang_int322bfloat16_tz \n^^^^^^^^^^^^^^^\n void  __bang_int322bfloat16_tz (bfloat16_t * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  bfloat16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int16_t), GDRAM2NRAM);\n  __bang_int322bfloat16_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.234. __bang_int322bfloat16_up \n^^^^^^^^^^^^^^^\n void  __bang_int322bfloat16_up (bfloat16_t * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  bfloat16\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322bfloat16_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.235. __bang_int322float \n^^^^^^^^^^^^^^^\n void  __bang_int322float (float * dst ,  const  int32_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  float  element-wisely in round-to-zero mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(float *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322float(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.236. __bang_int322float_dn \n^^^^^^^^^^^^^^^\n void  __bang_int322float_dn (float * dst ,  const  int32_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  float  element-wisely in round-down mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(float *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322float_dn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.237. __bang_int322float_oz \n^^^^^^^^^^^^^^^\n void  __bang_int322float_oz (float * dst ,  const  int32_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  float  element-wisely in round-off-zero mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(float *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322float_oz(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.238. __bang_int322float_rd \n^^^^^^^^^^^^^^^\n void  __bang_int322float_rd (float * dst ,  const  int32_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  float  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(float *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322float_rd(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.239. __bang_int322float_rm \n^^^^^^^^^^^^^^^\n void  __bang_int322float_rm (float * dst ,  const  int32_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  float  element-wisely in round-math mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(float *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322float_rm(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.240. __bang_int322float_rn \n^^^^^^^^^^^^^^^\n void  __bang_int322float_rn (float * dst ,  const  int32_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  float  element-wisely in round-nearest-even mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(float *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322float_rn(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.241. __bang_int322float_tz \n^^^^^^^^^^^^^^^\n void  __bang_int322float_tz (float * dst ,  const  int32_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  float  element-wisely in round-to-zero mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(float *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322float_tz(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.242. __bang_int322float_up \n^^^^^^^^^^^^^^^\n void  __bang_int322float_up (float * dst ,  const  int32_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  float  element-wisely in round-up mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(float *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322float_up(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.243. __bang_int322half \n^^^^^^^^^^^^^^^\n void  __bang_int322half (half * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  half  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(half *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ half dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322half(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.244. __bang_int322half_dn \n^^^^^^^^^^^^^^^\n void  __bang_int322half_dn (half * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  half  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(half *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ half dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322half_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.245. __bang_int322half_oz \n^^^^^^^^^^^^^^^\n void  __bang_int322half_oz (half * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  half  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(half *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ half dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322half_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.246. __bang_int322half_rd \n^^^^^^^^^^^^^^^\n void  __bang_int322half_rd (half * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  half  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(half *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ half dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322half_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.247. __bang_int322half_rm \n^^^^^^^^^^^^^^^\n void  __bang_int322half_rm (half * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  half  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(half *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ half dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322half_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.248. __bang_int322half_rn \n^^^^^^^^^^^^^^^\n void  __bang_int322half_rn (half * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  half  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(half *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ half dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322half_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.249. __bang_int322half_tz \n^^^^^^^^^^^^^^^\n void  __bang_int322half_tz (half * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  half  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(half *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ half dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322half_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.250. __bang_int322half_up \n^^^^^^^^^^^^^^^\n void  __bang_int322half_up (half * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  half  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(half *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ half dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322half_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.251. __bang_int322int16 \n^^^^^^^^^^^^^^^\n void  __bang_int322int16 (int16_t * dst ,  const  int32_t * src , unsigned int  src_count , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int32\\_t  to  int16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define DST_POS 3 \n define SRC_POS 5 \n __mlu_entry__ void kernel(int16_t *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ int16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322int16(dst_tmp, src_tmp, SIZE, DST_POS, SRC_POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.252. __bang_int322int4_dn \n^^^^^^^^^^^^^^^\n void  __bang_int322int4_dn (int4x2_t * dst ,  const  int32_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int32\\_t  to  int4  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322int4_dn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.253. __bang_int322int4_oz \n^^^^^^^^^^^^^^^\n void  __bang_int322int4_oz (int4x2_t * dst ,  const  int32_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int32\\_t  to  int4  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322int4_oz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.254. __bang_int322int4_rd \n^^^^^^^^^^^^^^^\n void  __bang_int322int4_rd (int4x2_t * dst ,  const  int32_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int32\\_t  to  int4  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322int4_rd(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.255. __bang_int322int4_rm \n^^^^^^^^^^^^^^^\n void  __bang_int322int4_rm (int4x2_t * dst ,  const  int32_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int32\\_t  to  int4  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322int4_rm(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.256. __bang_int322int4_rn \n^^^^^^^^^^^^^^^\n void  __bang_int322int4_rn (int4x2_t * dst ,  const  int32_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int32\\_t  to  int4  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322int4_rn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.257. __bang_int322int4_tz \n^^^^^^^^^^^^^^^\n void  __bang_int322int4_tz (int4x2_t * dst ,  const  int32_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int32\\_t  to  int4  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322int4_tz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.258. __bang_int322int4_up \n^^^^^^^^^^^^^^^\n void  __bang_int322int4_up (int4x2_t * dst ,  const  int32_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int32\\_t  to  int4  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322int4_up(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.259. __bang_int322int8 \n^^^^^^^^^^^^^^^\n void  __bang_int322int8 (int8_t * dst ,  const  int32_t * src , unsigned int  src_count , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int32\\_t  to  int8\\_t  element-wisely round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] ;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define DST_POS 3 \n define SRC_POS 5 \n __mlu_entry__ void kernel(int8_t *dst, int32_t *src) {\n  __nram__ int32_t src_tmp[SIZE];\n  __nram__ int8_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322int8(dst_tmp, src_tmp, SIZE, DST_POS, SRC_POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.260. __bang_int322tf32 \n^^^^^^^^^^^^^^^\n void  __bang_int322tf32 (float * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  tf32  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322tf32(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.261. __bang_int322tf32_dn \n^^^^^^^^^^^^^^^\n void  __bang_int322tf32_dn (float * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  tf32  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322tf32_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.262. __bang_int322tf32_oz \n^^^^^^^^^^^^^^^\n void  __bang_int322tf32_oz (float * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  tf32  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322tf32_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.263. __bang_int322tf32_rd \n^^^^^^^^^^^^^^^\n void  __bang_int322tf32_rd (float * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  tf32  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322tf32_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.264. __bang_int322tf32_rm \n^^^^^^^^^^^^^^^\n void  __bang_int322tf32_rm (float * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  tf32  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322tf32_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.265. __bang_int322tf32_rn \n^^^^^^^^^^^^^^^\n void  __bang_int322tf32_rn (float * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  tf32  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322tf32_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.266. __bang_int322tf32_tz \n^^^^^^^^^^^^^^^\n void  __bang_int322tf32_tz (float * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  tf32  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322tf32_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.267. __bang_int322tf32_up \n^^^^^^^^^^^^^^^\n void  __bang_int322tf32_up (float * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  tf32  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322tf32_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.268. __bang_int322uchar \n^^^^^^^^^^^^^^^\n void  __bang_int322uchar (unsigned char * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  unsigned char  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322uchar(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.269. __bang_int322uchar_dn \n^^^^^^^^^^^^^^^\n void  __bang_int322uchar_dn (unsigned char * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  unsigned char  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322uchar_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.270. __bang_int322uchar_oz \n^^^^^^^^^^^^^^^\n void  __bang_int322uchar_oz (unsigned char * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  unsigned char  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322uchar_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.271. __bang_int322uchar_rd \n^^^^^^^^^^^^^^^\n void  __bang_int322uchar_rd (unsigned char * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  unsigned char  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322uchar_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.272. __bang_int322uchar_rm \n^^^^^^^^^^^^^^^\n void  __bang_int322uchar_rm (unsigned char * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  unsigned char  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322uchar_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.273. __bang_int322uchar_rn \n^^^^^^^^^^^^^^^\n void  __bang_int322uchar_rn (unsigned char * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  unsigned char  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322uchar_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.274. __bang_int322uchar_tz \n^^^^^^^^^^^^^^^\n void  __bang_int322uchar_tz (unsigned char * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  unsigned char  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322uchar_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.275. __bang_int322uchar_up \n^^^^^^^^^^^^^^^\n void  __bang_int322uchar_up (unsigned char * dst ,  const  int32_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int32\\_t  to  unsigned char  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int32_t *src) {\n  __nram__ int32_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int32_t), GDRAM2NRAM);\n  __bang_int322uchar_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.276. __bang_int42bfloat16_dn \n^^^^^^^^^^^^^^^\n void  __bang_int42bfloat16_dn (bfloat16_t * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  bfloat16\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ bfloat16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42bfloat16_dn(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.277. __bang_int42bfloat16_oz \n^^^^^^^^^^^^^^^\n void  __bang_int42bfloat16_oz (bfloat16_t * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  bfloat16\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ bfloat16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42bfloat16_oz(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.278. __bang_int42bfloat16_rd \n^^^^^^^^^^^^^^^\n void  __bang_int42bfloat16_rd (bfloat16_t * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  bfloat16\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ bfloat16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42bfloat16_rd(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.279. __bang_int42bfloat16_rm \n^^^^^^^^^^^^^^^\n void  __bang_int42bfloat16_rm (bfloat16_t * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  bfloat16\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ bfloat16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42bfloat16_rm(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.280. __bang_int42bfloat16_rn \n^^^^^^^^^^^^^^^\n void  __bang_int42bfloat16_rn (bfloat16_t * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  bfloat16\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ bfloat16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42bfloat16_rn(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.281. __bang_int42bfloat16_tz \n^^^^^^^^^^^^^^^\n void  __bang_int42bfloat16_tz (bfloat16_t * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  bfloat16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ bfloat16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42bfloat16_tz(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.282. __bang_int42bfloat16_up \n^^^^^^^^^^^^^^^\n void  __bang_int42bfloat16_up (bfloat16_t * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  bfloat16\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ bfloat16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42bfloat16_up(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.283. __bang_int42float_dn \n^^^^^^^^^^^^^^^\n void  __bang_int42float_dn (float * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  float  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(float *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42float_dn(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.284. __bang_int42float_oz \n^^^^^^^^^^^^^^^\n void  __bang_int42float_oz (float * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  float  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(float *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42float_oz(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.285. __bang_int42float_rd \n^^^^^^^^^^^^^^^\n void  __bang_int42float_rd (float * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  float  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(float *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42float_rd(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.286. __bang_int42float_rm \n^^^^^^^^^^^^^^^\n void  __bang_int42float_rm (float * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  float  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(float *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42float_rm(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.287. __bang_int42float_rn \n^^^^^^^^^^^^^^^\n void  __bang_int42float_rn (float * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  float  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(float *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42float_rn(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.288. __bang_int42float_tz \n^^^^^^^^^^^^^^^\n void  __bang_int42float_tz (float * dst , int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  float  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(float *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42float_tz(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.289. __bang_int42float_up \n^^^^^^^^^^^^^^^\n void  __bang_int42float_up (float * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  float  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(float *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42float_up(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.290. __bang_int42half_dn \n^^^^^^^^^^^^^^^\n void  __bang_int42half_dn (half * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  half  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(half *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ half dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42half_dn(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.291. __bang_int42half_oz \n^^^^^^^^^^^^^^^\n void  __bang_int42half_oz (half * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  half  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(half *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ half dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42half_oz(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.292. __bang_int42half_rd \n^^^^^^^^^^^^^^^\n void  __bang_int42half_rd (half * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  half  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(half *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ half dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42half_rd(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.293. __bang_int42half_rm \n^^^^^^^^^^^^^^^\n void  __bang_int42half_rm (half * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  half  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(half *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ half dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42half_rm(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.294. __bang_int42half_rn \n^^^^^^^^^^^^^^^\n void  __bang_int42half_rn (half * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  half  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(half *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ half dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42half_rn(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.295. __bang_int42half_tz \n^^^^^^^^^^^^^^^\n void  __bang_int42half_tz (half * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  half  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(half *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ half dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42half_tz(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.296. __bang_int42half_up \n^^^^^^^^^^^^^^^\n void  __bang_int42half_up (half * dst ,  const  int4x2_t * src , unsigned int  size , int  src_position )   \n This function converts type of  <src>  from  int4  to  half  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(half *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ half dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42half_up(dst_tmp, src_tmp, SIZE, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.297. __bang_int42int16_dn \n^^^^^^^^^^^^^^^\n void  __bang_int42int16_dn (int16_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int16\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int16_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int16_dn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.298. __bang_int42int16_oz \n^^^^^^^^^^^^^^^\n void  __bang_int42int16_oz (int16_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int16\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int16_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int16_oz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.299. __bang_int42int16_rd \n^^^^^^^^^^^^^^^\n void  __bang_int42int16_rd (int16_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int16\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int16_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int16_rd(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.300. __bang_int42int16_rm \n^^^^^^^^^^^^^^^\n void  __bang_int42int16_rm (int16_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int16\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int16_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int16_rm(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.301. __bang_int42int16_rn \n^^^^^^^^^^^^^^^\n void  __bang_int42int16_rn (int16_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int16\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int16_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int16_rn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.302. __bang_int42int16_tz \n^^^^^^^^^^^^^^^\n void  __bang_int42int16_tz (int16_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int16_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int16_tz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.303. __bang_int42int16_up \n^^^^^^^^^^^^^^^\n void  __bang_int42int16_up (int16_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int16\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int16_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int16_up(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.304. __bang_int42int32_dn \n^^^^^^^^^^^^^^^\n void  __bang_int42int32_dn (int32_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int32\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int32_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int32_dn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.305. __bang_int42int32_oz \n^^^^^^^^^^^^^^^\n void  __bang_int42int32_oz (int32_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int32\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int32_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int32_oz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.306. __bang_int42int32_rd \n^^^^^^^^^^^^^^^\n void  __bang_int42int32_rd (int32_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int32\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] ;\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int32_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int32_rd(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.307. __bang_int42int32_rm \n^^^^^^^^^^^^^^^\n void  __bang_int42int32_rm (int32_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int32\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int32_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int32_rm(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.308. __bang_int42int32_rn \n^^^^^^^^^^^^^^^\n void  __bang_int42int32_rn (int32_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int32\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int32_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int32_rn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.309. __bang_int42int32_tz \n^^^^^^^^^^^^^^^\n void  __bang_int42int32_tz (int32_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int32\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int32_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int32_tz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.310. __bang_int42int32_up \n^^^^^^^^^^^^^^^\n void  __bang_int42int32_up (int32_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int32\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int32_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int32_up(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.311. __bang_int42int8_dn \n^^^^^^^^^^^^^^^\n void  __bang_int42int8_dn (int8_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int8\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int8_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int8_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int8_oz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.312. __bang_int42int8_oz \n^^^^^^^^^^^^^^^\n void  __bang_int42int8_oz (int8_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int8\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int8_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int8_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int8_oz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.313. __bang_int42int8_rd \n^^^^^^^^^^^^^^^\n void  __bang_int42int8_rd (int8_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int8\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int8_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int8_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int8_rd(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.314. __bang_int42int8_rm \n^^^^^^^^^^^^^^^\n void  __bang_int42int8_rm (int8_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int8\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int8_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int8_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int8_rm(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.315. __bang_int42int8_rn \n^^^^^^^^^^^^^^^\n void  __bang_int42int8_rn (int8_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int8\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int8_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int8_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int8_rm(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.316. __bang_int42int8_tz \n^^^^^^^^^^^^^^^\n void  __bang_int42int8_tz (int8_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int8\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int8_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int8_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int8_tz(dst_tmp, src_tmp, SIZE, DSRPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.317. __bang_int42int8_up \n^^^^^^^^^^^^^^^\n void  __bang_int42int8_up (int8_t * dst ,  const  int4x2_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int4  to  int8\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int8_t *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_tmp[SIZE/2];\n  __nram__ int8_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);\n  __bang_int42int8_oz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.318. __bang_int42tf32 \n^^^^^^^^^^^^^^^\n void  __bang_int42tf32 (float * dst ,  const  int4x2_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int4x2\\_t  to  tf32  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int4x2_t), GDRAM2NRAM);\n  __bang_int42tf32(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.319. __bang_int42tf32_dn \n^^^^^^^^^^^^^^^\n void  __bang_int42tf32_dn (float * dst ,  const  int4x2_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int4x2\\_t  to  tf32  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int4x2_t), GDRAM2NRAM);\n  __bang_int42tf32_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.320. __bang_int42tf32_oz \n^^^^^^^^^^^^^^^\n void  __bang_int42tf32_oz (float * dst ,  const  int4x2_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int4x2\\_t  to  tf32  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int4x2_t), GDRAM2NRAM);\n  __bang_int42tf32_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.321. __bang_int42tf32_rd \n^^^^^^^^^^^^^^^\n void  __bang_int42tf32_rd (float * dst ,  const  int4x2_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int4x2\\_t  to  tf32  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int4x2_t), GDRAM2NRAM);\n  __bang_int42tf32_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.322. __bang_int42tf32_rm \n^^^^^^^^^^^^^^^\n void  __bang_int42tf32_rm (float * dst ,  const  int4x2_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int4x2\\_t  to  tf32  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int4x2_t), GDRAM2NRAM);\n  __bang_int42tf32_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.323. __bang_int42tf32_rn \n^^^^^^^^^^^^^^^\n void  __bang_int42tf32_rn (float * dst ,  const  int4x2_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int4x2\\_t  to  tf32  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, char *src) {\n  __nram__ int4x2_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int4x2_t), GDRAM2NRAM);\n  __bang_int42tf32_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.324. __bang_int42tf32_tz \n^^^^^^^^^^^^^^^\n void  __bang_int42tf32_tz (float * dst ,  const  int4x2_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int4x2\\_t  to  tf32  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int4x2_t), GDRAM2NRAM);\n  __bang_int42tf32_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.325. __bang_int42tf32_up \n^^^^^^^^^^^^^^^\n void  __bang_int42tf32_up (float * dst ,  const  int4x2_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int4x2\\_t  to  tf32  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int4x2_t), GDRAM2NRAM);\n  __bang_int42tf32_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.326. __bang_int42uchar \n^^^^^^^^^^^^^^^\n void  __bang_int42uchar (unsigned char * dst ,  const  int4x2_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int4x2\\_t  to  unsigned char  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int4x2_t), GDRAM2NRAM);\n  __bang_int42uchar(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.327. __bang_int42uchar_dn \n^^^^^^^^^^^^^^^\n void  __bang_int42uchar_dn (unsigned char * dst ,  const  int4x2_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int4x2\\_t  to  unsigned char  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int4x2_t), GDRAM2NRAM);\n  __bang_int42uchar_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.328. __bang_int42uchar_oz \n^^^^^^^^^^^^^^^\n void  __bang_int42uchar_oz (unsigned char * dst ,  const  int4x2_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int4x2\\_t  to  unsigned char  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int4x2_t), GDRAM2NRAM);\n  __bang_int42uchar_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.329. __bang_int42uchar_rd \n^^^^^^^^^^^^^^^\n void  __bang_int42uchar_rd (unsigned char * dst ,  const  int4x2_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int4x2\\_t  to  unsigned char  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int4x2_t), GDRAM2NRAM);\n  __bang_int42uchar_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.330. __bang_int42uchar_rm \n^^^^^^^^^^^^^^^\n void  __bang_int42uchar_rm (unsigned char * dst ,  const  int4x2_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int4x2\\_t  to  unsigned char  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int4x2_t), GDRAM2NRAM);\n  __bang_int42uchar_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.331. __bang_int42uchar_rn \n^^^^^^^^^^^^^^^\n void  __bang_int42uchar_rn (unsigned char * dst ,  const  int4x2_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int4x2\\_t  to  unsigned char  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int4x2_t), GDRAM2NRAM);\n  __bang_int42uchar_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.332. __bang_int42uchar_tz \n^^^^^^^^^^^^^^^\n void  __bang_int42uchar_tz (unsigned char * dst ,  const  int4x2_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int4x2\\_t  to  unsigned char  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int4x2_t), GDRAM2NRAM);\n  __bang_int42uchar_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.333. __bang_int42uchar_up \n^^^^^^^^^^^^^^^\n void  __bang_int42uchar_up (unsigned char * dst ,  const  int4x2_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int4x2\\_t  to  unsigned char  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int4x2_t *src) {\n  __nram__ int4x2_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int4x2_t), GDRAM2NRAM);\n  __bang_int42uchar_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.334. __bang_int82bfloat16 \n^^^^^^^^^^^^^^^\n void  __bang_int82bfloat16 (bfloat16_t * dst ,  const  int8_t * src , int  fix_position , unsigned int  count )   \n This function converts type of  <src>  from  int8\\_t  to  bfloat16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int8_t *src) {\n  __nram__ int8 src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82bfloat16(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.335. __bang_int82bfloat16_dn \n^^^^^^^^^^^^^^^\n void  __bang_int82bfloat16_dn (bfloat16_t * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  bfloat16\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82bfloat16_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.336. __bang_int82bfloat16_oz \n^^^^^^^^^^^^^^^\n void  __bang_int82bfloat16_oz (bfloat16_t * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  bfloat16\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82bfloat16_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.337. __bang_int82bfloat16_rd \n^^^^^^^^^^^^^^^\n void  __bang_int82bfloat16_rd (bfloat16_t * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  bfloat16\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82bfloat16_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.338. __bang_int82bfloat16_rm \n^^^^^^^^^^^^^^^\n void  __bang_int82bfloat16_rm (bfloat16_t * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  bfloat16\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82bfloat16_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.339. __bang_int82bfloat16_rn \n^^^^^^^^^^^^^^^\n void  __bang_int82bfloat16_rn (bfloat16_t * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  bfloat16\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82bfloat16_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.340. __bang_int82bfloat16_tz \n^^^^^^^^^^^^^^^\n void  __bang_int82bfloat16_tz (bfloat16_t * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  bfloat16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82bfloat16_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.341. __bang_int82bfloat16_up \n^^^^^^^^^^^^^^^\n void  __bang_int82bfloat16_up (bfloat16_t * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  bfloat16\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82bfloat16_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.342. __bang_int82float \n^^^^^^^^^^^^^^^\n void  __bang_int82float (float * dst ,  const  int8_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  float  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The elements number of conversion.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  cannot be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(float *dst, int8_t *src) {\n  __nram__ int8_t src_tmp[SIZE];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82float(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.343. __bang_int82half \n^^^^^^^^^^^^^^^\n void  __bang_int82half (half * dst ,  const  int8_t * src , unsigned int  src_count , int  fix_position )   \n void  __bang_int82half (half * dst ,  const  int8_t * src , unsigned int  src_count , int  fix_position , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  int8\\_t  to  half  element-wisely in round-to-zero mode and saves the result in  <dst> .  <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements according to  <fix\\_position>  in round-to-zero mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }).\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(half) , and divisible by 64 on  (m)tp\\_2xx , and divisible by sizeof(half) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(int8_t);\n* (  \\div  sizeof(int8\\_t)  \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  cannot be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SRC_STRIDE 160 \n define DST_STRIDE 320 \n define LEN 128 \n define SEG_NUM 20 \n define POS 5 \n __mlu_entry__ void kernel(half *dst, int8_t *src, int size) {\n  __nram__ int8_t src_tmp[SRC_STRIDE * SEG_NUM + LEN];\n  __nram__ half dst_tmp[DST_STRIDE / sizeof(half) * SEG_NUM + LEN];\n  __memcpy(src_tmp, src, size, GDRAM2NRAM);\n  __bang_int82half(dst_tmp, src_tmp, LEN, POS, DST_STRIDE, SRC_STRIDE, SEG_NUM);\n  __memcpy(dst, dst_tmp, (DST_STRIDE * SEG_NUM + LEN * sizeof(half)), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.344. __bang_int82int16 \n^^^^^^^^^^^^^^^\n void  __bang_int82int16 (int16_t * dst ,  const  int8_t * src , unsigned int  src_count , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int8\\_t  to  int16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] ;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define DST_POS 3 \n define SRC_POS 5 \n __mlu_entry__ void kernel(int16_t *dst, int8_t *src) {\n  __nram__ int8_t src_tmp[SIZE];\n  __nram__ int16_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82int16(dst_tmp, src_tmp, SIZE, DST_POS, SRC_POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.345. __bang_int82int32 \n^^^^^^^^^^^^^^^\n void  __bang_int82int32 (int32_t * dst ,  const  int8_t * src , unsigned int  src_count , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int8\\_t  to  int32\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] ;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <src\\_count>  must be greater than zero. \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SIZE 128 \n define DST_POS 3 \n define SRC_POS 5 \n __mlu_entry__ void kernel(int32_t *dst, int8_t *src) {\n  __nram__ int8_t src_tmp[SIZE];\n  __nram__ int32_t dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82int32(dst_tmp, src_tmp, SIZE, DST_POS, SRC_POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.346. __bang_int82int4_dn \n^^^^^^^^^^^^^^^\n void  __bang_int82int4_dn (int4x2_t * dst ,  const  int8_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int8\\_t  to  int4  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int8_t *src) {\n  __nram__ int8_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82int4_dn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.347. __bang_int82int4_oz \n^^^^^^^^^^^^^^^\n void  __bang_int82int4_oz (int4x2_t * dst ,  const  int8_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int8\\_t  to  int4  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int8_t *src) {\n  __nram__ int8_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82int4_oz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.348. __bang_int82int4_rd \n^^^^^^^^^^^^^^^\n void  __bang_int82int4_rd (int4x2_t * dst ,  const  int8_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int8\\_t  to  int4  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int8_t *src) {\n  __nram__ int8_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82int4_rd(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.349. __bang_int82int4_rm \n^^^^^^^^^^^^^^^\n void  __bang_int82int4_rm (int4x2_t * dst ,  const  int8_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int8\\_t  to  int4  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int8_t *src) {\n  __nram__ int8_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82int4_rm(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.350. __bang_int82int4_rn \n^^^^^^^^^^^^^^^\n void  __bang_int82int4_rn (int4x2_t * dst ,  const  int8_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int8\\_t  to  int4  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int8_t *src) {\n  __nram__ int8_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82int4_rn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.351. __bang_int82int4_tz \n^^^^^^^^^^^^^^^\n void  __bang_int82int4_tz (int4x2_t * dst ,  const  int8_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int8\\_t  to  int4  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int8_t *src) {\n  __nram__ int8_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82int4_tz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.352. __bang_int82int4_up \n^^^^^^^^^^^^^^^\n void  __bang_int82int4_up (int4x2_t * dst ,  const  int8_t * src , unsigned int  size , int  dst_position , int  src_position )   \n This function converts type of  <src>  from  int8\\_t  to  int4  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] size : The elements number of conversion.\n*  [in] dst\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }).\n*  [in] src\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <size>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <src\\_position>  and  <dst\\_position>  must be in the range  [-127,127] .\n ^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n __mlu_entry__ void kernel(int4x2_t *dst, int8_t *src) {\n  __nram__ int8_t src_tmp[SIZE];\n  __nram__ int4x2_t dst_tmp[SIZE/2];\n  __memcpy(src_tmp, src, SIZE * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82int4_up(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.353. __bang_int82tf32 \n^^^^^^^^^^^^^^^\n void  __bang_int82tf32 (float * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  tf32  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82tf32(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.354. __bang_int82tf32_dn \n^^^^^^^^^^^^^^^\n void  __bang_int82tf32_dn (float * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  tf32  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82tf32_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.355. __bang_int82tf32_oz \n^^^^^^^^^^^^^^^\n void  __bang_int82tf32_oz (float * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  tf32  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82tf32_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.356. __bang_int82tf32_rd \n^^^^^^^^^^^^^^^\n void  __bang_int82tf32_rd (float * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  tf32  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82tf32_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.357. __bang_int82tf32_rm \n^^^^^^^^^^^^^^^\n void  __bang_int82tf32_rm (float * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  tf32  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82tf32_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.358. __bang_int82tf32_rn \n^^^^^^^^^^^^^^^\n void  __bang_int82tf32_rn (float * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  tf32  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82tf32_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.359. __bang_int82tf32_tz \n^^^^^^^^^^^^^^^\n void  __bang_int82tf32_tz (float * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  tf32  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82tf32_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.360. __bang_int82tf32_up \n^^^^^^^^^^^^^^^\n void  __bang_int82tf32_up (float * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  tf32  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(float *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82tf32_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.361. __bang_int82uchar \n^^^^^^^^^^^^^^^\n void  __bang_int82uchar (unsigned char * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  unsigned char  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82uchar(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.362. __bang_int82uchar_dn \n^^^^^^^^^^^^^^^\n void  __bang_int82uchar_dn (unsigned char * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  unsigned char  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82uchar_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.363. __bang_int82uchar_oz \n^^^^^^^^^^^^^^^\n void  __bang_int82uchar_oz (unsigned char * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  unsigned char  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82uchar_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.364. __bang_int82uchar_rd \n^^^^^^^^^^^^^^^\n void  __bang_int82uchar_rd (unsigned char * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  unsigned char  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82uchar_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.365. __bang_int82uchar_rm \n^^^^^^^^^^^^^^^\n void  __bang_int82uchar_rm (unsigned char * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  unsigned char  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82uchar_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.366. __bang_int82uchar_rn \n^^^^^^^^^^^^^^^\n void  __bang_int82uchar_rn (unsigned char * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  unsigned char  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82uchar_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.367. __bang_int82uchar_tz \n^^^^^^^^^^^^^^^\n void  __bang_int82uchar_tz (unsigned char * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  unsigned char  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82uchar_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.368. __bang_int82uchar_up \n^^^^^^^^^^^^^^^\n void  __bang_int82uchar_up (unsigned char * dst ,  const  int8_t * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  int8\\_t  to  unsigned char  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(unsigned char *dst, int8_t *src) {\n  __nram__ int8_t src_nram[LEN];\n  __nram__ unsigned char dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(int8_t), GDRAM2NRAM);\n  __bang_int82uchar_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(unsigned char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.369. __bang_short2half \n^^^^^^^^^^^^^^^\n void  __bang_short2half (half * dst ,  const  short * src , unsigned int  src_count )   \n void  __bang_short2half (half * dst ,  const  short * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  short  to  half  element-wisely in round-to-zero mode and saves the result in  <dst> .  <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-to-zero mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(half) , and divisible by 64 on  (m)tp\\_2xx , and divisible by sizeof(half) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(short);\n* (  \\div sizeof(short) \\ge  ) if  <src\\_stride>  is greater than zero;\n*  <src>  can be overlapped with  <dst> . \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SRC_STRIDE 160 \n define DST_STRIDE 320 \n define LEN 128 \n define SEG_NUM 20 \n __mlu_entry__ void kernel(half *dst, short *src, int size) {\n  __nram__ short src_tmp[SRC_STRIDE * SEG_NUM + LEN];\n  __nram__ half dst_tmp[DST_STRIDE / sizeof(half) * SEG_NUM + LEN];\n  __memcpy(src_tmp, src, size * sizeof(short), GDRAM2NRAM);\n  __bang_short2half(dst_tmp, src_tmp, LEN, DST_STRIDE, SRC_STRIDE, SEG_NUM);\n  __memcpy(dst, dst_tmp, (DST_STRIDE * SEG_NUM + LEN * sizeof(half)), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.370. __bang_tf322bfloat16 \n^^^^^^^^^^^^^^^\n void  __bang_tf322bfloat16 (bfloat16_t * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  bfloat16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322bfloat16(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.371. __bang_tf322bfloat16_dn \n^^^^^^^^^^^^^^^\n void  __bang_tf322bfloat16_dn (bfloat16_t * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  bfloat16\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322bfloat16_dn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.372. __bang_tf322bfloat16_oz \n^^^^^^^^^^^^^^^\n void  __bang_tf322bfloat16_oz (bfloat16_t * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  bfloat16\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322bfloat16_oz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.373. __bang_tf322bfloat16_rd \n^^^^^^^^^^^^^^^\n void  __bang_tf322bfloat16_rd (bfloat16_t * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  bfloat16\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322bfloat16_rd(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.374. __bang_tf322bfloat16_rm \n^^^^^^^^^^^^^^^\n void  __bang_tf322bfloat16_rm (bfloat16_t * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  bfloat16\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322bfloat16_rm(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.375. __bang_tf322bfloat16_rn \n^^^^^^^^^^^^^^^\n void  __bang_tf322bfloat16_rn (bfloat16_t * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  bfloat16\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322bfloat16_rn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.376. __bang_tf322bfloat16_tz \n^^^^^^^^^^^^^^^\n void  __bang_tf322bfloat16_tz (bfloat16_t * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  bfloat16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322bfloat16_tz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.377. __bang_tf322bfloat16_up \n^^^^^^^^^^^^^^^\n void  __bang_tf322bfloat16_up (bfloat16_t * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  bfloat16\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(bfloat16_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322bfloat16_up(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.378. __bang_tf322float \n^^^^^^^^^^^^^^^\n void  __bang_tf322float (float * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  float  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322float(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.379. __bang_tf322float_dn \n^^^^^^^^^^^^^^^\n void  __bang_tf322float_dn (float * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  float  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322float_dn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.380. __bang_tf322float_oz \n^^^^^^^^^^^^^^^\n void  __bang_tf322float_oz (float * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  float  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322float_oz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.381. __bang_tf322float_rd \n^^^^^^^^^^^^^^^\n void  __bang_tf322float_rd (float * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  float  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322float_rd(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.382. __bang_tf322float_rm \n^^^^^^^^^^^^^^^\n void  __bang_tf322float_rm (float * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  float  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322float_rm(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.383. __bang_tf322float_rn \n^^^^^^^^^^^^^^^\n void  __bang_tf322float_rn (float * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  float  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322float_rn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.384. __bang_tf322float_tz \n^^^^^^^^^^^^^^^\n void  __bang_tf322float_tz (float * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  float  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322float_tz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.385. __bang_tf322float_up \n^^^^^^^^^^^^^^^\n void  __bang_tf322float_up (float * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  float  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322float_up(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.386. __bang_tf322half \n^^^^^^^^^^^^^^^\n void  __bang_tf322half (half * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  half  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(half *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ half dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322half(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.387. __bang_tf322half_dn \n^^^^^^^^^^^^^^^\n void  __bang_tf322half_dn (half * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  half  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(half *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ half dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322half_dn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.388. __bang_tf322half_oz \n^^^^^^^^^^^^^^^\n void  __bang_tf322half_oz (half * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  half  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(half *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ half dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322half_oz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.389. __bang_tf322half_rd \n^^^^^^^^^^^^^^^\n void  __bang_tf322half_rd (half * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  half  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(half *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ half dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322half_rd(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.390. __bang_tf322half_rm \n^^^^^^^^^^^^^^^\n void  __bang_tf322half_rm (half * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  half  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(half *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ half dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322half_rm(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.391. __bang_tf322half_rn \n^^^^^^^^^^^^^^^\n void  __bang_tf322half_rn (half * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  half  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(half *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ half dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322half_rn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.392. __bang_tf322half_tz \n^^^^^^^^^^^^^^^\n void  __bang_tf322half_tz (half * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  half  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(half *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ half dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322half_tz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.393. __bang_tf322half_up \n^^^^^^^^^^^^^^^\n void  __bang_tf322half_up (half * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  half  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(half *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ half dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322half_up(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(half), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.394. __bang_tf322int16 \n^^^^^^^^^^^^^^^\n void  __bang_tf322int16 (int16_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int16(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.395. __bang_tf322int16_dn \n^^^^^^^^^^^^^^^\n void  __bang_tf322int16_dn (int16_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int16\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int16_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.396. __bang_tf322int16_oz \n^^^^^^^^^^^^^^^\n void  __bang_tf322int16_oz (int16_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int16\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int16_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.397. __bang_tf322int16_rd \n^^^^^^^^^^^^^^^\n void  __bang_tf322int16_rd (int16_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int16\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int16_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.398. __bang_tf322int16_rm \n^^^^^^^^^^^^^^^\n void  __bang_tf322int16_rm (int16_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int16\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int16_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.399. __bang_tf322int16_rn \n^^^^^^^^^^^^^^^\n void  __bang_tf322int16_rn (int16_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int16\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int16_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.400. __bang_tf322int16_tz \n^^^^^^^^^^^^^^^\n void  __bang_tf322int16_tz (int16_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int16_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.401. __bang_tf322int16_up \n^^^^^^^^^^^^^^^\n void  __bang_tf322int16_up (int16_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int16\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int16_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.402. __bang_tf322int32 \n^^^^^^^^^^^^^^^\n void  __bang_tf322int32 (int32_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int32\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int32(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.403. __bang_tf322int32_dn \n^^^^^^^^^^^^^^^\n void  __bang_tf322int32_dn (int32_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int32\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int32_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.404. __bang_tf322int32_oz \n^^^^^^^^^^^^^^^\n void  __bang_tf322int32_oz (int32_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int32\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int32_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.405. __bang_tf322int32_rd \n^^^^^^^^^^^^^^^\n void  __bang_tf322int32_rd (int32_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int32\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int32_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.406. __bang_tf322int32_rm \n^^^^^^^^^^^^^^^\n void  __bang_tf322int32_rm (int32_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int32\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int32_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.407. __bang_tf322int32_rn \n^^^^^^^^^^^^^^^\n void  __bang_tf322int32_rn (int32_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int32\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int32_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.408. __bang_tf322int32_tz \n^^^^^^^^^^^^^^^\n void  __bang_tf322int32_tz (int32_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int32\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int32_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.409. __bang_tf322int32_up \n^^^^^^^^^^^^^^^\n void  __bang_tf322int32_up (int32_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int32\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int32_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.410. __bang_tf322int4 \n^^^^^^^^^^^^^^^\n void  __bang_tf322int4 (int4x2_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int4x2\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int4x2_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int4x2_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int4(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int4x2_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.411. __bang_tf322int4_dn \n^^^^^^^^^^^^^^^\n void  __bang_tf322int4_dn (int4x2_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int4x2\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int4x2_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int4x2_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int4_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int4x2_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.412. __bang_tf322int4_oz \n^^^^^^^^^^^^^^^\n void  __bang_tf322int4_oz (int4x2_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int4x2\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int4x2_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int4x2_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int4_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int4x2_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.413. __bang_tf322int4_rd \n^^^^^^^^^^^^^^^\n void  __bang_tf322int4_rd (int4x2_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int4x2\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int4x2_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int4x2_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int4_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int4x2_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.414. __bang_tf322int4_rm \n^^^^^^^^^^^^^^^\n void  __bang_tf322int4_rm (int4x2_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int4x2\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int4x2_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int4x2_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int4_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int4x2_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.415. __bang_tf322int4_rn \n^^^^^^^^^^^^^^^\n void  __bang_tf322int4_rn (int4x2_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int4x2\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int4x2_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int4x2_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int4_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int4x2_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.416. __bang_tf322int4_tz \n^^^^^^^^^^^^^^^\n void  __bang_tf322int4_tz (int4x2_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int4x2\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int4x2_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int4x2_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int4_tz(dst_nram, src_nram, LEN ,FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int4x2_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.417. __bang_tf322int4_up \n^^^^^^^^^^^^^^^\n void  __bang_tf322int4_up (int4x2_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int4x2\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int4x2_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int4x2_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int4_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int4x2_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.418. __bang_tf322int8 \n^^^^^^^^^^^^^^^\n void  __bang_tf322int8 (int8_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int8\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int8(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.419. __bang_tf322int8_dn \n^^^^^^^^^^^^^^^\n void  __bang_tf322int8_dn (int8_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int8\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int8_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.420. __bang_tf322int8_oz \n^^^^^^^^^^^^^^^\n void  __bang_tf322int8_oz (int8_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int8\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int8_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.421. __bang_tf322int8_rd \n^^^^^^^^^^^^^^^\n void  __bang_tf322int8_rd (int8_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int8\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int8_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.422. __bang_tf322int8_rm \n^^^^^^^^^^^^^^^\n void  __bang_tf322int8_rm (int8_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int8\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int8_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.423. __bang_tf322int8_rn \n^^^^^^^^^^^^^^^\n void  __bang_tf322int8_rn (int8_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int8\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int8_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.424. __bang_tf322int8_tz \n^^^^^^^^^^^^^^^\n void  __bang_tf322int8_tz (int8_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int8\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int8_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.425. __bang_tf322int8_up \n^^^^^^^^^^^^^^^\n void  __bang_tf322int8_up (int8_t * dst ,  const  float * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  tf32  to  int8\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, float *src) {\n  __nram__ float src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322int8_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.426. __bang_tf322uchar \n^^^^^^^^^^^^^^^\n void  __bang_tf322uchar (unsigned char * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  unsigned char  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, float *src) {\n  __nram__ unsigned char dst_nram[LEN];\n  __nram__ float src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322uchar(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.427. __bang_tf322uchar_dn \n^^^^^^^^^^^^^^^\n void  __bang_tf322uchar_dn (unsigned char * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  unsigned char  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, float *src) {\n  __nram__ unsigned char dst_nram[LEN];\n  __nram__ float src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322uchar_dn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.428. __bang_tf322uchar_oz \n^^^^^^^^^^^^^^^\n void  __bang_tf322uchar_oz (unsigned char * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  unsigned char  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, float *src) {\n  __nram__ unsigned char dst_nram[LEN];\n  __nram__ float src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322uchar_oz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.429. __bang_tf322uchar_rd \n^^^^^^^^^^^^^^^\n void  __bang_tf322uchar_rd (unsigned char * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  unsigned char  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, float *src) {\n  __nram__ unsigned char dst_nram[LEN];\n  __nram__ float src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322uchar_rd(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.430. __bang_tf322uchar_rm \n^^^^^^^^^^^^^^^\n void  __bang_tf322uchar_rm (unsigned char * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  unsigned char  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, float *src) {\n  __nram__ unsigned char dst_nram[LEN];\n  __nram__ float src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322uchar_rm(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.431. __bang_tf322uchar_rn \n^^^^^^^^^^^^^^^\n void  __bang_tf322uchar_rn (unsigned char * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  unsigned char  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, float *src) {\n  __nram__ unsigned char dst_nram[LEN];\n  __nram__ float src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322uchar_rn(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.432. __bang_tf322uchar_tz \n^^^^^^^^^^^^^^^\n void  __bang_tf322uchar_tz (unsigned char * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  unsigned char  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, float *src) {\n  __nram__ unsigned char dst_nram[LEN];\n  __nram__ float src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322uchar_tz(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.433. __bang_tf322uchar_up \n^^^^^^^^^^^^^^^\n void  __bang_tf322uchar_up (unsigned char * dst ,  const  float * src , unsigned int  count )   \n This function converts type of  <src>  from  tf32  to  unsigned char  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(unsigned char *dst, float *src) {\n  __nram__ unsigned char dst_nram[LEN];\n  __nram__ float src_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(float), GDRAM2NRAM);\n  __bang_tf322uchar_up(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.434. __bang_uchar2bfloat16 \n^^^^^^^^^^^^^^^\n void  __bang_uchar2bfloat16 (bfloat16_t * dst ,  const  unsigned char * src , unsigned int  count )   \n This function converts type of  <src>  from  unsigned char  to  bfloat16\\_t  element-wisely and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(bfloat16_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ bfloat16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2bfloat16(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(bfloat16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.435. __bang_uchar2float \n^^^^^^^^^^^^^^^\n void  __bang_uchar2float (float * dst ,  const  unsigned char * src , unsigned int  count )   \n This function converts type of  <src>  from  unsigned char  to  float  element-wisely and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(unsigned char), GDRAM2NRAM);\n  __bang_uchar2float(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.436. __bang_uchar2half \n^^^^^^^^^^^^^^^\n void  __bang_uchar2half (half * dst ,  const  unsigned char * src , unsigned int  src_count )   \n void  __bang_uchar2half (half * dst ,  const  unsigned char * src , unsigned int  src_count , unsigned int  dst_stride , unsigned int  src_stride , unsigned int  segnum )   \n This function converts type of  <src>  from  unsigned char  to  half  element-wisely in round-to-zero mode and saves the result in  <dst> .  <src>  includes  <segnum> + 1  blocks, and each block consists of  <src\\_stride>  bytes.  <dst>  includes  <segnum> + 1  blocks, and each block consists of  <dst\\_stride>  bytes. In each block of  <src> , this function converts first  <src\\_count>  elements in round-to-zero mode, and saves the result in blocks in  <dst>  sequentially. If  <src\\_stride>  is zero, this function only converts the first block  <segnum> + 1  times. \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] dst\\_stride : The destination stride in bytes.\n*  [in] src\\_stride : The source stride in bytes.\n*  [in] segnum : The number of segments minus one. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <dst\\_stride>  must be greater than or equal to  <src\\_count> \\* sizeof(half) , and divisible by 64 on  (m)tp\\_2xx , and divisible by sizeof(half) on  (m)tp\\_3xx  or higher;\n*  <src\\_stride>  must be divisible by sizeof(unsigned char);\n*  <src>  cannot be overlapped with  <dst> ;\n* (  \\div sizeof(unsigned char) \\ge  ) if  <src\\_stride>  is greater than zero. \n Instruction Pipeline * Execute in Move instruction pipeline if the conversion function has  <src\\_stride>  and  <dst\\_stride> ;\n* Execute in Compute instruction pipeline, otherwise. \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define SRC_STRIDE 160 \n define DST_STRIDE 320 \n define LEN 128 \n define SEG_NUM 20 \n __mlu_entry__ void kernel(half *dst, unsigned char *src, int size) {\n  __nram__ unsigned char src_tmp[SRC_STRIDE * SEG_NUM + LEN];\n  __nram__ half dst_tmp[DST_STRIDE / sizeof(half) * SEG_NUM + LEN];\n  __memcpy(src_tmp, src, size, GDRAM2NRAM);\n  __bang_uchar2half(dst_tmp, src_tmp, LEN, DST_STRIDE, SRC_STRIDE, SEG_NUM);\n  __memcpy(dst, dst_tmp, (DST_STRIDE * SEG_NUM + LEN * sizeof(half)), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.437. __bang_uchar2int16 \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int16 (int16_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int16(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.438. __bang_uchar2int16_dn \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int16_dn (int16_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int16\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int16_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.439. __bang_uchar2int16_oz \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int16_oz (int16_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int16\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int16_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.440. __bang_uchar2int16_rd \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int16_rd (int16_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int16\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int16_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.441. __bang_uchar2int16_rm \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int16_rm (int16_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int16\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int16_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.442. __bang_uchar2int16_rn \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int16_rn (int16_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int16\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int16_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.443. __bang_uchar2int16_tz \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int16_tz (int16_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int16\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(unsigned char), GDRAM2NRAM);\n  __bang_uchar2int16_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.444. __bang_uchar2int16_up \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int16_up (int16_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int16\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int16_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int16_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int16_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.445. __bang_uchar2int32 \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int32 (int32_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int32\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int32(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.446. __bang_uchar2int32_dn \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int32_dn (int32_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int32\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int32_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.447. __bang_uchar2int32_oz \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int32_oz (int32_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int32\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int32_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.448. __bang_uchar2int32_rd \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int32_rd (int32_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int32\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int32_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.449. __bang_uchar2int32_rm \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int32_rm (int32_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int32\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int32_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.450. __bang_uchar2int32_rn \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int32_rn (int32_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int32\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int32_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.451. __bang_uchar2int32_tz \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int32_tz (int32_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int32\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int32_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.452. __bang_uchar2int32_up \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int32_up (int32_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int32\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int32_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int32_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int32_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int32_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.453. __bang_uchar2int4 \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int4 (int4x2_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int4x2\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int4x2_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int4x2_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int4(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.454. __bang_uchar2int4_dn \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int4_dn (int4x2_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int4x2\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int4x2_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int4x2_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int4_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.455. __bang_uchar2int4_oz \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int4_oz (int4x2_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int4x2\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int4x2_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int4x2_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int4_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.456. __bang_uchar2int4_rd \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int4_rd (int4x2_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int4x2\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int4x2_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int4x2_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int4_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.457. __bang_uchar2int4_rm \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int4_rm (int4x2_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int4x2\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int4x2_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int4x2_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int4_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.458. __bang_uchar2int4_rn \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int4_rn (int4x2_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int4x2\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int4x2_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int4x2_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int4_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.459. __bang_uchar2int4_tz \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int4_tz (int4x2_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int4x2\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(nt4x2_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int4x2_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int4_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.460. __bang_uchar2int4_up \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int4_up (int4x2_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int4x2\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero and divisible by 2;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int4x2_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int4x2_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int4_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(char), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.461. __bang_uchar2int8 \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int8 (int8_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int8\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\div 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int8(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.462. __bang_uchar2int8_dn \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int8_dn (int8_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int8\\_t  element-wisely in round-down mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\div 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int8_dn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.463. __bang_uchar2int8_oz \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int8_oz (int8_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int8\\_t  element-wisely in round-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\div 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int8_oz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.464. __bang_uchar2int8_rd \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int8_rd (int8_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int8\\_t  element-wisely in round-nearest-off-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\div 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int8_rd(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.465. __bang_uchar2int8_rm \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int8_rm (int8_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int8\\_t  element-wisely in round-math mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\div 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int8_rm(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.466. __bang_uchar2int8_rn \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int8_rn (int8_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int8\\_t  element-wisely in round-nearest-even mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\div 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int8_rn(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.467. __bang_uchar2int8_tz \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int8_tz (int8_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int8\\_t  element-wisely in round-to-zero mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\div 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(unsigned char), GDRAM2NRAM);\n  __bang_uchar2int8_tz(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.468. __bang_uchar2int8_up \n^^^^^^^^^^^^^^^\n void  __bang_uchar2int8_up (int8_t * dst ,  const  unsigned char * src , unsigned int  count , int  fix_position )   \n This function converts type of  <src>  from  unsigned char  to  int8\\_t  element-wisely in round-up mode and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements.\n*  [in] fix\\_position : Scale factor of destination vector, i.e., (  \\div 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  can be overlapped with  <dst> ;\n*  <fix\\_position>  must be in the range  [-127,127] . \n ^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n define FIX_POSITION 2 \n __mlu_entry__ void kernel(int8_t *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ int8_t dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2int8_up(dst_nram, src_nram, LEN, FIX_POSITION);\n  __memcpy(dst, dst_nram, LEN * sizeof(int8_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.469. __bang_uchar2tf32 \n^^^^^^^^^^^^^^^\n void  __bang_uchar2tf32 (float * dst ,  const  unsigned char * src , unsigned int  count )   \n This function converts type of  <src>  from  unsigned char  to  tf32  element-wisely and saves the result in  <dst> . \n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] count : The number of elements. \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <count>  must be greater than zero;\n*  <src>  cannot be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\n Example \n``` \n include  \n define LEN 128 \n __mlu_entry__ void kernel(float *dst, unsigned char *src) {\n  __nram__ unsigned char src_nram[LEN];\n  __nram__ float dst_nram[LEN];\n  __memcpy(src_nram, src, LEN * sizeof(char), GDRAM2NRAM);\n  __bang_uchar2tf32(dst_nram, src_nram, LEN);\n  __memcpy(dst, dst_nram, LEN * sizeof(float), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.470. __bang_uint162float \n^^^^^^^^^^^^^^^\n void  __bang_uint162float (float * dst ,  const  uint16_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  uint16\\_t  to  float  element-wisely in round-to-zero mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  cannot be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(float *dst, uint16_t *src) {\n  __nram__ uint16_t src_tmp[SIZE];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_uint162float(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(uint16_t), NRAM2GDRAM);\n} \n ``` \n"
  },
  {
    "content": "\n 3.30.471. __bang_uint322float \n^^^^^^^^^^^^^^^\n void  __bang_uint322float (float * dst ,  const  uint32_t * src , unsigned int  src_count , int  fix_position )   \n This function converts type of  <src>  from  uint32\\_t  to  float  element-wisely in round-to-zero mode and saves the result in  <dst> .\n^^^^^^^^^^^^^^^\n Parameters *  [out] dst : The address of destination vector.\n*  [in] src : The address of source vector.\n*  [in] src\\_count : The number of elements.\n*  [in] fix\\_position : Scale factor of source vector, i.e., (  \\times 2^{ }). \n^^^^^^^^^^^^^^^\n Return *  void . \n^^^^^^^^^^^^^^^\n Remark *  <src>  and  <dst>  must point to  \\_\\_nram\\_\\_  address space;\n*  <src\\_count>  must be greater than zero;\n*  <fix\\_position>  must be in the range  [-127,127] ;\n*  <src>  cannot be overlapped with  <dst> . \n^^^^^^^^^^^^^^^\nExample \n``` \n include  \n define SIZE 128 \n define POS 5 \n __mlu_entry__ void kernel(float *dst, uint32_t *src) {\n  __nram__ uint32_t src_tmp[SIZE];\n  __nram__ float dst_tmp[SIZE];\n  __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);\n  __bang_uint322float(dst_tmp, src_tmp, SIZE, POS);\n  __memcpy(dst, dst_tmp, SIZE * sizeof(uint32_t), NRAM2GDRAM);\n} \n ``` \n"
  }
]